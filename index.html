<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>Performa - Voice Fitness Tracker</title>
  
  <!-- PWA Meta Tags -->
  <meta name="description" content="AI-powered fitness tracker with voice commands and custom feedback">
  <meta name="theme-color" content="#00796b">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-mobile-web-app-title" content="Performa">
  <meta name="msapplication-TileColor" content="#00796b">
  
  <!-- Web App Manifest -->
  <link href="manifest.json" rel="manifest"/>
  
  <!-- Apple Touch Icons -->
  <link rel="apple-touch-icon" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgwIiBoZWlnaHQ9IjE4MCIgdmlld0JveD0iMCAwIDE4MCAxODAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxODAiIGhlaWdodD0iMTgwIiByeD0iMjIiIGZpbGw9IiMwMDc5NmIiLz4KPHN2ZyB4PSI0NSIgeT0iNDUiIHdpZHRoPSI5MCIgaGVpZ2h0PSI5MCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSIjZmZmZmZmIj4KICA8cGF0aCBkPSJNMTIgMmMtNC45NyAwLTkgNC4wMy05IDl2N2MwIDEuNjYgMS4zNCAzIDMgM2gxdjVoMlYxNGg0djdoMlYxNGgxYzEuNjYgMCAzLTEuMzQgMy0zVjExYzAtNC45Ny00LjAzLTktOS05ek03LjUgMTNjLS44MyAwLTEuNS0uNjctMS41LTEuNXMuNjctMS41IDEuNS0xLjUgMS41LjY3IDEuNSAxLjUtLjY3IDEuNS0xLjUgMS41em05IDBjLS44MyAwLTEuNS0uNjctMS41LTEuNXMuNjctMS41IDEuNS0xLjUgMS41LjY3IDEuNSAxLjUtLjY3IDEuNS0xLjUgMS41eiIvPgo8L3N2Zz4KPC9zdmc+">
  
  <!-- Favicon -->
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiByeD0iNCIgZmlsbD0iIzAwNzk2YiIvPgo8c3ZnIHg9IjgiIHk9IjgiIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSIjZmZmZmZmIj4KICA8cGF0aCBkPSJNMTIgMmMtNC45NyAwLTkgNC4wMy05IDl2N2MwIDEuNjYgMS4zNCAzIDMgM2gxdjVoMlYxNGg0djdoMlYxNGgxYzEuNjYgMCAzLTEuMzQgMy0zVjExYzAtNC45Ny00LjAzLTktOS05ek03LjUgMTNjLS44MyAwLTEuNS0uNjctMS41LTEuNXMuNjctMS41IDEuNS0xLjUgMS41LjY3IDEuNSAxLjUtLjY3IDEuNS0xLjUgMS41em05IDBjLS44MyAwLTEuNS0uNjctMS41LTEuNXMuNjctMS41IDEuNS0xLjUgMS41LjY3IDEuNSAxLjUtLjY3IDEuNS0xLjUgMS41eiIvPgo8L3N2Zz4KPC9zdmc+">
  <!-- External dependencies with error handling -->
  <script>
    // Load Chart.js with fallback
    (function() {
      const script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/chart.js';
      script.onerror = () => console.log('Chart.js failed to load - charts will be disabled');
      document.head.appendChild(script);
    })();
    
    // Load html2canvas with fallback
    (function() {
      const script = document.createElement('script');
      script.src = 'https://html2canvas.hertzen.com/dist/html2canvas.min.js';
      script.onerror = () => console.log('html2canvas failed to load - image capture will be disabled');
      document.head.appendChild(script);
    })();
  </script>
  
  <!-- Memory Manager (inlined) -->
  <script>
// Memory Manager for Performa Tracker - ENHANCED VERSION WITH LEAK FIXES
// Comprehensive memory management with cleanup tracking

class MemoryManager {
  constructor() {
    this.memoryData = null;
    this.timers = new Set(); // Track all timers
    this.intervals = new Set(); // Track all intervals
    this.eventListeners = new Map(); // Track event listeners
    this.voiceRecognizers = new Set(); // Track voice recognition instances
    this.audioContexts = new Set(); // Track audio contexts
    this.domCache = new Map(); // Cache DOM elements
    this.init();
  }

  init() {
    this.createMemoryUI();
    this.loadMemoryUsage();
    this.setupGlobalCleanup();
    this.patchTimerMethods();
  }

  // Patch timer methods to track them
  patchTimerMethods() {
    const originalSetTimeout = window.setTimeout;
    const originalClearTimeout = window.clearTimeout;
    const originalSetInterval = window.setInterval;
    const originalClearInterval = window.clearInterval;

    window.setTimeout = (callback, delay, ...args) => {
      const id = originalSetTimeout(callback, delay, ...args);
      this.timers.add(id);
      return id;
    };

    window.clearTimeout = (id) => {
      this.timers.delete(id);
      return originalClearTimeout(id);
    };

    window.setInterval = (callback, delay, ...args) => {
      const id = originalSetInterval(callback, delay, ...args);
      this.intervals.add(id);
      return id;
    };

    window.clearInterval = (id) => {
      this.intervals.delete(id);
      return originalClearInterval(id);
    };
  }

  // Setup global cleanup handlers
  setupGlobalCleanup() {
    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      this.performCompleteCleanup();
    });

    // Cleanup on visibility change
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        this.performPartialCleanup();
      }
    });

    // Global error handlers
    window.addEventListener('error', (event) => {
      console.error('Global error:', event.error);
    });

    window.addEventListener('unhandledrejection', (event) => {
      console.error('Unhandled promise rejection:', event.reason);
      event.preventDefault();
    });
  }

  // Perform complete cleanup
  performCompleteCleanup() {
    console.log('Performing complete memory cleanup...');
    
    // Clear all timers
    this.timers.forEach(id => clearTimeout(id));
    this.intervals.forEach(id => clearInterval(id));
    this.timers.clear();
    this.intervals.clear();

    // Stop all voice recognizers
    this.voiceRecognizers.forEach(recognizer => {
      try {
        recognizer.stop();
        recognizer.abort();
      } catch (e) {
        console.warn('Error stopping voice recognizer:', e);
      }
    });
    this.voiceRecognizers.clear();

    // Close all audio contexts
    this.audioContexts.forEach(context => {
      try {
        context.close();
      } catch (e) {
        console.warn('Error closing audio context:', e);
      }
    });
    this.audioContexts.clear();

    // Clear DOM cache
    this.domCache.clear();
  }

  // Perform partial cleanup
  performPartialCleanup() {
    // Stop voice recognition when tab is hidden
    this.voiceRecognizers.forEach(recognizer => {
      try {
        recognizer.stop();
      } catch (e) {
        console.warn('Error stopping voice recognizer:', e);
      }
    });

    // Suspend audio contexts
    this.audioContexts.forEach(context => {
      try {
        if (context.state === 'running') {
          context.suspend();
        }
      } catch (e) {
        console.warn('Error suspending audio context:', e);
      }
    });
  }

  // Register voice recognizer for cleanup
  registerVoiceRecognizer(recognizer) {
    this.voiceRecognizers.add(recognizer);
  }

  // Register audio context for cleanup
  registerAudioContext(context) {
    this.audioContexts.add(context);
  }

  // Get cached DOM element
  getCachedElement(id) {
    if (this.domCache.has(id)) {
      return this.domCache.get(id);
    }
    const element = document.getElementById(id);
    if (element) {
      this.domCache.set(id, element);
    }
    return element;
  }

  // Create the memory management UI
  createMemoryUI() {
    const memorySection = document.createElement('div');
    memorySection.className = 'memory-management-section';
    memorySection.innerHTML = `
      <div class="settings-section">
        <div class="settings-title">üìä Memory Management</div>
        
        <!-- Memory Usage Overview -->
        <div class="memory-overview">
          <div class="memory-total">
            <span class="memory-label">Total App Size:</span>
            <span id="totalMemoryUsage" class="memory-value">Calculating...</span>
          </div>
          <div class="memory-quota">
            <span class="memory-label">Available Storage:</span>
            <span id="storageQuota" class="memory-value">Checking...</span>
          </div>
          <div id="memoryProgressBar" class="memory-progress-bar">
            <div class="memory-progress-fill"></div>
          </div>
          <div class="memory-status" id="memoryStatus">Analyzing memory usage...</div>
        </div>

        <!-- Memory Breakdown -->
        <div class="memory-breakdown" id="memoryBreakdown" style="display: none;">
          <h4>Memory Breakdown:</h4>
          <div class="breakdown-items"></div>
        </div>

        <!-- Recommendations -->
        <div class="memory-recommendations" id="memoryRecommendations" style="display: none;">
          <h4>üí° Recommendations:</h4>
          <div class="recommendation-items"></div>
        </div>

        <!-- Archive Cleanup Section -->
        <div class="archive-cleanup-section">
          <h4>üóëÔ∏è Archive Data Cleanup</h4>
          
          <!-- Quick Cleanup Options -->
          <div class="quick-cleanup">
            <div class="cleanup-option">
              <button id="smartCleanupBtn" class="cleanup-btn smart">
                <span class="btn-icon">üßπ</span>
                <div class="btn-content">
                  <div class="btn-title">Smart Cleanup</div>
                  <div class="btn-desc">Keep recent data & achievements</div>
                </div>
              </button>
            </div>
            
            <div class="cleanup-option">
              <button id="customCleanupBtn" class="cleanup-btn custom">
                <span class="btn-icon">üìÖ</span>
                <div class="btn-content">
                  <div class="btn-title">Custom Date Range</div>
                  <div class="btn-desc">Choose specific dates to clean</div>
                </div>
              </button>
            </div>
          </div>

          <!-- Smart Cleanup Settings -->
          <div id="smartCleanupSettings" class="cleanup-settings" style="display: none;">
            <h5>Smart Cleanup Settings:</h5>
            <div class="setting-row">
              <label>Keep last <input type="number" id="keepDays" value="90" min="1" max="365"> days</label>
            </div>
            <div class="setting-row">
              <label>Maximum entries: <input type="number" id="maxEntries" value="500" min="50" max="2000"></label>
            </div>
            <div class="setting-info">
              <small>üõ°Ô∏è Important data (achievements, PRs, voice notes) will always be preserved</small>
            </div>
            <button id="executeSmartCleanup" class="execute-btn">Execute Smart Cleanup</button>
          </div>

          <!-- Custom Date Range Settings -->
          <div id="customCleanupSettings" class="cleanup-settings" style="display: none;">
            <h5>Custom Date Range Cleanup:</h5>
            <div class="date-range">
              <div class="date-input">
                <label>From: <input type="date" id="cleanupStartDate"></label>
              </div>
              <div class="date-input">
                <label>To: <input type="date" id="cleanupEndDate"></label>
              </div>
            </div>
            
            <div class="data-type-selection">
              <h6>Data Types to Clean:</h6>
              <div class="checkbox-group">
                <label><input type="checkbox" value="exercise-data" checked> Exercise Data</label>
                <label><input type="checkbox" value="voice-recordings"> Voice Recordings</label>
                <label><input type="checkbox" value="route-images"> Route Images</label>
                <label><input type="checkbox" value="map-cache"> Map Cache</label>
              </div>
            </div>
            
            <div class="cleanup-preview" id="cleanupPreview" style="display: none;">
              <div class="preview-content">
                <span class="preview-label">Will delete:</span>
                <span id="previewSize" class="preview-value">Calculating...</span>
              </div>
            </div>
            
            <div class="custom-cleanup-actions">
              <button id="previewCustomCleanup" class="preview-btn">Preview Cleanup</button>
              <button id="executeCustomCleanup" class="execute-btn" disabled>Execute Cleanup</button>
            </div>
          </div>
        </div>

        <!-- Cleanup Results -->
        <div id="cleanupResults" class="cleanup-results" style="display: none;">
          <div class="results-content">
            <h5>‚úÖ Cleanup Complete!</h5>
            <div class="results-stats"></div>
          </div>
        </div>
      </div>
    `;

    // Add CSS styles
    this.addMemoryStyles();

    // Find settings container and add memory section
    const settingsContainer = document.querySelector('.settings-content') || document.querySelector('#settingsContent');
    if (settingsContainer) {
      settingsContainer.appendChild(memorySection);
      this.bindEvents();
    }
  }

  // Add CSS styles for memory management
  addMemoryStyles() {
    if (document.getElementById('memory-manager-styles')) return;

    const style = document.createElement('style');
    style.id = 'memory-manager-styles';
    style.textContent = `
      .memory-management-section {
        margin: 20px 0;
        padding: 20px;
        background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        border-radius: 12px;
        border: 1px solid #e1e8ed;
      }

      .memory-overview {
        background: white;
        padding: 20px;
        border-radius: 8px;
        margin-bottom: 20px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      }

      .memory-total, .memory-quota {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }

      .memory-quota {
        padding-top: 10px;
        border-top: 1px solid #e0e0e0;
        font-size: 0.9em;
        color: #666;
      }

      .memory-label {
        font-weight: 600;
        color: #333;
      }

      .memory-value {
        font-size: 1.2em;
        font-weight: bold;
        color: #00796b;
      }

      .memory-progress-bar {
        width: 100%;
        height: 8px;
        background: #e0e0e0;
        border-radius: 4px;
        overflow: hidden;
        margin-bottom: 10px;
      }

      .memory-progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #4CAF50, #FF9800, #F44336);
        border-radius: 4px;
        transition: width 0.3s ease;
      }

      .memory-status {
        font-size: 0.9em;
        color: #666;
        text-align: center;
      }

      .memory-breakdown, .memory-recommendations {
        background: white;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 15px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }

      .breakdown-items, .recommendation-items {
        display: grid;
        gap: 10px;
        margin-top: 10px;
      }

      .breakdown-item, .recommendation-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 12px;
        background: #f8f9fa;
        border-radius: 6px;
        border-left: 4px solid #00796b;
      }

      .recommendation-item {
        border-left-color: #ff9800;
      }

      .recommendation-item.high {
        border-left-color: #f44336;
        background: #fff3e0;
      }

      .archive-cleanup-section {
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      }

      .quick-cleanup {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 15px;
        margin-bottom: 20px;
      }

      .cleanup-btn {
        display: flex;
        align-items: center;
        padding: 15px;
        border: 2px solid #e0e0e0;
        border-radius: 8px;
        background: white;
        cursor: pointer;
        transition: all 0.3s ease;
        width: 100%;
      }

      .cleanup-btn:hover {
        border-color: #00796b;
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
      }

      .cleanup-btn.active {
        border-color: #00796b;
        background: #e0f2f1;
      }

      .btn-icon {
        font-size: 1.5em;
        margin-right: 12px;
      }

      .btn-title {
        font-weight: 600;
        color: #333;
        margin-bottom: 4px;
      }

      .btn-desc {
        font-size: 0.85em;
        color: #666;
      }

      .cleanup-settings {
        background: #f8f9fa;
        padding: 20px;
        border-radius: 8px;
        border: 1px solid #e0e0e0;
        margin-bottom: 15px;
      }

      .setting-row {
        margin-bottom: 15px;
      }

      .setting-row label {
        display: flex;
        align-items: center;
        gap: 8px;
        font-weight: 500;
      }

      .setting-row input[type="number"] {
        width: 80px;
        padding: 5px 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
      }

      .setting-info {
        background: #e3f2fd;
        padding: 10px;
        border-radius: 6px;
        margin-bottom: 15px;
      }

      .date-range {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 15px;
        margin-bottom: 20px;
      }

      .date-input input[type="date"] {
        width: 100%;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
      }

      .checkbox-group {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-top: 10px;
      }

      .checkbox-group label {
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
      }

      .cleanup-preview {
        background: #fff3e0;
        padding: 15px;
        border-radius: 6px;
        margin-bottom: 15px;
        border-left: 4px solid #ff9800;
      }

      .preview-content {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .preview-value {
        font-weight: bold;
        color: #f57c00;
      }

      .custom-cleanup-actions {
        display: flex;
        gap: 10px;
      }

      .preview-btn, .execute-btn {
        padding: 10px 20px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 500;
        transition: all 0.3s ease;
      }

      .preview-btn {
        background: #e3f2fd;
        color: #1976d2;
      }

      .execute-btn {
        background: #00796b;
        color: white;
      }

      .execute-btn:disabled {
        background: #ccc;
        cursor: not-allowed;
      }

      .execute-btn:hover:not(:disabled) {
        background: #00695c;
        transform: translateY(-1px);
      }

      .cleanup-results {
        background: #e8f5e8;
        padding: 20px;
        border-radius: 8px;
        border-left: 4px solid #4caf50;
      }

      .results-stats {
        margin-top: 10px;
        font-size: 0.9em;
      }

      @media (max-width: 768px) {
        .quick-cleanup {
          grid-template-columns: 1fr;
        }
        
        .date-range {
          grid-template-columns: 1fr;
        }
        
        .checkbox-group {
          grid-template-columns: 1fr;
        }
      }
    `;
    document.head.appendChild(style);
  }

  // Bind event listeners
  bindEvents() {
    // Quick cleanup option selection
    document.getElementById('smartCleanupBtn').addEventListener('click', () => {
      this.selectCleanupOption('smart');
    });

    document.getElementById('customCleanupBtn').addEventListener('click', () => {
      this.selectCleanupOption('custom');
    });

    // Smart cleanup execution
    document.getElementById('executeSmartCleanup').addEventListener('click', () => {
      this.executeSmartCleanup();
    });

    // Custom cleanup preview and execution
    document.getElementById('previewCustomCleanup').addEventListener('click', () => {
      this.previewCustomCleanup();
    });

    document.getElementById('executeCustomCleanup').addEventListener('click', () => {
      this.executeCustomCleanup();
    });

    // Auto-set date range to last 6 months when custom cleanup is selected
    const endDate = new Date();
    const startDate = new Date();
    startDate.setMonth(startDate.getMonth() - 6);
    
    document.getElementById('cleanupEndDate').value = endDate.toISOString().split('T')[0];
    document.getElementById('cleanupStartDate').value = startDate.toISOString().split('T')[0];
  }

  // Select cleanup option (smart or custom)
  selectCleanupOption(option) {
    // Reset button states
    document.querySelectorAll('.cleanup-btn').forEach(btn => btn.classList.remove('active'));
    
    // Hide all settings
    document.getElementById('smartCleanupSettings').style.display = 'none';
    document.getElementById('customCleanupSettings').style.display = 'none';
    
    if (option === 'smart') {
      document.getElementById('smartCleanupBtn').classList.add('active');
      document.getElementById('smartCleanupSettings').style.display = 'block';
    } else if (option === 'custom') {
      document.getElementById('customCleanupBtn').classList.add('active');
      document.getElementById('customCleanupSettings').style.display = 'block';
    }
  }

  // Load memory usage from service worker
  async loadMemoryUsage() {
    try {
      if (!navigator.serviceWorker || !navigator.serviceWorker.controller) {
        this.showMemoryError('Service worker not available');
        return;
      }

      const channel = new MessageChannel();
      
      channel.port1.onmessage = (event) => {
        if (event.data.type === 'MEMORY_USAGE') {
          this.displayMemoryUsage(event.data.data);
        } else if (event.data.type === 'MEMORY_USAGE_ERROR') {
          this.showMemoryError(event.data.error);
        }
      };

      navigator.serviceWorker.controller.postMessage({
        type: 'GET_MEMORY_USAGE'
      }, [channel.port2]);

    } catch (error) {
      console.error('Failed to load memory usage:', error);
      this.showMemoryError('Failed to calculate memory usage');
    }
  }

  // Display memory usage data
  async displayMemoryUsage(data) {
    this.memoryData = data;

    // Update total memory
    document.getElementById('totalMemoryUsage').textContent = data.totalFormatted;

    // Get and display storage quota
    await this.updateStorageQuota(data.total);

    // Update status
    const status = this.getMemoryStatus(data.total);
    document.getElementById('memoryStatus').textContent = status.message;
    document.getElementById('memoryStatus').style.color = status.color;

    // Show breakdown
    this.displayMemoryBreakdown(data.breakdown);

    // Show recommendations
    this.displayRecommendations(data.recommendations);
  }

  // Update storage quota display and progress bar
  async updateStorageQuota(usedBytes) {
    try {
      if ('storage' in navigator && 'estimate' in navigator.storage) {
        const estimate = await navigator.storage.estimate();
        const quotaGB = (estimate.quota / (1024 * 1024 * 1024)).toFixed(1);
        const usedGB = (usedBytes / (1024 * 1024 * 1024)).toFixed(2);
        
        document.getElementById('storageQuota').textContent = `${quotaGB} GB total`;
        
        // Update progress bar based on actual quota
        const percentage = Math.min((usedBytes / estimate.quota) * 100, 100);
        document.querySelector('.memory-progress-fill').style.width = percentage + '%';
        
        console.log(`üìä Storage: ${usedGB}GB used of ${quotaGB}GB available (${percentage.toFixed(1)}%)`);
      } else {
        document.getElementById('storageQuota').textContent = 'Unknown';
        // Fallback to 1GB scale for progress bar
        const percentage = Math.min((usedBytes / (1024 * 1024 * 1024)) * 100, 100);
        document.querySelector('.memory-progress-fill').style.width = percentage + '%';
      }
    } catch (error) {
      console.warn('Could not get storage quota:', error);
      document.getElementById('storageQuota').textContent = 'Unknown';
      // Fallback to 1GB scale for progress bar
      const percentage = Math.min((usedBytes / (1024 * 1024 * 1024)) * 100, 100);
      document.querySelector('.memory-progress-fill').style.width = percentage + '%';
    }
  }

  // Get memory status message
  getMemoryStatus(totalBytes) {
    const totalMB = totalBytes / (1024 * 1024);
    const totalGB = totalMB / 1024;
    
    if (totalMB < 50) {
      return { message: '‚úÖ Excellent - Memory usage is minimal', color: '#4CAF50' };
    } else if (totalMB < 250) {
      return { message: 'üëç Good - Memory usage is reasonable', color: '#8BC34A' };
    } else if (totalMB < 500) {
      return { message: 'üìä Normal - App is using moderate storage', color: '#2196F3' };
    } else if (totalMB < 1000) {
      return { message: '‚ö†Ô∏è Moderate - Consider cleaning old data if needed', color: '#FF9800' };
    } else if (totalGB < 2) {
      return { message: 'üìà High usage - Still within normal limits', color: '#FF5722' };
    } else {
      return { message: 'üö® Very High - Cleanup recommended for optimal performance', color: '#F44336' };
    }
  }

  // Display memory breakdown
  displayMemoryBreakdown(breakdown) {
    const container = document.querySelector('#memoryBreakdown .breakdown-items');
    container.innerHTML = '';

    Object.entries(breakdown).forEach(([category, data]) => {
      const item = document.createElement('div');
      item.className = 'breakdown-item';
      item.innerHTML = `
        <span>${category} (${data.count} items)</span>
        <span>${this.formatBytes(data.size)}</span>
      `;
      container.appendChild(item);
    });

    document.getElementById('memoryBreakdown').style.display = 'block';
  }

  // Display recommendations
  displayRecommendations(recommendations) {
    const container = document.querySelector('#memoryRecommendations .recommendation-items');
    container.innerHTML = '';

    recommendations.forEach(rec => {
      const item = document.createElement('div');
      item.className = `recommendation-item ${rec.priority}`;
      item.innerHTML = `
        <div>
          <strong>${rec.action}</strong>
          <div style="font-size: 0.85em; color: #666;">${rec.description}</div>
        </div>
        <span style="font-weight: bold;">${rec.estimatedSavings}</span>
      `;
      container.appendChild(item);
    });

    document.getElementById('memoryRecommendations').style.display = 'block';
  }

  // Execute smart cleanup
  async executeSmartCleanup() {
    const keepDays = parseInt(document.getElementById('keepDays').value);
    const maxEntries = parseInt(document.getElementById('maxEntries').value);

    if (!navigator.serviceWorker || !navigator.serviceWorker.controller) {
      alert('Service worker not available');
      return;
    }

    // Show loading state
    document.getElementById('executeSmartCleanup').textContent = 'Cleaning...';
    document.getElementById('executeSmartCleanup').disabled = true;

    try {
      const channel = new MessageChannel();
      
      channel.port1.onmessage = (event) => {
        if (event.data.type === 'SMART_CLEANUP_COMPLETE') {
          this.showCleanupResults(event.data.data, 'Smart Cleanup');
          this.loadMemoryUsage(); // Refresh memory usage
        } else if (event.data.type === 'SMART_CLEANUP_ERROR') {
          alert('Cleanup failed: ' + event.data.error);
        }

        // Reset button
        document.getElementById('executeSmartCleanup').textContent = 'Execute Smart Cleanup';
        document.getElementById('executeSmartCleanup').disabled = false;
      };

      navigator.serviceWorker.controller.postMessage({
        type: 'SMART_CLEANUP_ARCHIVE',
        keepDays,
        maxEntries
      }, [channel.port2]);

    } catch (error) {
      console.error('Smart cleanup failed:', error);
      alert('Smart cleanup failed');
      
      // Reset button
      document.getElementById('executeSmartCleanup').textContent = 'Execute Smart Cleanup';
      document.getElementById('executeSmartCleanup').disabled = false;
    }
  }

  // Preview custom cleanup
  async previewCustomCleanup() {
    const startDate = document.getElementById('cleanupStartDate').value;
    const endDate = document.getElementById('cleanupEndDate').value;
    const dataTypes = Array.from(document.querySelectorAll('.data-type-selection input:checked'))
      .map(cb => cb.value);

    if (!startDate || !endDate || dataTypes.length === 0) {
      alert('Please select date range and at least one data type');
      return;
    }

    if (!navigator.serviceWorker || !navigator.serviceWorker.controller) {
      alert('Service worker not available');
      return;
    }

    // Show loading state
    document.getElementById('previewSize').textContent = 'Calculating...';
    document.getElementById('cleanupPreview').style.display = 'block';

    try {
      const channel = new MessageChannel();
      
      channel.port1.onmessage = (event) => {
        if (event.data.type === 'CLEANUP_ESTIMATE') {
          const data = event.data.data;
          document.getElementById('previewSize').textContent = 
            `${data.totalItems} items (${data.totalSizeFormatted})`;
          
          // Enable execute button
          document.getElementById('executeCustomCleanup').disabled = false;
          
          // Show safety warning for large cleanups
          if (!data.safe) {
            document.getElementById('previewSize').style.color = '#f44336';
            document.getElementById('previewSize').textContent += ' ‚ö†Ô∏è Large cleanup';
          }
        } else if (event.data.type === 'CLEANUP_ESTIMATE_ERROR') {
          document.getElementById('previewSize').textContent = 'Error calculating size';
        }
      };

      navigator.serviceWorker.controller.postMessage({
        type: 'ESTIMATE_CLEANUP_SIZE',
        startDate,
        endDate,
        dataTypes
      }, [channel.port2]);

    } catch (error) {
      console.error('Preview failed:', error);
      document.getElementById('previewSize').textContent = 'Error calculating size';
    }
  }

  // Execute custom cleanup
  async executeCustomCleanup() {
    const startDate = document.getElementById('cleanupStartDate').value;
    const endDate = document.getElementById('cleanupEndDate').value;
    const dataTypes = Array.from(document.querySelectorAll('.data-type-selection input:checked'))
      .map(cb => cb.value);

    if (!confirm('Are you sure you want to delete this data? This action cannot be undone.')) {
      return;
    }

    if (!navigator.serviceWorker || !navigator.serviceWorker.controller) {
      alert('Service worker not available');
      return;
    }

    // Show loading state
    document.getElementById('executeCustomCleanup').textContent = 'Deleting...';
    document.getElementById('executeCustomCleanup').disabled = true;

    try {
      const channel = new MessageChannel();
      
      channel.port1.onmessage = (event) => {
        if (event.data.type === 'DELETE_COMPLETE') {
          this.showCleanupResults(event.data.data, 'Custom Cleanup');
          this.loadMemoryUsage(); // Refresh memory usage
        } else if (event.data.type === 'DELETE_ERROR') {
          alert('Cleanup failed: ' + event.data.error);
        }

        // Reset button
        document.getElementById('executeCustomCleanup').textContent = 'Execute Cleanup';
        document.getElementById('executeCustomCleanup').disabled = true; // Keep disabled until new preview
      };

      navigator.serviceWorker.controller.postMessage({
        type: 'DELETE_DATA_BY_DATE_RANGE',
        startDate,
        endDate,
        dataTypes
      }, [channel.port2]);

    } catch (error) {
      console.error('Custom cleanup failed:', error);
      alert('Custom cleanup failed');
      
      // Reset button
      document.getElementById('executeCustomCleanup').textContent = 'Execute Cleanup';
      document.getElementById('executeCustomCleanup').disabled = true;
    }
  }

  // Show cleanup results
  showCleanupResults(data, cleanupType) {
    const resultsContainer = document.querySelector('#cleanupResults .results-stats');
    resultsContainer.innerHTML = `
      <div><strong>${cleanupType} Results:</strong></div>
      <div>üìÑ Items deleted: ${data.deleted}</div>
      <div>üíæ Space freed: ${data.totalSizeFormatted}</div>
      ${data.keptRecent ? `<div>üïí Recent items kept: ${data.keptRecent}</div>` : ''}
      ${data.keptImportant ? `<div>‚≠ê Important items kept: ${data.keptImportant}</div>` : ''}
    `;

    document.getElementById('cleanupResults').style.display = 'block';

    // Hide after 10 seconds
    setTimeout(() => {
      document.getElementById('cleanupResults').style.display = 'none';
    }, 10000);
  }

  // Show memory error
  showMemoryError(error) {
    document.getElementById('totalMemoryUsage').textContent = 'Error';
    document.getElementById('memoryStatus').textContent = error;
    document.getElementById('memoryStatus').style.color = '#f44336';
  }

  // Format bytes helper
  formatBytes(bytes) {
    if (bytes === 0) return '0 Bytes';
    
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }
}

// Initialize memory manager when DOM is loaded
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    new MemoryManager();
  });
} else {
  new MemoryManager();
}

// Export for manual initialization
window.MemoryManager = MemoryManager;
  </script>
  
  <!-- Leaflet CSS with fallback -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" onerror="console.log('Leaflet CSS failed to load')" />
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(to right, #e0f7fa, #ffffff);
      margin: 0;
      padding: 20px;
      color: #333;
      margin-top: 48px;
    }
    h1 {
      text-align: center;
      color: #00796b;
    }
    .timer-container {
      text-align: center;
      margin-bottom: 30px;
    }
    .timer {
      font-size: 3rem;
      color: #004d40;
      background-color: #ffffff;
      display: inline-block;
      padding: 20px 40px;
      border-radius: 20px;
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
      font-weight: bold;
      user-select: none;
      cursor: pointer;
    }
    .timer-btns {
      margin-top: 20px;
    }
    .timer-btns button {
      background-color: #00796b;
      color: white;
      padding: 10px 16px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 1rem;
      margin: 0 8px;
      transition: background-color 0.3s ease;
    }
    .timer-btns button:hover {
      background-color: #004d40;
    }
    
    /* Ensure buttons remain clickable during automation */
    .timer-btns button,
    button[onclick*="toggleSidebar"],
    .view-back-btn,
    .sidebar-btn {
      pointer-events: auto !important;
      z-index: 10000 !important;
    }
    #form, .entry-section {
      background: #ffffff;
      padding: 15px;
      border-radius: 12px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
      margin-bottom: 20px;
      max-width: 500px;
      margin-left: auto;
      margin-right: auto;
    }
    label, input, select {
      display: block;
      margin-bottom: 10px;
      width: 100%;
      font-size: 1rem;
    }
    input, select {
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 8px;
    }
    #addEntry, .filter-btn, .edit-btn, .delete-btn, .save-btn {
      background-color: #00796b;
      color: white;
      padding: 10px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.9rem;
      margin-top: 10px;
    }
    #addEntry:hover, .filter-btn:hover, .edit-btn:hover, .delete-btn:hover, .save-btn:hover {
      background-color: #004d40;
    }
    #filterBtns {
      text-align: center;
      margin-bottom: 20px;
    }
    #entries {
      max-width: 500px;
      margin-left: auto;
      margin-right: auto;
    }
    .entry {
      background: #ffffff;
      padding: 15px;
      border-left: 6px solid #00796b;
      border-radius: 10px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      margin-bottom: 10px;
    }
    .entry strong {
      font-size: 1.1rem;
      color: #004d40;
    }
    .sidebar-toggle-btn {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 1000;
      background-color: #00796b;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 1.2rem;
    }
    .switch {
      position: relative;
      display: inline-block;
      width: 40px;
      height: 24px;
    }
    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 24px;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    input:checked + .slider {
      background-color: #004d40;
    }
    input:checked + .slider:before {
      transform: translateX(16px);
    }
    .dark-mode {
      background: #121212;
      color: #e0e0e0;
    }
    .dark-mode input,
    .dark-mode select,
    .dark-mode .entry,
    .dark-mode #form {
      background-color: #1e1e1e;
      color: #e0e0e0;
      border-color: #555;
    }
    .dark-mode .timer {
      background-color: #1e1e1e;
      color: #80cbc4;
      user-select: none;
      cursor: pointer;
    }
    .dark-mode .filter-btn,
    .dark-mode .delete-btn,
    .dark-mode .edit-btn,
    .dark-mode .save-btn,
    .dark-mode #addEntry {
      background-color: #004d40;
    }
    .dark-mode .filter-btn:hover,
    .dark-mode .delete-btn:hover,
    .dark-mode .edit-btn:hover,
    .dark-mode .save-btn:hover,
    .dark-mode #addEntry:hover {
      background-color: #00251a;
    }
    .entry-card {
      background-color: #1e1e1e;
      color: #e0e0e0;
      padding: 12px 16px;
      border-radius: 12px;
      margin: 10px 0;
      font-size: 0.95rem;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }
    #categoryBar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 52px;
      background-color: #00695c;
      color: white;
      display: flex;
      justify-content: center;
      gap: 10px;
      align-items: center;
      padding: 0 10px;
      z-index: 1000;
      border-bottom-left-radius: 8px;
      border-bottom-right-radius: 8px;
      width: 100%;
      box-sizing: border-box;
    }
    .cat-btn {
      background-color: transparent;
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.4);
      border-radius: 8px;
      padding: 6px 12px;
      font-size: 0.85rem;
      cursor: pointer;
      transition: background-color 0.2s, box-shadow 0.2s;
      user-select: none;
      -webkit-tap-highlight-color: rgba(255, 255, 255, 0.3);
    }
    .cat-btn:hover,
    .cat-btn:focus,
    .cat-btn:active {
      background-color: rgba(255, 255, 255, 0.2);
      box-shadow: 0 0 6px #ffffffaa inset;
      outline: none;
    }
    .dark-mode .cat-btn {
      border-color: rgba(255, 255, 255, 0.3);
    }
    .timer.glow {
      box-shadow: 0 0 20px 5px #00e5ff, 0 0 30px 10px #00e5ff inset;
      transition: box-shadow 0.3s ease-in-out;
    }
    .archive-entry {
      background-color: #1e1e1e;
      color: #e0e0e0;
      padding: 14px 18px;
      margin: 12px 0;
      border-left: 6px solid #00acc1;
      border-radius: 10px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      font-size: 0.95rem;
      line-height: 1.4;
    }
    #sidebar {
      position: fixed;
      top: 0;
      left: -220px;
      height: 100%;
      width: 220px;
      background: linear-gradient(to bottom, #004d40, #00695c);
      color: white;
      padding: 24px;
      transition: left 0.3s;
      z-index: 10001;
      box-shadow: 2px 0 8px rgba(0,0,0,0.3);
    }
    #overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0,0,0,0.4);
      z-index: 10000;
      display: none;
    }
    #idealForm {
      background: #ffffff;
      padding: 15px;
      border-radius: 12px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
      margin-top: 20px;
    }
    .dark-mode #idealForm {
      background: #1e1e1e;
      color: #e0e0e0;
      border-color: #555;
    }
    /* Dark mode formula cards */
    .dark-mode .formula-card {
      background: #1a1a1a !important;
      color: #ffffff !important;
      border: 1px solid #555 !important;
    }
    /* Dark mode about section styling */
    .dark-mode #aboutContent h3 {
      color: #00e5ff !important;
      border-bottom-color: #00e5ff !important;
    }
    .dark-mode #aboutContent h4 {
      color: #80cbc4 !important;
    }
    .dark-mode #aboutContent p {
      color: #e0e0e0 !important;
    }
    .dark-mode #aboutContent li {
      color: #e0e0e0 !important;
    }
    .dark-mode #aboutContent code {
      background: #1a1a1a !important;
      color: #00e5ff !important;
      padding: 2px 4px !important;
      border-radius: 4px !important;
    }
    .dark-mode #aboutContent div[style*="background: linear-gradient"] {
      background: linear-gradient(135deg, #1a1a1a, #2d2d2d) !important;
      border-left-color: #00e5ff !important;
      color: #e0e0e0 !important;
    }
    .dark-mode #aboutContent div[style*="background: rgba(0, 121, 107, 0.1)"] {
      background: rgba(0, 229, 255, 0.1) !important;
      border-color: rgba(0, 229, 255, 0.3) !important;
    }
    .dark-mode #aboutContent div[style*="background: rgba(0, 121, 107, 0.1)"] p {
      color: #00e5ff !important;
    }
    .cat-btn.clicked {
      background-color: rgba(255, 255, 255, 0.3) !important;
      box-shadow: inset 0 0 12px #ffffff, 0 0 8px #ffffff;
    }
    .view-back-btn {
      position: fixed;
      top: 70px;
      left: 20px;
      z-index: 1003;
      padding: 12px 20px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 500;
      background: linear-gradient(to right, #4CAF50, #2E7D32);
      color: white;
      box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
      border: none;
      outline: none;
      transition: all 0.3s ease;
    }
    .view-back-btn:hover {
      transform: translateY(-2px);
      background: linear-gradient(to right, #2E7D32, #1B5E20);
      box-shadow: 0 6px 16px rgba(76, 175, 80, 0.4);
    }
    .dark-mode .view-back-btn {
      background: linear-gradient(to right, #388E3C, #2E7D32);
      color: white;
      box-shadow: 0 4px 12px rgba(56, 142, 60, 0.3);
    }
    .dark-mode .view-back-btn:hover {
      background: linear-gradient(to right, #2E7D32, #1B5E20);
      box-shadow: 0 6px 16px rgba(56, 142, 60, 0.4);
    }
    .settings-btn {
      background: linear-gradient(to right, #00bfa5, #00796b);
      color: white;
      border: none;
      padding: 12px 16px;
      border-radius: 10px;
      cursor: pointer;
      width: 100%;
      font-size: 1rem;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
      margin-top: 16px;
      text-align: left;
    }
    .settings-btn:hover {
      background: linear-gradient(to right, #00897b, #00695c);
    }
    #settingsPanel {
      display: none;
      margin-top: 20px;
      padding: 15px;
      background: rgba(0,0,0,0.1);
      border-radius: 10px;
    }
    #aboutPanel {
      display: none;
      margin-top: 20px;
      padding: 15px;
      background: rgba(0,0,0,0.1);
      border-radius: 10px;
      max-height: 60vh;
      overflow-y: auto;
    }
    #voiceFeedbackInterval {
      width: 100%;
      padding: 8px;
      border-radius: 8px;
      border: 1px solid #ccc;
      margin-top: 10px;
    }
    /* Jogging Tracker Styles */
    .jog-controls {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }
    .jog-btn {
      background-color: #00796b;
      color: white;
      padding: 10px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.9rem;
      flex: 1;
    }
    .jog-btn:hover {
      background-color: #004d40;
    }
    .jog-stats {
      margin-top: 15px;
      padding: 15px;
      background: rgba(0, 121, 107, 0.1);
      border-radius: 12px;
      border: 2px solid rgba(0, 121, 107, 0.2);
    }

    .jog-stats-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-bottom: 15px;
    }
    .stat-item {
      text-align: center;
      padding: 10px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .stat-label {
      display: block;
      font-size: 0.8rem;
      color: #666;
      margin-bottom: 4px;
      font-weight: 500;
    }

    .stat-value {
      display: block;
      font-size: 1.1rem;
      font-weight: bold;
      color: #00796b;
    }

    .jog-features {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      justify-content: center;
    }

    .feature-tag {
      font-size: 0.75rem;
      padding: 4px 8px;
      background: rgba(0, 121, 107, 0.8);
      color: white;
      border-radius: 12px;
      font-weight: 500;
    }

    .jog-stats p {
      margin: 5px 0;
    }
    .map-container {
      width: 100%;
      height: 200px;
      margin-top: 10px;
      border-radius: 8px;
      overflow: hidden;
      position: relative;
    }
    .map-container img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 8px;
    }
    .map-container .offline-notice {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0,0,0,0.7);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
    }
    /* Settings View */
    #settingsView {
      display: none;
      padding: 20px;
      max-width: 600px;
      margin: 0 auto;
    }
    .settings-section {
      background: #ffffff;
      padding: 15px;
      border-radius: 12px;
      margin-bottom: 20px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }
    .dark-mode .settings-section {
      background: #1e1e1e;
    }
    
    /* Complex Tasks and Automation Styling */
    .complex-task-item {
      margin-bottom: 15px;
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 12px;
      background: #f9f9f9;
      transition: all 0.3s ease;
    }
    
    .complex-task-item:hover {
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      transform: translateY(-2px);
    }
    
    .dark-mode .complex-task-item {
      background: #2d2d2d;
      border-color: #444;
      color: #e0e0e0;
    }
    
    .dark-mode .complex-task-item:hover {
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    
    .complex-task-display {
      background: #f0f8f0;
      padding: 15px;
      margin: 10px 0;
      border-radius: 12px;
      border-left: 4px solid #4CAF50;
      transition: all 0.3s ease;
    }
    
    .complex-task-display:hover {
      background: #e8f5e8;
      box-shadow: 0 2px 8px rgba(76, 175, 80, 0.2);
    }
    
    .automation-task-display {
      background: #f0f0ff;
      padding: 15px;
      margin: 10px 0;
      border-radius: 12px;
      border-left: 4px solid #2196F3;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .automation-task-display:hover {
      background: #e8e8ff;
      box-shadow: 0 2px 8px rgba(33, 150, 243, 0.2);
      transform: translateX(5px);
    }
    
    .dark-mode .complex-task-display {
      background: #2d3d2d;
      color: #e0e0e0;
      border-left-color: #66BB6A;
    }
    
    .dark-mode .complex-task-display:hover {
      background: #354535;
      box-shadow: 0 2px 8px rgba(102, 187, 106, 0.3);
    }
    
    .dark-mode .automation-task-display {
      background: #2d2d3d;
      color: #e0e0e0;
      border-left-color: #42A5F5;
    }
    .dark-mode .automation-task-display:hover {
      background: #353545;
      box-shadow: 0 2px 8px rgba(66, 165, 245, 0.3);
    }
    
    .task-button {
      background: #f44336;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 20px;
      cursor: pointer;
      font-size: 0.85rem;
      transition: all 0.3s ease;
      float: right;
      margin-left: 8px;
    }
    
    .task-button:hover {
      background: #d32f2f;
      transform: scale(1.05);
    }
    
    .task-button.edit {
      background: #FF9800;
    }
    
    .task-button.edit:hover {
      background: #F57C00;
    }
    .settings-title {
      font-size: 1.2rem;
      margin-bottom: 15px;
      color: #00796b;
      border-bottom: 1px solid #00796b;
      padding-bottom: 5px;
    }
    .dark-mode .settings-title {
      color: #00bcd4;
      border-bottom-color: #00bcd4;
    }
    .settings-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 15px;
    }
    .settings-label {
      font-size: 1rem;
      flex: 1;
    }
    /* Sidebar button colors */
    .sidebar-btn-blue {
      background: linear-gradient(to right, #2196F3, #1976D2);
    }
    .sidebar-btn-green {
      background: linear-gradient(to right, #4CAF50, #2E7D32);
    }
    .sidebar-btn-purple {
      background: linear-gradient(to right, #9C27B0, #7B1FA2);
    }
    .sidebar-btn-orange {
      background: linear-gradient(to right, #FF9800, #F57C00);
    }
    .sidebar-btn-teal {
      background: linear-gradient(to right, #4CAF50, #2E7D32);
    }
    .sidebar-btn-blue:hover {
      background: linear-gradient(to right, #1976D2, #0D47A1);
    }
    .sidebar-btn-green:hover {
      background: linear-gradient(to right, #2E7D32, #1B5E20);
    }
    .sidebar-btn-purple:hover {
      background: linear-gradient(to right, #7B1FA2, #4A148C);
    }
    .sidebar-btn-orange:hover {
      background: linear-gradient(to right, #F57C00, #E65100);
    }
    .sidebar-btn-teal:hover {
      background: linear-gradient(to right, #2E7D32, #1B5E20);
    }
    /* Progress chart buttons */
    .chart-type-btn {
      margin: 8px 12px;
      padding: 14px 24px;
      font-size: 1rem;
      border-radius: 12px;
      background: #00796b;
      color: white;
      font-weight: 600;
      border: none;
      cursor: pointer;
    }
    .chart-type-btn:hover {
      background: #004d40;
    }
    /* Leaflet map styles */
    #map {
      width: 100%;
      height: 100%;
      border-radius: 8px;
    }
    .leaflet-container {
      background: #1e1e1e !important;
    }
    .leaflet-control-attribution {
      display: none;
    }
    .route-map-image {
      width: 100%;
      max-width: 500px;
      height: auto;
      border-radius: 8px;
      margin-top: 10px;
      border: 1px solid #ddd;
    }
    .dark-mode .route-map-image {
      border-color: #444;
    }
    /* Route View Modal Styles */
    #routeView {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.9);
      z-index: 99999;
      overflow-y: auto;
      touch-action: none;
    }
    #routeView .route-container {
      max-width: 800px;
      margin: 60px auto 20px;
      background: white;
      padding: 20px;
      border-radius: 10px;
    }
    .dark-mode #routeView .route-container {
      background: #1e1e1e;
      color: #e0e0e0;
    }
    #routeView h2 {
      text-align: center;
      color: #00796b;
    }
    .dark-mode #routeView h2 {
      color: #00bcd4;
    }
    #routeView .route-stats {
      margin-top: 20px;
    }
    #routeView .route-stats h3 {
      color: #00796b;
      margin-bottom: 10px;
    }
    .dark-mode #routeView .route-stats h3 {
      color: #00bcd4;
    }
    #routeView .route-stats p {
      margin: 8px 0;
      color: #333;
    }
    .dark-mode #routeView .route-stats p {
      color: #e0e0e0;
    }
    #routeView .close-btn {
      position: fixed;
      top: 70px;
      right: 20px;
      background: #f44336;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 1.2rem;
      z-index: 100000;
    }
    #routeView .close-btn:hover {
      background: #d32f2f;
    }
    /* Confirmation dialog styles */
    .confirmation-dialog {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0,0,0,0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10004;
    }
    .confirmation-content {
      background: white;
      padding: 20px;
      border-radius: 10px;
      max-width: 500px;
      width: 90%;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    .dark-mode .confirmation-content {
      background: #1e1e1e;
      color: #e0e0e0;
    }
    .confirmation-content h3 {
      margin-top: 0;
      color: #00796b;
    }
    .dark-mode .confirmation-content h3 {
      color: #00bcd4;
    }
    .confirmation-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 20px;
    }
    .confirmation-buttons button {
      padding: 8px 16px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 0.9rem;
    }
    .confirm-btn {
      background-color: #4CAF50;
      color: white;
      border: none;
    }
    .confirm-btn:hover {
      background-color: #388E3C;
    }
    .cancel-btn {
      background-color: #f44336;
      color: white;
      border: none;
    }
    .cancel-btn:hover {
      background-color: #d32f2f;
    }
    /* Error message styles */
    .error-message {
      color: #f44336;
      background-color: #ffebee;
      padding: 10px;
      border-radius: 5px;
      margin: 10px 0;
      display: none;
    }
    .dark-mode .error-message {
      background-color: #3a1c1c;
    }
    @media (max-width: 600px) {
      .timer { font-size: 2rem; padding: 10px; }
      #form, #entries { width: 100%; padding: 10px; }
      .chart-type-btn {
        padding: 10px 16px;
        margin: 5px 8px;
      }
      .jog-controls {
        flex-direction: column;
      }
    }
    /* Voice Interaction Styles */
    .voice-status {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 10px 15px;
      border-radius: 25px;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      backdrop-filter: blur(5px);
      z-index: 1000;
      max-width: 80%;
    }
    
    .voice-status .indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 10px;
      transition: all 0.3s ease;
    }
    
    .voice-status .indicator.ready {
      background: #00e5ff;
      box-shadow: 0 0 5px #00e5ff;
    }
    
    .voice-status .indicator.listening {
      background: #4caf50;
      box-shadow: 0 0 10px #4caf50;
      animation: pulse 1.5s infinite;
    }
    
    .voice-status .indicator.feedback {
      background: #2196f3;
      box-shadow: 0 0 10px #2196f3;
      animation: pulse 1s infinite;
    }
    
    .voice-status .indicator.error {
      background: #f44336;
      box-shadow: 0 0 10px #f44336;
    }
    
    #voiceFeedbackContainer {
      position: fixed;
      bottom: 60px;
      left: 20px;
      max-width: 80%;
      z-index: 1000;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 10px 15px;
      border-radius: 12px;
      backdrop-filter: blur(5px);
      max-height: 150px;
      overflow-y: auto;
      display: none;
    }
    
    .voice-message {
      margin-bottom: 8px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(255,255,255,0.2);
      animation: fadeIn 0.3s ease-out;
    }
    
    .voice-message:last-child {
      margin-bottom: 0;
      padding-bottom: 0;
      border-bottom: none;
    }
    
    .voice-message.user {
      color: #80cbc4;
    }
    
    .voice-message.feedback {
      color: #81c784;
    }
    
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    /* Offline notification */
    .offline-notification {
      position: fixed;
      top: 60px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #d32f2f, #f44336);
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      z-index: 1000;
      display: none;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      align-items: center;
      font-weight: 500;
      max-width: 90%;
      text-align: center;
      transition: all 0.3s ease;
    }
    
    /* Streak view light mode styling */
    body:not(.dark-mode) #streakView {
      background: linear-gradient(to right, #e0f7fa, #ffffff);
    }
    
    body:not(.dark-mode) #streakView h2 {
      color: #00796b !important;
    }
    
    /* Light mode streak cards */
    body:not(.dark-mode) .streak-card {
      background: linear-gradient(135deg, #ffffff, #f5f5f5) !important;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1) !important;
      border: 1px solid #e0e0e0;
    }
    
    body:not(.dark-mode) .streak-card div:first-child {
      color: #00796b !important;
    }
    
    body:not(.dark-mode) #currentStreak {
      color: #00796b !important;
      text-shadow: none !important;
    }
    
    body:not(.dark-mode) #bestStreak {
      color: #f57c00 !important;
      text-shadow: none !important;
    }
    
    /* Light mode info boxes */
    body:not(.dark-mode) .streak-container div[style*="background: rgba(0,0,0,0.2)"] {
      background: rgba(255,255,255,0.9) !important;
      border: 1px solid #e0e0e0 !important;
    }
    
    body:not(.dark-mode) #lastLogDate {
      color: #2d3748 !important;
    }
    
    body:not(.dark-mode) #streakSummary {
      color: #2d3748 !important;
    }
    
    body:not(.dark-mode) .streak-container div[style*="color: #80cbc4"] {
      color: #00796b !important;
    }
    
    /* Light mode calendar */
    body:not(.dark-mode) #streakCalendar .calendar-day {
      background: #f5f5f5;
      border: 1px solid #e0e0e0;
      color: #333;
    }
    
    body:not(.dark-mode) #streakCalendar .calendar-day.active {
      background: #00796b;
      color: white;
    }
    
    body:not(.dark-mode) #streakCalendar .calendar-day.today {
      border-color: #00796b;
      font-weight: bold;
    }

    /* Dark mode styles for Memory Manager */
    .dark-mode .memory-management-section { background: #23232b; border-color: #333; }
    .dark-mode .memory-overview,
    .dark-mode .memory-breakdown,
    .dark-mode .memory-recommendations,
    .dark-mode .archive-cleanup-section { background: #181820; color: #e0e0e0; }
    .dark-mode .memory-label,
    .dark-mode .memory-value { color: #00bcd4; }
    .dark-mode .memory-progress-bar { background: #333; }
    .dark-mode .memory-progress-fill { background: linear-gradient(90deg, #26a69a, #ffb300, #e57373); }
    .dark-mode .memory-status { color: #b0bec5; }
    .dark-mode .breakdown-item,
    .dark-mode .recommendation-item { background: #23232b; border-left-color: #00bcd4; color: #e0e0e0; }
    .dark-mode .recommendation-item.high { border-left-color: #e57373; background: #2d2323; }
    .dark-mode .cleanup-btn { background: #23232b; border-color: #333; color: #e0e0e0; }
    .dark-mode .cleanup-btn.active { background: #263238; }
    .dark-mode .cleanup-settings { background: #23232b; border-color: #333; }
    .dark-mode .preview-btn { background: #263238; color: #00bcd4; }
    .dark-mode .execute-btn { background: #00bcd4; color: #181820; }
    .dark-mode .execute-btn:disabled { background: #555; color: #888; }
    .dark-mode .cleanup-preview { background: #2d2323; border-left-color: #ffb300; color: #e0e0e0; }
    .dark-mode .cleanup-results { background: #1b2e1b; border-left-color: #26a69a; color: #e0e0e0; }
  </style>
</head>
<body>
  <!-- Custom Splash Screen -->
  <div id="splashScreen" style="
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, #e0f7fa 0%, #b2dfdb 50%, #80cbc4 100%);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 10000;
    transition: opacity 0.5s ease-out;
  ">
    <div style="text-align: center; animation: fadeInUp 1s ease-out;">
             <!-- App Icon -->
       <div style="
         width: 120px;
         height: 120px;
         background: white;
         border-radius: 24px;
         margin: 0 auto 30px;
         display: flex;
         align-items: center;
         justify-content: center;
         box-shadow: 0 8px 32px rgba(0, 121, 107, 0.3);
         animation: bounceIn 1.2s ease-out;
         padding: 10px;
       ">
         <img src="icons/icon-192.png" alt="Performa" style="
           width: 100%;
           height: 100%;
           object-fit: contain;
           border-radius: 16px;
         ">
       </div>
      
      <!-- App Name -->
      <h1 style="
        font-size: 2.5rem;
        font-weight: 700;
        color: #004d40;
        margin: 0 0 10px 0;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        animation: slideInFromLeft 1s ease-out 0.3s both;
      ">
        Performa
      </h1>
      
      <!-- Tagline -->
      <p style="
        font-size: 1.1rem;
        color: #00796b;
        margin: 0 0 40px 0;
        font-weight: 500;
        animation: slideInFromRight 1s ease-out 0.5s both;
      ">
        Voice-Enabled Fitness Tracker
      </p>
      
      <!-- Loading Animation -->
      <div style="
        width: 50px;
        height: 50px;
        margin: 0 auto;
        animation: spin 2s linear infinite;
      ">
        <div style="
          width: 100%;
          height: 100%;
          border: 4px solid rgba(0, 121, 107, 0.2);
          border-top: 4px solid #00796b;
          border-radius: 50%;
        "></div>
      </div>
      
      <!-- Loading Text -->
      <p style="
        font-size: 0.9rem;
        color: #00796b;
        margin: 20px 0 0 0;
        animation: pulse 2s ease-in-out infinite;
      ">
        Loading your fitness data...
      </p>
    </div>
  </div>

  <style>
    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    @keyframes bounceIn {
      0% {
        opacity: 0;
        transform: scale(0.3);
      }
      50% {
        opacity: 1;
        transform: scale(1.05);
      }
      70% {
        transform: scale(0.9);
      }
      100% {
        opacity: 1;
        transform: scale(1);
      }
    }
    
    @keyframes slideInFromLeft {
      from {
        opacity: 0;
        transform: translateX(-50px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }
    
    @keyframes slideInFromRight {
      from {
        opacity: 0;
        transform: translateX(50px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    /* Dark mode splash screen */
    .dark-mode #splashScreen {
      background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 50%, #3a3a3a 100%) !important;
    }
    
    .dark-mode #splashScreen h1 {
      color: #00e5ff !important;
    }
    
    .dark-mode #splashScreen p {
      color: #80cbc4 !important;
    }
    
    .dark-mode #splashScreen div[style*="border-top: 4px solid #00796b"] {
      border-top-color: #00e5ff !important;
    }
  </style>
     <!-- Offline Notification -->
   <div class="offline-notification" id="offlineNotification">
     <span>You are currently offline. Some features may be limited.</span>
     <button onclick="hideOfflineNotification()" style="
       background: none;
       border: none;
       color: white;
       font-size: 18px;
       cursor: pointer;
       padding: 5px;
       margin-left: 10px;
       border-radius: 4px;
       transition: background 0.2s;
     " onmouseover="this.style.background='rgba(255,255,255,0.2)'" onmouseout="this.style.background='none'">
       ‚úï
     </button>
   </div>

  <!-- Voice Status Indicator -->
  <div class="voice-status" id="voiceStatus">
    <div class="indicator ready" id="voiceIndicator"></div>
    <span id="voiceStatusText">Voice: Ready</span>
  </div>

  <!-- Voice Feedback Container -->
  <div id="voiceFeedbackContainer"></div>

  <!-- Category Bar -->
  <div id="categoryBar">
    <button class="cat-btn" onclick="setCategory('C.S.A')" title="Chest, Shoulder &amp; Abs">C.S.A</button>
    <button class="cat-btn" onclick="setCategory('C.P.E')" title="Core, Power &amp; Endurance">C.P.E</button>
    <button class="cat-btn" onclick="setCategory('CA.P')" title="Cardio &amp; Power">CA.P</button>
    <button class="cat-btn" onclick="setCategory('L.B.S')" title="Lower Body Strength">L.B.S</button>
    <div id="scorePanel" onclick="showStreakTracker()" style="margin-left: auto; display: flex; align-items: center; gap: 10px; padding: 6px 12px; height: 40px; background-color: #004d40; border-radius: 8px; color: white; font-size: 0.75rem; box-shadow: 0 1px 3px rgba(0,0,0,0.2); cursor: pointer;">
      <div><strong>EQ:</strong> <span id="todayAvg">0</span></div>
      <div><strong>Total:</strong> <span id="totalScore">0.00</span></div>
    </div>
  </div>

  <!-- Main Content -->
  <div id="mainContent">
    <!-- Sidebar -->
    <div id="sidebar">
          <button onclick="toggleSidebar(); showSettingsView()" class="settings-btn sidebar-btn-blue">‚öôÔ∏è Settings</button>
    <button onclick="toggleSidebar(); showProgressView()" class="settings-btn sidebar-btn-green">üìà Progress</button>
    <button onclick="toggleSidebar(); showArchiveView()" class="settings-btn sidebar-btn-purple">üìÇ View Archive</button>
    <button onclick="toggleSidebar(); showMasteredView()" class="settings-btn sidebar-btn-orange">üìò Mastered Performa</button>
    <button onclick="toggleSidebar(); showIdealsPage()" class="settings-btn sidebar-btn-teal">üõ†Ô∏è Ideals</button>

    </div>
    
    <div id="overlay" onclick="toggleSidebar()"></div>
    
    <div style="text-align: left; margin-bottom: 10px;">
      <button onclick="toggleSidebar()" style="background-color: #00796b; color: white; padding: 10px 20px; border: none; border-radius: 8px; font-size: 1rem; cursor: pointer;">‚ò∞</button>
    </div>
    
    <h1>Performa Tracker</h1>
    


    
    <div class="timer-container">
      <div class="timer" id="timer" onclick="startVoiceRecognition()">
        00:00:00
      </div>
      <div class="timer-btns">
        <button onclick="startTimer()">Start</button>
        <button onclick="stopTimer()">Stop</button>
        <button onclick="resetTimer()">Reset</button>
      </div>
      

    </div>
    
    <div id="form">
      <label for="type">Activity type:</label>
      <select id="type" onchange="renderFields()">
  <option value="" selected disabled hidden>Select activity type</option>
  <option value="reps">Reps-Based</option>
  <option value="iso">Isometric</option>
  <option value="semi">Semi-Isometric</option>
  <option value="jog">Jogging</option>
      </select>
      <div id="fields"></div>
      <label for="category">Category:</label>
      <select id="category">
        <option value="Select category">Select category</option>
        <option value="C.S.A">C.S.A</option>
        <option value="C.P.E">C.P.E</option>
        <option value="CA.P">CA.P</option>
        <option value="L.B.S">L.B.S</option>
      </select>
      <div id="jogControls" style="display: none;">
        <div class="jog-controls">
          <button id="startJogBtn" class="jog-btn" onclick="startJogging()">Start Jog</button>
          <button id="viewRouteBtn" class="jog-btn" onclick="viewRoute()">View Route</button>
        </div>
        <div id="jogStats" class="jog-stats" style="display: none;">
          <div class="jog-stats-grid">
            <div class="stat-item">
              <span class="stat-label">Distance</span>
              <span class="stat-value"><span id="jogDistance">0</span> km</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Duration</span>
              <span class="stat-value"><span id="jogDuration">0</span> sec</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Avg Speed</span>
              <span class="stat-value"><span id="jogAvgSpeed">0</span> km/h</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Current Speed</span>
              <span class="stat-value"><span id="jogCurrentSpeed">0</span> km/h</span>
            </div>
          </div>
          <div id="jogFeatures" class="jog-features">
            <div class="feature-tag">üìç High-Accuracy GPS</div>
            <div class="feature-tag">‚è∏Ô∏è Auto Pause/Resume</div>
            <div class="feature-tag">üìä Route Smoothing</div>
            <div class="feature-tag">üíæ Session Recovery</div>
          </div>
        </div>
      </div>
      <div id="gpsError" class="error-message" style="display: none;"></div>
      <button id="addEntry">Add Entry</button>
      <button id="cancelEdit" onclick="cancelEdit()" style="background-color: #d32f2f; color: white; margin-left: 10px; padding: 10px; border: none; border-radius: 8px; cursor: pointer; font-size: 0.9rem; display: none;">‚úñ Cancel</button>
    </div>
    
    <div id="filterBtns">
      <button class="filter-btn" onclick='filterEntries("all")'>All</button>
      <button class="filter-btn" onclick='filterEntries("reps")'>Reps-Based</button>
      <button class="filter-btn" onclick='filterEntries("iso")'>Isometric</button>
      <button class="filter-btn" onclick='filterEntries("semi")'>Semi-Isometric</button>
      <button class="filter-btn" onclick='filterEntries("jog")'>Jogging</button>
    </div>
    
      <div id="entries"></div>
  
  <!-- Debug info for mobile -->
        <!-- Debug box hidden - app is working -->
      <div id="debugInfo" style="display: none;"></div>
</div>



  <!-- Progress View -->
  <div id="progressView" style="display: none; padding: 20px; max-width: 800px; margin: 0 auto;">
    <button onclick="hideProgressView()" class="view-back-btn">‚Üê Back</button>
    <h2 style="text-align: center; margin-top: 60px;">üìà Progress</h2>
    <div style="text-align: center; margin: 20px 0;">
      <button onclick="switchChartType('total')" class="chart-type-btn">Total Score</button>
      <button onclick="switchChartType('exercise')" class="chart-type-btn">Per Exercise</button>
    </div>
    <div style="text-align: center; margin-bottom: 20px;">
      <label for="fromDate">From:</label>
      <input id="fromDate" type="date"/>
      <label for="toDate">To:</label>
      <input id="toDate" type="date"/>
      <select id="exerciseDropdown" style="padding: 10px;border-radius: 10px;font-size: 1rem;min-width: 160px; margin: 10px auto; display: none;"></select>
    </div>
    <canvas height="300" id="progressChart" style="background:#1e1e1e;border-radius:8px;"></canvas>
  </div>

  <!-- Mastered View -->
  <div id="masteredView" style="display: none; padding: 20px; max-width: 600px; margin: 0 auto;">
    <button onclick="hideMasteredView()" class="view-back-btn">‚Üê Back</button>
    <h2 style="text-align: center; margin-top: 60px;">üìò Mastered Performa</h2>
    <div id="masteredContainer"></div>
  </div>

  <!-- Ideal Score View -->
  <div id="idealScoreView" style="display: none; padding: 20px; max-width: 600px; margin: 0 auto;">
    <button onclick="hideIdealScoreView()" class="view-back-btn">‚Üê Back</button>
    <h2 style="text-align: center; margin-top: 60px;">üõ†Ô∏è Ideal Score</h2>
    <form id="idealForm">
      <label for="idealType">Activity Type:</label>
      <select id="idealType" onchange="renderIdealInputs()">
        <option value="">Select an activity type</option>
        <option value="reps">Reps-Based</option>
        <option value="iso">Isometric</option>
        <option value="semi">Semi-Isometric</option>
        <option value="jog">Jogging</option>
      </select>
      <label for="idealCategory">Category:</label>
      <select id="idealCategory">
        <option value="">Select a category</option>
        <option value="C.S.A">C.S.A</option>
        <option value="C.P.E">C.P.E</option>
        <option value="CA.P">CA.P</option>
        <option value="L.B.S">L.B.S</option>
      </select>
      <label for="idealName">Exercise Name:</label>
      <input type="text" id="idealName" placeholder="Enter exercise name">
      <div id="idealFields"></div>
      <button type="submit" class="save-btn" style="background: linear-gradient(to right, #4CAF50, #2E7D32); width: 100%; padding: 12px; font-size: 1rem; margin-top: 15px;">Save Ideal</button>
    </form>
    <div id="idealLogs" style="margin-top:20px;"></div>
  </div>

  <!-- Archive View -->
  <div id="archiveView" style="display: none; padding: 20px; max-width: 600px; margin: 0 auto;">
    <button onclick="hideArchiveView()" class="view-back-btn">‚Üê Back</button>
    <div id="archiveContainer"></div>
  </div>

  <!-- Settings View -->
  <div id="settingsView" style="display: none; padding: 20px; max-width: 600px; margin: 0 auto;">
    <button onclick="hideSettingsView()" class="view-back-btn">‚Üê Back</button>
    <h2 style="text-align: center; margin-top: 60px;">‚öôÔ∏è Settings</h2>
    
    <div class="settings-section">
      <div class="settings-title">Appearance</div>
      <div class="settings-row">
        <label for="darkModeToggle" class="settings-label">Dark Mode</label>
        <label class="switch">
          <input id="darkModeToggle" onchange="toggleDarkMode()" type="checkbox"/>
          <span class="slider round"></span>
        </label>
      </div>
    </div>
    
    <div class="settings-section">
      <div class="settings-title">Voice Commands & Feedback</div>
      <div class="settings-row">
        <span class="settings-label">Enable Voice Commands</span>
        <label class="switch">
          <input id="voiceCommandsToggle" type="checkbox" checked onchange="toggleVoiceCommands()"/>
          <span class="slider round"></span>
        </label>
      </div>
      <div class="settings-row">
        <span class="settings-label">Enable Voice Feedback</span>
        <label class="switch">
          <input id="voiceFeedbackToggle" type="checkbox" checked onchange="toggleVoiceFeedback()"/>
          <span class="slider round"></span>
        </label>
      </div>
      <div class="settings-row">
        <span class="settings-label">Speak summary after entry</span>
        <label class="switch">
          <input id="entrySummaryToggle" type="checkbox" checked onchange="toggleEntrySummary()"/>
          <span class="slider round"></span>
        </label>
      </div>
      <div>
        <label for="voiceFeedbackInterval">Voice Feedback Interval (seconds):</label>
        <input type="number" id="voiceFeedbackInterval" min="5" max="300" value="30">
      </div>
      

      
      <div id="voiceCommandSettings" style="margin-top: 15px;">
        <h4 style="margin-bottom: 10px;">Custom Voice Commands</h4>
        <div class="settings-row">
          <label class="settings-label">Start Timer Command:</label>
          <input type="text" id="startTimerCommand" value="start timer" style="width: 120px;">
        </div>
        <div class="settings-row">
          <label class="settings-label">Stop Timer Command:</label>
          <input type="text" id="stopTimerCommand" value="stop timer" style="width: 120px;">
        </div>
        <div class="settings-row">
          <label class="settings-label">Reset Timer Command:</label>
          <input type="text" id="resetTimerCommand" value="reset timer" style="width: 120px;">
        </div>
        <div class="settings-row">
          <label class="settings-label">Start Jog Command:</label>
          <input type="text" id="startJogCommand" value="start jog" style="width: 120px;">
        </div>
        <div class="settings-row">
          <label class="settings-label">Stop Jog Command:</label>
          <input type="text" id="stopJogCommand" value="stop jog" style="width: 120px;">
        </div>

        <h4 style="margin-bottom: 10px; margin-top: 15px;">Navigation Commands</h4>
        <div class="settings-row">
          <label class="settings-label">Show Progress Command:</label>
          <input type="text" id="showProgressCommand" value="show progress" style="width: 120px;">
        </div>
        <div class="settings-row">
          <label class="settings-label">Show Archive Command:</label>
          <input type="text" id="showArchiveCommand" value="show archive" style="width: 120px;">
        </div>
        <div class="settings-row">
          <label class="settings-label">Open Settings Command:</label>
          <input type="text" id="openSettingsCommand" value="open settings" style="width: 120px;">
        </div>
        <div class="settings-row">
          <label class="settings-label">Go Home Command:</label>
          <input type="text" id="goHomeCommand" value="go home" style="width: 120px;">
        </div>

        <h4 style="margin-bottom: 10px; margin-top: 15px;">Entry Commands</h4>
        <div class="settings-row">
          <label class="settings-label">Add Entry Command:</label>
          <input type="text" id="addEntryCommand" value="add entry" style="width: 120px;">
        </div>
        <div class="settings-row">
          <label class="settings-label">Log Exercise Command:</label>
          <input type="text" id="logExerciseCommand" value="log for" style="width: 120px;">
        </div>
        <div class="settings-row">
          <label class="settings-label">Set Actual Reps Command:</label>
          <input type="text" id="setActualRepsCommand" value="actual reps are" style="width: 120px;">
        </div>

        <h4 style="margin-bottom: 10px; margin-top: 15px;">Timer Commands</h4>
        <div class="settings-row">
          <label class="settings-label">Start Timer For Command:</label>
          <input type="text" id="startTimerForCommand" value="start timer for" style="width: 120px;">
        </div>


        <h4 style="margin-bottom: 10px; margin-top: 15px;">Complex Task Commands</h4>
        <div id="complexTasksContainer"></div>
        <div style="text-align: center; margin: 20px 0;">
          <button onclick="addComplexTaskCommand()" style="background: linear-gradient(135deg, #4CAF50, #45a049); color: white; padding: 12px 24px; border: none; border-radius: 25px; cursor: pointer; margin: 5px 10px; font-weight: 600; box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3); transition: all 0.3s ease;">+ Add Complex Task</button>
          <button onclick="showAutomationRecorder()" style="background: linear-gradient(135deg, #2196F3, #1976D2); color: white; padding: 12px 24px; border: none; border-radius: 25px; cursor: pointer; margin: 5px 10px; font-weight: 600; box-shadow: 0 4px 15px rgba(33, 150, 243, 0.3); transition: all 0.3s ease;">üéØ Record Automation</button>
        </div>

        <h4 class="feedback-main-title">üîä Voice Feedback Settings</h4>
        
        <!-- All Feedback Types in One Section -->
        <div class="feedback-section">
          
          <!-- Start Timer Feedback -->
          <div class="feedback-item">
            <div class="feedback-name">Start Timer</div>
            <div class="toggle-switch">
              <button onclick="setFeedbackMode('startTimer', 'tts')" id="startTimer_tts_btn" class="toggle-btn active">ü§ñ TTS</button>
              <button onclick="setFeedbackMode('startTimer', 'custom')" id="startTimer_custom_btn" class="toggle-btn">üéôÔ∏è Custom</button>
            </div>
            <div id="startTimer_content">
              <div class="feedback-message">Timer started</div>
            </div>
            <button onclick="openFeedbackModal('startTimer')" class="edit-btn">‚úèÔ∏è Edit</button>
            <button onclick="resetFeedback('startTimer')" class="reset-btn">üîÑ Reset</button>
          </div>

          <!-- Stop Timer Feedback -->
          <div class="feedback-item">
            <div class="feedback-name">Stop Timer</div>
            <div class="toggle-switch">
              <button onclick="setFeedbackMode('stopTimer', 'tts')" id="stopTimer_tts_btn" class="toggle-btn active">ü§ñ TTS</button>
              <button onclick="setFeedbackMode('stopTimer', 'custom')" id="stopTimer_custom_btn" class="toggle-btn">üéôÔ∏è Custom</button>
            </div>
            <div id="stopTimer_content">
              <div class="feedback-message">Timer stopped</div>
            </div>
            <button onclick="openFeedbackModal('stopTimer')" class="edit-btn">‚úèÔ∏è Edit</button>
            <button onclick="resetFeedback('stopTimer')" class="reset-btn">üîÑ Reset</button>
          </div>

          <!-- Reset Timer Feedback -->
          <div class="feedback-item">
            <div class="feedback-name">Reset Timer</div>
            <div class="toggle-switch">
              <button onclick="setFeedbackMode('resetTimer', 'tts')" id="resetTimer_tts_btn" class="toggle-btn active">ü§ñ TTS</button>
              <button onclick="setFeedbackMode('resetTimer', 'custom')" id="resetTimer_custom_btn" class="toggle-btn">üéôÔ∏è Custom</button>
            </div>
            <div id="resetTimer_content">
              <div class="feedback-message">Timer reset</div>
            </div>
            <button onclick="openFeedbackModal('resetTimer')" class="edit-btn">‚úèÔ∏è Edit</button>
            <button onclick="resetFeedback('resetTimer')" class="reset-btn">üîÑ Reset</button>
          </div>

          <!-- Timer Set For Feedback -->
          <div class="feedback-item">
            <div class="feedback-name">Timer Set For Duration</div>
            <div class="toggle-switch">
              <button onclick="setFeedbackMode('timerSetFor', 'tts')" id="timerSetFor_tts_btn" class="toggle-btn active">ü§ñ TTS</button>
              <button onclick="setFeedbackMode('timerSetFor', 'custom')" id="timerSetFor_custom_btn" class="toggle-btn">üéôÔ∏è Custom</button>
            </div>
            <div id="timerSetFor_content">
              <div class="feedback-message">Timer set for</div>
            </div>
            <button onclick="openFeedbackModal('timerSetFor')" class="edit-btn">‚úèÔ∏è Edit</button>
            <button onclick="resetFeedback('timerSetFor')" class="reset-btn">üîÑ Reset</button>
          </div>

          <!-- Timer Interval Feedback -->
          <div class="feedback-item">
            <div class="feedback-name">Timer Interval</div>
            <div class="toggle-switch">
              <button onclick="setFeedbackMode('timerInterval', 'tts')" id="timerInterval_tts_btn" class="toggle-btn active">ü§ñ TTS</button>
              <button onclick="setFeedbackMode('timerInterval', 'custom')" id="timerInterval_custom_btn" class="toggle-btn">üéôÔ∏è Custom</button>
            </div>
            <div id="timerInterval_content">
              <div class="feedback-message">passed</div>
            </div>
            <button onclick="openFeedbackModal('timerInterval')" class="edit-btn">‚úèÔ∏è Edit</button>
            <button onclick="resetFeedback('timerInterval')" class="reset-btn">üîÑ Reset</button>
          </div>

          <!-- Start Jog Feedback -->
          <div class="feedback-item">
            <div class="feedback-name">Start Jogging</div>
            <div class="toggle-switch">
              <button onclick="setFeedbackMode('startJog', 'tts')" id="startJog_tts_btn" class="toggle-btn active">ü§ñ TTS</button>
              <button onclick="setFeedbackMode('startJog', 'custom')" id="startJog_custom_btn" class="toggle-btn">üéôÔ∏è Custom</button>
            </div>
            <div id="startJog_content">
              <div class="feedback-message">Jogging started</div>
            </div>
            <button onclick="openFeedbackModal('startJog')" class="edit-btn">‚úèÔ∏è Edit</button>
            <button onclick="resetFeedback('startJog')" class="reset-btn">üîÑ Reset</button>
          </div>

          <!-- Stop Jog Feedback -->
          <div class="feedback-item">
            <div class="feedback-name">Stop Jogging</div>
            <div class="toggle-switch">
              <button onclick="setFeedbackMode('stopJog', 'tts')" id="stopJog_tts_btn" class="toggle-btn active">ü§ñ TTS</button>
              <button onclick="setFeedbackMode('stopJog', 'custom')" id="stopJog_custom_btn" class="toggle-btn">üéôÔ∏è Custom</button>
            </div>
            <div id="stopJog_content">
              <div class="feedback-message">Jogging stopped</div>
            </div>
            <button onclick="openFeedbackModal('stopJog')" class="edit-btn">‚úèÔ∏è Edit</button>
            <button onclick="resetFeedback('stopJog')" class="reset-btn">üîÑ Reset</button>
          </div>

          <!-- Add Entry Feedback -->
          <div class="feedback-item">
            <div class="feedback-name">Add Entry</div>
            <div class="toggle-switch">
              <button onclick="setFeedbackMode('addEntry', 'tts')" id="addEntry_tts_btn" class="toggle-btn active">ü§ñ TTS</button>
              <button onclick="setFeedbackMode('addEntry', 'custom')" id="addEntry_custom_btn" class="toggle-btn">üéôÔ∏è Custom</button>
            </div>
            <div id="addEntry_content">
              <div class="feedback-message">Entry added</div>
            </div>
            <button onclick="openFeedbackModal('addEntry')" class="edit-btn">‚úèÔ∏è Edit</button>
            <button onclick="resetFeedback('addEntry')" class="reset-btn">üîÑ Reset</button>
          </div>

          <!-- Log Exercise Feedback -->
          <div class="feedback-item">
            <div class="feedback-name">Log Exercise</div>
            <div class="toggle-switch">
              <button onclick="setFeedbackMode('logExercise', 'tts')" id="logExercise_tts_btn" class="toggle-btn active">ü§ñ TTS</button>
              <button onclick="setFeedbackMode('logExercise', 'custom')" id="logExercise_custom_btn" class="toggle-btn">üéôÔ∏è Custom</button>
            </div>
            <div id="logExercise_content">
              <div class="feedback-message">Exercise logged</div>
            </div>
            <button onclick="openFeedbackModal('logExercise')" class="edit-btn">‚úèÔ∏è Edit</button>
            <button onclick="resetFeedback('logExercise')" class="reset-btn">üîÑ Reset</button>
          </div>

          <!-- Set Actual Reps Feedback -->
          <div class="feedback-item">
            <div class="feedback-name">Set Actual Reps</div>
            <div class="toggle-switch">
              <button onclick="setFeedbackMode('setActualReps', 'tts')" id="setActualReps_tts_btn" class="toggle-btn active">ü§ñ TTS</button>
              <button onclick="setFeedbackMode('setActualReps', 'custom')" id="setActualReps_custom_btn" class="toggle-btn">üéôÔ∏è Custom</button>
            </div>
            <div id="setActualReps_content">
              <div class="feedback-message">Actual reps set to</div>
            </div>
            <button onclick="openFeedbackModal('setActualReps')" class="edit-btn">‚úèÔ∏è Edit</button>
            <button onclick="resetFeedback('setActualReps')" class="reset-btn">üîÑ Reset</button>
          </div>

          <!-- Navigation Feedback -->
          <div class="feedback-item">
            <div class="feedback-name">Navigation Actions</div>
            <div class="toggle-switch">
              <button onclick="setFeedbackMode('navigation', 'tts')" id="navigation_tts_btn" class="toggle-btn active">ü§ñ TTS</button>
              <button onclick="setFeedbackMode('navigation', 'custom')" id="navigation_custom_btn" class="toggle-btn">üéôÔ∏è Custom</button>
            </div>
            <div id="navigation_content">
              <div class="feedback-message">Navigated to</div>
            </div>
            <button onclick="openFeedbackModal('navigation')" class="edit-btn">‚úèÔ∏è Edit</button>
            <button onclick="resetFeedback('navigation')" class="reset-btn">üîÑ Reset</button>
          </div>

        </div>

        <button onclick="saveVoiceSettings()" style="margin-top: 20px; background: #00796b; color: white; padding: 12px 24px; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">üíæ Save All Settings</button>
      </div>
    </div>
    
    <div class="settings-section">
      <div class="settings-title">Jogging Tracker</div>
      <div class="settings-row">
        <span class="settings-label">Enable GPS Tracking</span>
        <label class="switch">
          <input id="gpsTrackingToggle" type="checkbox" checked onchange="toggleGPSTracking()"/>
          <span class="slider round"></span>
        </label>
      </div>
      <div class="settings-row">
        <span class="settings-label">Show Route Preview</span>
        <label class="switch">
          <input id="routePreviewToggle" type="checkbox" checked onchange="toggleRoutePreview()"/>
          <span class="slider round"></span>
        </label>
      </div>
    </div>
    

    <div class="settings-section" id="complexTasksDisplay" style="display: none;">
      <div class="settings-title">Your Complex Tasks & Automations</div>
      <div id="complexTasksList"></div>
    </div>

    <div class="settings-section">
      <div class="settings-title">üìä Data Management</div>
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 15px;">
        <!-- Export Section -->
        <div style="text-align: center;">
          <h4 style="margin-bottom: 15px; color: #00796b;">üì§ Export Data</h4>
          <button onclick="exportEntriesAsJSON()" style="background: linear-gradient(to right, #009688, #00796b); color: white; border: none; padding: 12px 16px; border-radius: 10px; cursor: pointer; width: 100%; font-size: 0.9rem; margin-bottom: 10px; transition: all 0.3s ease; box-shadow: 0 3px 8px rgba(0,150,136,0.3);" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 5px 12px rgba(0,150,136,0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 3px 8px rgba(0,150,136,0.3)'">
            üìÅ Export JSON
          </button>
          <button onclick="exportEntriesAsCSV()" style="background: linear-gradient(to right, #00acc1, #0097a7); color: white; border: none; padding: 12px 16px; border-radius: 10px; cursor: pointer; width: 100%; font-size: 0.9rem; transition: all 0.3s ease; box-shadow: 0 3px 8px rgba(0,172,193,0.3);" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 5px 12px rgba(0,172,193,0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 3px 8px rgba(0,172,193,0.3)'">
            üìä Export CSV
          </button>
        </div>
        
        <!-- Import Section -->
        <div style="text-align: center;">
          <h4 style="margin-bottom: 15px; color: #00796b;">üì• Import Data</h4>
          <label for="importFile" style="display: block; background: linear-gradient(to right, #ffa000, #ffca28); color: #333; text-align: center; padding: 12px 16px; border-radius: 10px; cursor: pointer; width: 100%; font-size: 0.9rem; margin-bottom: 10px; transition: all 0.3s ease; box-shadow: 0 3px 8px rgba(255,160,0,0.3); font-weight: 500;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 5px 12px rgba(255,160,0,0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 3px 8px rgba(255,160,0,0.3)'">
            üìÇ Select JSON File
          </label>
          <input accept=".json" id="importFile" style="display: none;" type="file"/>
          <button onclick="importFromJSON()" style="background: linear-gradient(to right, #7cb342, #689f38); color: white; border: none; padding: 12px 16px; border-radius: 10px; cursor: pointer; width: 100%; font-size: 0.9rem; transition: all 0.3s ease; box-shadow: 0 3px 8px rgba(124,179,66,0.3);" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 5px 12px rgba(124,179,66,0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 3px 8px rgba(124,179,66,0.3)'">
            üì§ Import JSON
          </button>
        </div>
      </div>
      
      <div style="margin-top: 20px; padding: 15px; background: rgba(0,121,107,0.1); border-radius: 10px; border-left: 4px solid #00796b;">
        <p style="margin: 0; font-size: 0.9rem; color: #004d40;">
          <strong>üí° Tip:</strong> Export your data regularly for backup. JSON files contain all your exercise data, voice feedback settings, and custom recordings.
        </p>
        <p style="margin: 8px 0 0 0; font-size: 0.85rem; color: #00695c;">
          <strong>üéôÔ∏è Voice Recordings:</strong> Custom voice recordings are stored locally and may be automatically deleted by your browser if storage space is low. Regular exports ensure your recordings are preserved.
        </p>
      </div>
    </div>

    <div class="settings-section">
      <div class="settings-title">About</div>
      <div id="aboutContent">
        <div style="text-align: center; margin-bottom: 20px;">
          <h2 style="color: #00796b; margin-bottom: 5px;">üèÜ Performa Theory</h2>
          <p style="font-style: italic; color: #666;">Mastering Progress Through Precision</p>
          <p><strong>Version: 2.0 (Voice-Enabled)</strong></p>
        </div>

        <div style="margin-bottom: 20px;">
          <h3 style="color: #00796b; border-bottom: 2px solid #00796b; padding-bottom: 5px;">üìã What is Performa Tracker?</h3>
          <p>Performa Tracker is a comprehensive fitness tracking app that transforms subjective workout logging into an <strong>objective, data-driven system</strong>. It helps you quantify your performance against your personal ideal standards using scientific scoring formulas.</p>
        </div>

        <div style="margin-bottom: 20px;">
          <h3 style="color: #00796b; border-bottom: 2px solid #00796b; padding-bottom: 5px;">üßÆ Scoring Formulas</h3>
          
          <h4 style="color: #004d40;">üéØ Exercise Quality (EQ) Formula:</h4>
          <div class="formula-card" style="background: #f0f8f7; padding: 10px; border-radius: 8px; margin: 10px 0; font-family: monospace; color: #004d40; border: 1px solid #c8e6c9;">
            EQ = Average Score for Selected Category<br>
            EQ = Sum of Today's Scores √∑ Number of Exercises
          </div>

          <h4 style="color: #004d40;">üìä Individual Exercise Scores:</h4>
          <ul style="margin: 10px 0;">
            <li><strong>Reps:</strong> <code>Score = Actual Reps √∑ Ideal Reps</code></li>
            <li><strong>Isometric:</strong> <code>Score = Actual Time √∑ Ideal Time</code></li>
            <li><strong>Semi-Isometric:</strong> <code>Score = (Actual Time √ó Reps) √∑ (Ideal Time √ó Ideal Reps)</code></li>
            <li><strong>Jogging:</strong> <code>Score = (Distance √ó Speed) √∑ (Ideal Distance √ó Ideal Speed)</code></li>
          </ul>

          <h4 style="color: #004d40;">üèÜ Total Performa Formula:</h4>
          <div class="formula-card" style="background: #f0f8f7; padding: 10px; border-radius: 8px; margin: 10px 0; font-family: monospace; color: #004d40; border: 1px solid #c8e6c9;">
            Total Performa = Today's Scores + Mastered Exercises Score
          </div>
        </div>

        <div style="margin-bottom: 20px;">
          <h3 style="color: #00796b; border-bottom: 2px solid #00796b; padding-bottom: 5px;">üèÉ‚Äç‚ôÇÔ∏è Activity Types</h3>
          <ul style="margin: 10px 0;">
            <li><strong>Reps:</strong> Push-ups, squats, pull-ups (repetition-based)</li>
            <li><strong>Isometric:</strong> Planks, wall sits (time-based holding)</li>
            <li><strong>Semi-Isometric:</strong> Burpees, mountain climbers (time + reps)</li>
            <li><strong>Jogging:</strong> Running, walking with GPS tracking</li>
          </ul>
        </div>

        <div style="margin-bottom: 20px;">
          <h3 style="color: #00796b; border-bottom: 2px solid #00796b; padding-bottom: 5px;">üéØ Exercise Categories</h3>
          <ul style="margin: 10px 0;">
            <li><strong>C.S.A</strong> - Chest, Shoulder &amp; Abs</li>
            <li><strong>C.P.E</strong> - Core, Power &amp; Endurance</li>
            <li><strong>CA.P</strong> - Cardio &amp; Power</li>
            <li><strong>L.B.S</strong> - Lower Body Strength</li>
          </ul>
        </div>

        <div style="margin-bottom: 20px;">
          <h3 style="color: #00796b; border-bottom: 2px solid #00796b; padding-bottom: 5px;">üé§ Voice Commands</h3>
          <h4 style="color: #004d40;">Exercise Logging:</h4>
          <ul style="margin: 10px 0;">
            <li>"log push-ups" - Auto-detects type and fills ideal values</li>
            <li>"set actual reps to 25" - Sets actual values</li>
            <li>"set ideal value to 20" - Sets ideal values</li>
          </ul>
          
          <h4 style="color: #004d40;">Navigation:</h4>
          <ul style="margin: 10px 0;">
            <li>"show progress" - Opens progress charts</li>
            <li>"show mastered" - Shows mastered exercises</li>
            <li>"show streak" - Opens streak tracker</li>
            <li>"start timer" / "stop timer" - Timer control</li>
          </ul>
        </div>

        <div style="margin-bottom: 20px;">
          <h3 style="color: #00796b; border-bottom: 2px solid #00796b; padding-bottom: 5px;">üìà Progress Tracking</h3>
          <ul style="margin: 10px 0;">
            <li><strong>üî• Streak Tracking:</strong> Consecutive days with logged exercises</li>
            <li><strong>üìä Progress Charts:</strong> Visual trends and improvements over time</li>
            <li><strong>üèÜ Mastered Exercises:</strong> Exercises with score ‚â• 1.00 contribute permanently</li>
            <li><strong>üì± Smart Autofill:</strong> Auto-populates ideal values when typing exercise names</li>
          </ul>
        </div>

        <div style="margin-bottom: 20px;">
          <h3 style="color: #00796b; border-bottom: 2px solid #00796b; padding-bottom: 5px;">üåê Advanced Features</h3>
          <ul style="margin: 10px 0;">
            <li><strong>üó∫Ô∏è GPS Jogging:</strong> Real-time route tracking with interactive maps</li>
            <li><strong>‚è±Ô∏è Smart Timer:</strong> Integrated countdown timer for exercises</li>
            <li><strong>ü§ñ Automation:</strong> Complex task automation with voice triggers</li>
            <li><strong>üì± Mobile Optimized:</strong> Touch-friendly with offline capabilities</li>
            <li><strong>üåô Customization:</strong> Dark mode, custom commands, personalized feedback</li>
          </ul>
        </div>

        <div style="margin-bottom: 20px;">
          <h3 style="color: #00796b; border-bottom: 2px solid #00796b; padding-bottom: 5px;">‚ú® Key Benefits</h3>
          <ul style="margin: 10px 0;">
            <li><strong>üéØ Precision Tracking:</strong> Quantified performance against personal standards</li>
            <li><strong>üöÄ Efficiency:</strong> Voice control and smart autofill eliminate manual input</li>
            <li><strong>üìä Analytics:</strong> Comprehensive scoring shows exercise quality and progress</li>
            <li><strong>üîÑ Automation:</strong> Intelligent detection and logging of exercises</li>
            <li><strong>üí™ Motivation:</strong> Streak challenges and mastery achievements</li>
            <li><strong>üåç Accessibility:</strong> Offline-first, voice-controlled, cross-platform</li>
          </ul>
        </div>

        <div style="background: linear-gradient(135deg, #e0f2f1, #f1f8e9); padding: 15px; border-radius: 12px; border-left: 4px solid #00796b; margin-top: 20px;">
          <h3 style="color: #00796b; margin-top: 0;">üéØ Core Value Proposition</h3>
          <p style="margin-bottom: 0;"><strong>Performa Tracker transforms fitness tracking into a gamified, scientific system</strong> where you compete against your own ideal standards while building consistent exercise habits through intelligent automation and motivational features.</p>
        </div>

        <div style="text-align: center; margin-top: 20px; padding: 10px; background: rgba(0, 121, 107, 0.1); border: 1px solid rgba(0, 121, 107, 0.3); border-radius: 8px;">
          <p style="margin: 0; color: #00796b; font-size: 0.9em;">
            <strong>Track your progress ‚Ä¢ Achieve mastery ‚Ä¢ Grow consistently</strong>
          </p>
        </div>
      </div>
    </div>
  </div>

  <!-- Route View Modal -->
  <div id="routeView" style="display: none;">
    <button onclick="hideRouteView()" class="close-btn">‚úï</button>
    <div class="route-container">
      <h2>Jogging Route</h2>
      <div id="mapDisplay" class="map-container">
        <div id="map" style="width: 100%; height: 100%;"></div>
        <div id="offlineNotice" class="offline-notice" style="display: none;">You are offline</div>
      </div>
      <div id="routeStats" class="route-stats">
        <h3>Route Statistics</h3>
        <p>Total Distance: <span id="routeDistance">0</span> km</p>
        <p>Duration: <span id="routeDuration">0</span> seconds</p>
        <p>Average Speed: <span id="routeAvgSpeed">0</span> km/h</p>
      </div>
      <button onclick="captureMap()" class="jog-btn" style="margin-top: 20px; width: 100%;">Capture Route Image</button>
    </div>
  </div>

  <!-- Streak Tracker View -->
  <div id="streakView" style="display: none; padding: 20px; max-width: 600px; margin: 0 auto;">
    <button onclick="hideStreakView()" class="view-back-btn">‚Üê Back</button>
    <h2 style="text-align: center; margin-top: 60px; color: #00e5ff;">üî• Streak Tracker</h2>
    
    <div class="streak-container" style="margin-top: 30px;">
      <div class="streak-card" style="background: linear-gradient(135deg, #004d40, #00796b); padding: 20px; border-radius: 16px; margin-bottom: 20px; box-shadow: 0 4px 15px rgba(0,0,0,0.3);">
        <div style="font-size: 1rem; color: #80cbc4;">üî• Current Streak</div>
        <div id="currentStreak" style="font-size: 3rem; font-weight: bold; color: #00e5ff; text-shadow: 0 0 10px rgba(0,229,255,0.5);">0</div>
      </div>
      
      <div class="streak-card" style="background: linear-gradient(135deg, #00796b, #00695c); padding: 20px; border-radius: 16px; margin-bottom: 20px; box-shadow: 0 4px 15px rgba(0,0,0,0.3);">
        <div style="font-size: 1rem; color: #80cbc4;">üèÜ Best Streak</div>
        <div id="bestStreak" style="font-size: 3rem; font-weight: bold; color: #ffc107; text-shadow: 0 0 10px rgba(255,193,7,0.5);">0</div>
      </div>
      
      <div style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 12px; margin-bottom: 20px;">
        <div style="font-size: 1rem; color: #80cbc4; margin-bottom: 10px;">üìÖ Last Log Date</div>
        <div id="lastLogDate" style="font-size: 1.2rem; color: white;">Never</div>
      </div>
      
      <div style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 12px; margin-bottom: 20px;">
        <div style="font-size: 1rem; color: #80cbc4; margin-bottom: 10px;">üìÖ Streak Summary</div>
        <div id="streakSummary" style="font-size: 1rem; color: white;">No streak data yet</div>
      </div>
      
      <div style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 12px;">
        <div style="font-size: 1rem; color: #80cbc4; margin-bottom: 10px; text-align: center;">Activity Calendar</div>
        <div id="streakCalendar" style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 8px;"></div>
      </div>
    </div>
  </div>

  <!-- Confirmation Dialog -->
  <div id="confirmationDialog" class="confirmation-dialog" style="display: none;">
    <div class="confirmation-content">
      <h3>Save Jogging Entry</h3>
      <p>Would you like to save this jogging session with the route image?</p>
      <div id="confirmationMap" class="map-container" style="height: 200px; margin: 15px 0;">
        <div id="confirmationMapView" style="width: 100%; height: 100%;"></div>
      </div>
      <div class="confirmation-buttons">
        <button class="cancel-btn" onclick="cancelSaveJogEntry()">Cancel</button>
        <button class="confirm-btn" onclick="confirmSaveJogEntry()">Save</button>
      </div>
    </div>
  </div>
  <!-- Automation Recorder Modal -->
  <div id="automationRecorderModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 99999;">
    <div class="automation-modal-content" style="width: 100%; height: 100%; margin: 0; border-radius: 0; display: flex; flex-direction: column; overflow: hidden; box-shadow: none;">
      
      <!-- Control Header -->
      <div class="automation-header" style="padding: 8px 16px; border-radius: 0; flex-shrink: 0; display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">
        
        <!-- Name Input -->
        <div style="flex: 1; min-width: 200px;">
          <input type="text" id="automationName" placeholder="Automation name..." style="width: 100%; padding: 6px 10px; border: 1px solid; border-radius: 4px; font-size: 0.85rem;">
        </div>
        
        <!-- Recording Mode Toggle -->
        <div class="mode-toggle" style="display: flex; background: rgba(255,255,255,0.1); border-radius: 12px; padding: 1px; border: 1px solid rgba(255,255,255,0.2);">
          <button id="timestampModeBtn" onclick="setRecordingMode('timestamp')" style="padding: 4px 8px; border: none; border-radius: 10px; font-size: 0.7rem; cursor: pointer; transition: all 0.2s; background: rgba(255,255,255,0.9); color: #333;">‚è±</button>
          <button id="sequenceModeBtn" onclick="setRecordingMode('sequence')" style="padding: 4px 8px; border: none; border-radius: 10px; font-size: 0.7rem; cursor: pointer; transition: all 0.2s; background: transparent; color: rgba(255,255,255,0.8);">üìã</button>
        </div>
        
        <!-- Recording Controls -->
        <div style="display: flex; align-items: center; gap: 6px;">
          <button id="startRecordingBtn" onclick="startRecording()" style="background: #f44336; color: white; padding: 6px 12px; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; font-size: 0.8rem; display: flex; align-items: center; gap: 4px; white-space: nowrap;">
            <span id="recordingIndicator">‚è∫</span>
            <span id="recordingButtonText">Record</span>
          </button>
          
          <div id="recordingStatus" style="display: none;">
            <span class="recording-pulse" style="width: 12px; height: 12px; background: #f44336; border-radius: 50%; animation: pulse 1s infinite;"></span>
          </div>
          
          <button id="saveAutomationBtn" onclick="saveAutomationSequence()" disabled style="background: #28a745; color: white; padding: 6px 12px; border: none; border-radius: 6px; cursor: pointer; font-size: 0.8rem; opacity: 0.6; white-space: nowrap;">üíæ</button>
          
          <button onclick="cancelAutomationRecording()" style="background: #dc3545; color: white; padding: 6px 8px; border: none; border-radius: 6px; cursor: pointer; font-size: 0.8rem; display: flex; align-items: center; justify-content: center;">‚úï</button>
        </div>
      </div>
      
      <!-- Status Bar -->
      <div class="automation-status" style="padding: 4px 16px; font-size: 0.7rem; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid;">
        <div id="recordedActionsCount" style="font-weight: 500;">0 actions</div>
        <div id="recordingTimer" style="display: none; font-weight: 500;">‚è∞ <span id="recordingTime">00:00</span></div>
      </div>
      
      <!-- Full Performa App iframe -->
      <div id="automationAppFrame" style="flex: 1; position: relative; overflow: hidden;">
        <iframe 
          id="performaAppIframe" 
          src="about:blank"
          style="width: 100%; height: 100%; border: none; background: white;"
          sandbox="allow-same-origin allow-scripts allow-forms allow-pointer-lock allow-popups allow-downloads"
          onload="onIframeLoad()">
        </iframe>
        
        <!-- Loading Overlay -->
        <div id="loadingOverlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 10;">
          <div style="text-align: center;">
            <div class="loading-spinner" style="width: 50px; height: 50px; border: 4px solid; border-top: 4px solid transparent; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px;"></div>
            <h3 style="margin: 0; font-size: 1.2rem; font-weight: 600;">Loading Full Performa App...</h3>
            <p style="margin: 10px 0 0 0; font-size: 0.9rem; opacity: 0.8;">Preparing complete app interface for automation recording</p>
          </div>
        </div>
      </div>
      

    </div>
  </div>

  <!-- TTS Feedback Edit Modal -->
  <div id="ttsEditModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 100000;">
    <div style="width: 90%; max-width: 500px; margin: 10vh auto; background: white; border-radius: 12px; padding: 24px; box-shadow: 0 20px 40px rgba(0,0,0,0.3);">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h3 style="margin: 0; color: #2d3748;">‚úèÔ∏è Edit TTS Message</h3>
        <button onclick="closeTTSModal()" style="background: #e53e3e; color: white; border: none; border-radius: 50%; width: 30px; height: 30px; cursor: pointer; font-size: 1rem;">‚úï</button>
      </div>
      
      <div style="margin-bottom: 20px;">
        <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #2d3748;" id="ttsModalLabel">Feedback Message:</label>
        <textarea id="ttsMessageInput" placeholder="Enter your text-to-speech message..." style="width: 100%; height: 80px; padding: 12px; border: 1px solid #e2e8f0; border-radius: 8px; font-size: 1rem; resize: vertical; font-family: inherit;"></textarea>
        <small style="color: #666; font-style: italic;">This message will be spoken using text-to-speech</small>
      </div>
      
      <div style="display: flex; gap: 12px; justify-content: flex-end;">
        <button onclick="testTTSMessage()" style="background: #38a169; color: white; padding: 10px 16px; border: none; border-radius: 6px; cursor: pointer;">üé§ Test</button>
        <button onclick="closeTTSModal()" style="background: #718096; color: white; padding: 10px 16px; border: none; border-radius: 6px; cursor: pointer;">Cancel</button>
        <button onclick="saveTTSMessage()" style="background: #3182ce; color: white; padding: 10px 16px; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">üíæ Save</button>
      </div>
    </div>
  </div>

  <!-- Custom Recording Modal -->
  <div id="customRecordModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 100000;">
    <div style="width: 95%; max-width: 600px; margin: 5vh auto; background: white; border-radius: 12px; padding: 24px; box-shadow: 0 20px 40px rgba(0,0,0,0.3); max-height: 85vh; overflow-y: auto;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h3 style="margin: 0; color: #2d3748;">üéôÔ∏è Custom Recording</h3>
        <button onclick="closeCustomRecordModal()" style="background: #e53e3e; color: white; border: none; border-radius: 50%; width: 30px; height: 30px; cursor: pointer; font-size: 1rem;">‚úï</button>
      </div>
      
      <div style="margin-bottom: 20px;">
        <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #2d3748;" id="customModalLabel">Recording for:</label>
        <div style="background: #f8fafc; padding: 12px; border-radius: 8px; border: 1px solid #e2e8f0;">
          <span id="customModalFeedbackName" style="font-weight: 600; color: #3182ce;"></span>
        </div>
      </div>

      <!-- Recording Section -->
      <div style="margin-bottom: 24px; padding: 16px; border: 2px dashed #e2e8f0; border-radius: 8px; background: #f8fafc;">
        <h4 style="margin: 0 0 12px 0; color: #2d3748;">üéôÔ∏è Record New Audio</h4>
        <div style="display: flex; gap: 12px; align-items: center; margin-bottom: 12px;">
          <button id="customRecordBtn" onclick="toggleCustomRecording()" style="background: #e53e3e; color: white; padding: 8px 16px; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">üéôÔ∏è Start Recording</button>
          <button id="customSaveRecordBtn" onclick="saveCustomRecording()" disabled style="background: #38a169; color: white; padding: 8px 16px; border: none; border-radius: 6px; cursor: pointer; opacity: 0.5;">üíæ Save Recording</button>
        </div>
        <div id="customRecordingStatus" style="font-size: 0.9rem; color: #666;"></div>
      </div>

      <!-- Upload Section -->
      <div style="margin-bottom: 24px; padding: 16px; border: 2px dashed #e2e8f0; border-radius: 8px; background: #f8fafc;">
        <h4 style="margin: 0 0 12px 0; color: #2d3748;">üìÅ Upload Audio File</h4>
        <div style="display: flex; gap: 12px; align-items: center; margin-bottom: 8px;">
          <input type="file" id="customAudioUpload" accept="audio/*" style="flex: 1;" />
          <button onclick="uploadCustomAudioFile()" style="background: #3182ce; color: white; padding: 8px 16px; border: none; border-radius: 6px; cursor: pointer;">üì§ Upload</button>
        </div>
        <small style="color: #666;">Supported formats: MP3, WAV, OGG. Max 5MB per file.</small>
      </div>

      <!-- Current Recording Display -->
      <div id="currentCustomRecording" style="margin-bottom: 20px; padding: 16px; border: 1px solid #e2e8f0; border-radius: 8px; background: white;">
        <h4 style="margin: 0 0 12px 0; color: #2d3748;">üìÑ Current Setting</h4>
        <div id="currentRecordingDisplay" style="color: #666; font-style: italic;">No custom recording set</div>
      </div>
      
      <div style="display: flex; gap: 12px; justify-content: flex-end;">
        <button onclick="testCurrentCustomRecording()" id="testCustomBtn" style="background: #38a169; color: white; padding: 10px 16px; border: none; border-radius: 6px; cursor: pointer;" disabled>üé§ Test</button>
        <button onclick="removeCustomRecording()" id="removeCustomBtn" style="background: #e53e3e; color: white; padding: 10px 16px; border: none; border-radius: 6px; cursor: pointer;" disabled>üóëÔ∏è Remove</button>
        <button onclick="closeCustomRecordModal()" style="background: #718096; color: white; padding: 10px 16px; border: none; border-radius: 6px; cursor: pointer;">Close</button>
      </div>
    </div>
  </div>
  
  <!-- Feedback System Styles -->
  <style>
  /* Custom Feedback Card Layout */
  .feedback-main-title {
    margin-bottom: 15px;
    margin-top: 20px;
    font-size: 1.1rem;
    color: #00796b;
    font-weight: 600;
  }

  .feedback-section {
    margin-bottom: 20px;
    background: #f1f5f9;
    padding: 15px;
    border-radius: 12px;
    border: 1px solid #e2e8f0;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
  }

  .feedback-item {
    margin-bottom: 15px;
    padding: 15px;
    border-radius: 12px;
    background: #f8fafc;
    border: 1px solid #e2e8f0;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    transition: all 0.3s ease;
  }

  .feedback-item:hover {
    box-shadow: 0 6px 12px rgba(0,0,0,0.15);
    transform: translateY(-1px);
  }

  .feedback-name {
    text-align: center;
    font-weight: 600;
    color: #004d40;
    font-size: 1.1rem;
    margin-bottom: 12px;
    padding-bottom: 8px;
    border-bottom: 1px solid #ccc;
  }

  .toggle-switch {
    display: flex;
    background: #ffffff;
    border-radius: 8px;
    padding: 4px;
    border: 1px solid #e2e8f0;
    margin-bottom: 12px;
    width: 100%;
    box-shadow: inset 0 1px 2px rgba(0,0,0,0.05);
  }

  .toggle-btn {
    flex: 1;
    padding: 8px 16px;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 0.9rem;
    font-weight: 500;
    background: transparent;
    color: #333;
    text-align: center;
  }

  .toggle-btn.active {
    background: #00796b;
    color: white;
  }

  .toggle-btn:hover:not(.active) {
    background: rgba(0, 121, 107, 0.1);
    color: #00796b;
  }
  .feedback-message {
    width: 100%;
    padding: 8px 12px;
    background: #ffffff;
    border: 1px solid #e2e8f0;
    border-radius: 8px;
    font-size: 1rem;
    color: #333;
    text-align: center;
    font-style: italic;
    margin-bottom: 12px;
    box-shadow: inset 0 1px 2px rgba(0,0,0,0.05);
  }

  .feedback-recording {
    width: 100%;
    padding: 12px 16px;
    background: #ecfdf5;
    border: 2px solid #22c55e;
    border-radius: 8px;
    font-size: 0.95rem;
    color: #15803d;
    text-align: center;
    margin-bottom: 14px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    box-shadow: 0 2px 8px rgba(34, 197, 94, 0.1);
  }

  .feedback-recording.no-recording {
    background: #fef2f2;
    border-color: #ef4444;
    color: #dc2626;
    box-shadow: 0 2px 8px rgba(239, 68, 68, 0.1);
  }

  .edit-btn {
    width: 100%;
    background: #00796b;
    color: white;
    padding: 10px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 0.9rem;
    transition: background-color 0.3s ease;
    margin-bottom: 8px;
  }

  .edit-btn:hover {
    background: #004d40;
  }

  .delete-btn {
    width: 100%;
    background: #d32f2f;
    color: white;
    padding: 10px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 0.9rem;
    transition: background-color 0.3s ease;
    margin-bottom: 8px;
  }

  .delete-btn:hover {
    background: #b71c1c;
  }

  .reset-btn {
    width: 100%;
    background: #6b7280;
    color: white;
    padding: 8px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 0.8rem;
    transition: background-color 0.3s ease;
  }

  .reset-btn:hover {
    background: #4b5563;
  }

  /* Modal Styles - Simplified */
  #ttsEditModal,
  #customRecordModal {
    background: rgba(0,0,0,0.7);
  }

  #ttsEditModal > div,
  #customRecordModal > div {
    background: white;
    color: #1a202c;
    border: none;
    box-shadow: 0 10px 30px rgba(0,0,0,0.2);
  }

  #ttsMessageInput {
    background: #f8fafc;
    color: #2d3748;
    border: 1px solid #e2e8f0;
    font-family: inherit;
  }

  #ttsMessageInput:focus {
    border-color: #4299e1;
    outline: none;
    background: white;
  }

  #customAudioUpload {
    background: #f8fafc;
    color: #2d3748;
    border: 1px solid #e2e8f0;
    border-radius: 4px;
    padding: 6px 8px;
    font-size: 0.9rem;
  }

  /* Dark mode styles */
  .dark-mode .feedback-main-title {
    color: #ffffff !important;
    text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
    font-weight: 700;
  }

  .dark-mode .feedback-section {
    background: #0a0a0a !important;
    border: 1px solid #222 !important;
    box-shadow: 0 6px 20px rgba(0,0,0,0.8) !important;
  }

  .dark-mode .feedback-item {
    background: #0f0f0f !important;
    border-color: #333 !important;
    box-shadow: 0 4px 12px rgba(0,0,0,0.6) !important;
  }

  .dark-mode .feedback-item:hover {
    box-shadow: 0 4px 8px rgba(0,0,0,0.4);
    transform: translateY(-1px);
  }

  .dark-mode .feedback-name {
    color: #ffffff !important;
    border-bottom-color: #444 !important;
    font-weight: 700;
  }

  .dark-mode .toggle-switch {
    background: #1a1a1a !important;
    border-color: #444 !important;
  }

  .dark-mode .toggle-btn {
    color: #f0f0f0 !important;
    font-weight: 600;
  }

  .dark-mode .toggle-btn.active {
    background: #004d40;
    color: white;
  }

  .dark-mode .toggle-btn:hover:not(.active) {
    background: rgba(0, 77, 64, 0.3);
    color: #80cbc4;
  }

  .dark-mode .feedback-message {
    background: #1a1a1a !important;
    border-color: #444 !important;
    color: #f0f0f0 !important;
  }

  .dark-mode .feedback-recording {
    background: #1a1a1a !important;
    border-color: #10b981 !important;
    color: #a7f3d0 !important;
    box-shadow: 0 2px 8px rgba(0,0,0,0.4) !important;
  }

  .dark-mode .feedback-recording.no-recording {
    background: #1a1a1a !important;
    border-color: #ef4444 !important;
    color: #fecaca !important;
    box-shadow: 0 2px 8px rgba(0,0,0,0.4) !important;
  }

  .dark-mode .edit-btn {
    background: #004d40 !important;
    color: #ffffff !important;
    font-weight: 600;
  }

  .dark-mode .edit-btn:hover {
    background: #00251a !important;
  }

  .dark-mode .delete-btn {
    background: #b71c1c !important;
    color: #ffffff !important;
    font-weight: 600;
  }

  .dark-mode .delete-btn:hover {
    background: #7f0000 !important;
  }

  .dark-mode .reset-btn {
    background: #333333 !important;
    color: #f0f0f0 !important;
    font-weight: 500;
  }

  .dark-mode .reset-btn:hover {
    background: #222222 !important;
  }

  /* Dark mode modal styles */
  .dark-mode #ttsEditModal > div,
  .dark-mode #customRecordModal > div {
    background: #1e1e1e !important;
    border: 1px solid #555 !important;
    box-shadow: 0 10px 30px rgba(0,0,0,0.8) !important;
    color: #e0e0e0 !important;
  }

  /* Modal headings and labels */
  .dark-mode #ttsEditModal h3,
  .dark-mode #customRecordModal h3,
  .dark-mode #ttsEditModal h4,
  .dark-mode #customRecordModal h4,
  .dark-mode #ttsEditModal label,
  .dark-mode #customRecordModal label {
    color: #f0f0f0 !important;
  }

  /* Modal text elements */
  .dark-mode #ttsEditModal small,
  .dark-mode #customRecordModal small,
  .dark-mode #ttsEditModal span,
  .dark-mode #customRecordModal span,
  .dark-mode #customRecordingStatus,
  .dark-mode #currentRecordingDisplay {
    color: #d0d0d0 !important;
  }

  /* Modal input and textarea */
  .dark-mode #ttsMessageInput,
  .dark-mode #customAudioUpload {
    background: #2d2d2d !important;
    border-color: #555 !important;
    color: #f0f0f0 !important;
  }

  .dark-mode #ttsMessageInput:focus {
    background: #333333 !important;
    border-color: #00796b !important;
  }

  .dark-mode #ttsEditModal input,
  .dark-mode #customRecordModal input {
    background: #2d2d2d !important;
    border-color: #555 !important;
    color: #f0f0f0 !important;
  }

  /* Modal section backgrounds */
  .dark-mode #ttsEditModal div[style*="background: #f8fafc"],
  .dark-mode #customRecordModal div[style*="background: #f8fafc"] {
    background: #2a2a2a !important;
    border-color: #444 !important;
  }

  .dark-mode #ttsEditModal div[style*="background: white"],
  .dark-mode #customRecordModal div[style*="background: white"] {
    background: #2a2a2a !important;
    border-color: #444 !important;
  }

  /* Modal buttons - maintain app theme colors */
  .dark-mode #ttsEditModal button[style*="background: #3182ce"],
  .dark-mode #customRecordModal button[style*="background: #3182ce"] {
    background: #00796b !important;
  }

  .dark-mode #ttsEditModal button[style*="background: #38a169"],
  .dark-mode #customRecordModal button[style*="background: #38a169"] {
    background: #004d40 !important;
  }

  .dark-mode #ttsEditModal button[style*="background: #e53e3e"],
  .dark-mode #customRecordModal button[style*="background: #e53e3e"] {
    background: #dc2626 !important;
  }

  .dark-mode #ttsEditModal button[style*="background: #718096"],
  .dark-mode #customRecordModal button[style*="background: #718096"] {
    background: #4b5563 !important;
  }
  </style>

  <!-- Automation Styles -->
  <style>
    @keyframes pulse {
      0% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.5; transform: scale(1.2); }
      100% { opacity: 1; transform: scale(1); }
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .recording-pulse {
      animation: pulse 1s infinite;
    }
    
    #recordingIndicator.recording {
      animation: pulse 0.8s infinite;
    }
    
    .loading-spinner {
      animation: spin 1s linear infinite;
    }
    
    /* Mobile Optimizations */
    .automation-modal-content {
      background: var(--card-background, #ffffff);
      color: var(--text-color, #333333);
      font-size: 14px;
    }
    
    /* Touch-friendly buttons */
    .automation-header button {
      min-height: 32px;
      min-width: 32px;
      touch-action: manipulation;
    }
    
    /* Responsive iframe container */
    #automationAppFrame {
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 10px;
      background: var(--background-color, #f5f5f5);
    }
    
    #performaAppIframe {
      transform-origin: 0 0;
      pointer-events: auto;
      width: min(100%, 400px);
      height: min(100%, 650px);
      max-width: 100%;
      max-height: 100%;
      border-radius: 8px;
      border: 1px solid var(--border-color, #e2e8f0);
      box-shadow: 0 4px 20px rgba(0,0,0,0.1);
    }
    
      .automation-header {
    background: linear-gradient(135deg, #00796b, #004d40) !important;
    color: white;
    border-color: rgba(255,255,255,0.2);
  }

  .automation-header input,
  .automation-header select {
    background: rgba(255,255,255,0.95) !important;
    color: #333 !important;
    border: 1px solid rgba(255,255,255,0.3) !important;
    border-radius: 6px;
    padding: 6px 10px;
  }

  .automation-status {
    background: #f8fafc !important;
    color: #666 !important;
    border-color: #e2e8f0 !important;
  }

  .automation-footer {
    background: #f8fafc !important;
    color: #666 !important;
    border-color: #e2e8f0 !important;
  }

  #loadingOverlay {
    background: rgba(255,255,255,0.95) !important;
    color: #333 !important;
  }

  .loading-spinner {
    border-color: #e2e8f0 !important;
    border-top-color: #00796b !important;
  }

  /* Light mode automation modal */
  .automation-modal-content {
    background: #ffffff !important;
    color: #333333 !important;
    font-size: 14px;
  }

  #automationAppFrame {
    background: #f1f5f9 !important;
  }

  #performaAppIframe {
    background: #ffffff !important;
    border-color: #e2e8f0 !important;
    box-shadow: 0 4px 20px rgba(0,0,0,0.1) !important;
  }
    
      /* Dark Mode Automation Styles */
  .dark-mode .automation-modal-content {
    background: #1e1e1e !important;
    color: #e0e0e0 !important;
  }

  .dark-mode #automationAppFrame {
    background: #0a0a0a !important;
  }
  .dark-mode #performaAppIframe {
    background: #1e1e1e !important;
    border-color: #555 !important;
    box-shadow: 0 4px 20px rgba(0,0,0,0.6) !important;
  }
  .dark-mode .automation-header {
    background: linear-gradient(135deg, #00796b, #004d40) !important;
    border-color: rgba(255,255,255,0.1) !important;
  }

  .dark-mode .automation-header input,
  .dark-mode .automation-header select {
    background: #2d2d2d !important;
    color: #e0e0e0 !important;
    border-color: #555 !important;
  }

  .dark-mode .automation-status,
  .dark-mode .automation-footer {
    background: #2a2a2a !important;
    color: #d0d0d0 !important;
    border-color: #555 !important;
  }

  /* Dark mode automation loading overlay */
  .dark-mode #loadingOverlay {
    background: rgba(30, 30, 30, 0.95) !important;
    color: #e0e0e0 !important;
  }

  .dark-mode .loading-spinner {
    border-color: #444 !important;
    border-top-color: #00796b !important;
  }

  /* Dark mode automation text elements */
  .dark-mode #loadingOverlay h3,
  .dark-mode #loadingOverlay p {
    color: #f0f0f0 !important;
  }
    
    /* Responsive automation window */
    @media (max-width: 768px) {
      #performaAppIframe {
        width: 100%;
        height: 100%;
        border-radius: 6px;
      }
      
      #automationAppFrame {
        padding: 5px;
      }
    }
  </style>

  <!-- Automation Edit Modal -->
  <div id="automationEditModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 99998;">
    <div style="width: 90%; max-width: 600px; margin: 5vh auto; background: white; border-radius: 15px; overflow: hidden; box-shadow: 0 10px 30px rgba(0,0,0,0.3);">
      
      <div style="background: linear-gradient(135deg, #9C27B0, #7B1FA2); color: white; padding: 20px;">
        <h3 style="margin: 0; font-size: 1.3rem;">‚úèÔ∏è Edit Automation</h3>
      </div>
      
      <div style="padding: 20px;">
        <div style="margin-bottom: 15px;">
          <label style="display: block; margin-bottom: 5px; font-weight: 600;">Automation Name:</label>
          <input type="text" id="editAutomationName" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-size: 1rem;">
        </div>
        
        <div style="margin-bottom: 15px;">
          <label style="display: block; margin-bottom: 5px; font-weight: 600;">Voice Commands (one per line):</label>
          <textarea id="editAutomationCommand" style="width: 100%; height: 60px; padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-size: 1rem; resize: vertical;"></textarea>
          <small style="color: #666; font-style: italic;">You can set multiple voice commands that trigger this automation</small>
        </div>
        
        <div style="margin-bottom: 20px;">
          <label style="display: block; margin-bottom: 5px; font-weight: 600;">Recorded Actions:</label>
          <div id="editAutomationActions" style="background: #f8f9fa; padding: 15px; border-radius: 8px; max-height: 200px; overflow-y: auto; border: 1px solid #e0e0e0;">
            <!-- Actions will be listed here -->
          </div>
        </div>
      </div>
      
      <div style="padding: 15px 20px; background: #f8f9fa; border-top: 1px solid #e0e0e0; display: flex; justify-content: space-between;">
        <button onclick="cancelEditAutomation()" style="background: #6c757d; color: white; padding: 10px 20px; border: none; border-radius: 20px; cursor: pointer;">Cancel</button>
        <button onclick="saveEditedAutomation()" style="background: #28a745; color: white; padding: 10px 20px; border: none; border-radius: 20px; cursor: pointer;">Save Changes</button>
      </div>
    </div>
  </div>

  <audio id="voiceBeep" src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+H2xW0jAy5+zezMeSsFJonO8dzOgSoFl2+z8qleJAg+ltryxHkpBCl+zfDegzQIDmKz8ut2JwU2jr/w0YYyBitrzPDOczMJI2Kz9eKNPgoMfcby2nsuBSuAyO/ejToJGGe687Nz">

  <!-- Add Leaflet JS with error handling -->
  <script>
    // Load Leaflet with fallback
    (function() {
      const script = document.createElement('script');
      script.src = 'https://unpkg.com/leaflet@1.7.1/dist/leaflet.js';
      script.onerror = () => console.log('Leaflet JS failed to load - maps will be disabled');
      document.head.appendChild(script);
    })();
  </script>

 <script>
// Global variables - App fully functional with all syntax errors fixed
let timerInterval, elapsed = 0;

// Mobile debug function
function showDebugInfo(message) {
  // Debug info disabled - app is working
  console.log(message);
}
let editingId = null;
let db, currentFilter = 'all';
let selectedCategory = null;
let nameHistory = [];
let recognizer;
let listening = false;
let progressChartInstance;
let voiceFeedbackInterval = 30; // Default interval in seconds
let lastFeedbackTime = 0;
let isAutomationRunning = false;
let voiceFeedbackEnabled = true;
let currentChartType = 'total';
let automationTimeouts = []; // Track automation timeouts to avoid conflicts
let manualInteractionTimestamp = 0; // Track manual interactions to prevent automation conflicts

// Add event listeners for manual interactions during automation
document.addEventListener('DOMContentLoaded', function() {
  // Track manual clicks on key buttons during automation
  const hamburgerBtn = document.querySelector('button[onclick*="toggleSidebar"]');
  const timerButtons = document.querySelectorAll('.timer-btns button');
  const backButtons = document.querySelectorAll('.view-back-btn');
  
  function markManualInteraction(event) {
    if (isAutomationRunning) {
      // Only mark as manual if the click was initiated by user, not automation
      const isAutomationClick = event.isTrusted === false || event.detail === 0;
      if (!isAutomationClick) {
        manualInteractionTimestamp = Date.now();
        console.log('Manual interaction detected during automation:', event.target);
      }
    }
  }
  
  // Add listeners to buttons that should remain manual during automation
  if (hamburgerBtn) hamburgerBtn.addEventListener('click', markManualInteraction);
  timerButtons.forEach(btn => btn.addEventListener('click', markManualInteraction));
  backButtons.forEach(btn => btn.addEventListener('click', markManualInteraction));
  
  // Add timer stability checks for automation
  timerButtons.forEach(btn => {
    btn.addEventListener('click', function(e) {
      // Ensure timer functions are called even during automation
      if (isAutomationRunning) {
        console.log('Timer button clicked during automation:', btn.textContent);
        // Add a small delay to ensure proper execution
        setTimeout(() => {
          const timerDisplay = document.getElementById('timer');
          if (timerDisplay) {
            console.log('Timer display after button click:', timerDisplay.textContent);
          }
        }, 100);
      }
    });
  });
  
  // Initialize main form tracking for automation recording
  if (typeof setupMainFormTracking === 'function') {
    setupMainFormTracking();
  }
});

// Jogging Tracker variables
let joggingInterval;
let joggingStartTime;
let joggingPositions = [];
let watchId = null;
let isJogging = false;
let gpsTrackingEnabled = true;
let routePreviewEnabled = true;
let map;
let polyline;
let routeImageData = null;
let confirmationMap = null;
let confirmationPolyline = null;

// Voice System variables
let currentVoiceUtterance = null;
let selectedVoice = null;
let complexTasks = JSON.parse(localStorage.getItem('complexTasks') || '[]');
let automationSequences = JSON.parse(localStorage.getItem('automationSequences') || '[]');
let isRecording = false;
let recordedActions = [];
let timerDuration = null;

// Custom recordings and feedback system variables  
let customRecordings = JSON.parse(localStorage.getItem('customRecordings') || '{}');
let currentRecordingBlob = null;
let mediaRecorder = null;
let recordedChunks = [];
let currentVoiceMode = localStorage.getItem('currentVoiceMode') || 'tts';

// Timer functions
function formatTime(ms) {
  const totalSeconds = Math.floor(ms / 1000);
  const hrs = String(Math.floor(totalSeconds / 3600)).padStart(2, '0');
  const mins = String(Math.floor((totalSeconds % 3600) / 60)).padStart(2, '0');
  const secs = String(totalSeconds % 60).padStart(2, '0');
  return `${hrs}:${mins}:${secs}`;
}
function updateTimerDisplay() {
  const timerElement = document.getElementById('timer');
  if (timerElement) {
    const formattedTime = formatTime(elapsed);
    timerElement.textContent = formattedTime;
    // Log during automation and first few updates to help debug
    if (isAutomationRunning || elapsed < 5000) {
      console.log('Timer updated:', formattedTime, 'Elapsed:', elapsed, 'Automation:', isAutomationRunning);
    }
  } else {
    console.error('Timer element not found!');
  }
}

function startTimer() {
  // Clear any existing timer first to prevent conflicts
  if (timerInterval) {
    clearInterval(timerInterval);
    timerInterval = null;
    console.log('Cleared existing timer interval');
  }
  
  // Timer should work regardless of automation state

  
  // Visual feedback during automation
  if (isAutomationRunning) {
    const statusDiv = document.getElementById('automationStatus');
    if (statusDiv) {
      statusDiv.textContent = '‚è±Ô∏è Timer Started!';
      
      // Show timer count for 3 seconds to verify it's working
      let count = 0;
      const testInterval = setInterval(() => {
        count++;
        if (statusDiv.textContent.includes('Timer Started')) {
          statusDiv.textContent = `‚è±Ô∏è Timer Running: ${count}s`;
        }
        if (count >= 3) {
          clearInterval(testInterval);
          if (statusDiv.textContent.includes('Timer Running')) {
            statusDiv.textContent = 'ü§ñ Automation continues...';
          }
        }
      }, 1000);
    }
  }
  
  const start = Date.now() - elapsed;
  
  // Try multiple approaches to ensure timer starts
  try {
    timerInterval = setInterval(() => {
      elapsed = Date.now() - start;
      updateTimerDisplay();
      
      // Voice feedback
      if (voiceFeedbackEnabled && listening) {
        const currentSeconds = Math.floor(elapsed / 1000);
        if (currentSeconds >= lastFeedbackTime + voiceFeedbackInterval) {
          lastFeedbackTime = currentSeconds;
          speakTimeFeedback(currentSeconds);
        }
      }
    }, 100);
    
    // Ensure timer works during automation by storing reference
    if (isAutomationRunning) {
      console.log('Timer starting during automation - ensuring stability');
      // Store timer reference to prevent interference
      window.activeTimerInterval = timerInterval;
      
      // Add a verification check after 1 second
      setTimeout(() => {
        if (!timerInterval) {
          console.warn('Timer interval was cleared during automation - restarting');
          // Restart timer if it was cleared
          if (window.activeTimerInterval !== timerInterval) {
            startTimer();
          }
        } else {
          console.log('Timer verified running during automation');
        }
      }, 1000);
    }
  } catch (error) {
    console.error('Error starting timer:', error);
  }
  
  // Force an immediate update to test
  updateTimerDisplay();
}



function stopTimer() {
  if (!timerInterval) return;
  
  // Timer should work regardless of automation state
  console.log('Timer stopped');
  
  // Visual feedback during automation
  if (isAutomationRunning) {
    const statusDiv = document.getElementById('automationStatus');
    if (statusDiv) {
      statusDiv.textContent = '‚èπÔ∏è Timer Stopped!';
      setTimeout(() => {
        if (statusDiv.textContent.includes('Timer Stopped')) {
          statusDiv.textContent = 'ü§ñ Automation continues...';
        }
      }, 1000);
    }
  }
  
  clearInterval(timerInterval);
  timerInterval = null;
  
  // Clear automation timer reference if it exists
  if (window.activeTimerInterval) {
    window.activeTimerInterval = null;
  }
  
  // Auto-fill actual time field when timer is stopped
  const type = document.getElementById('type').value;
  const elapsedSeconds = Math.floor(elapsed / 1000);
  
  if (type === 'iso' || type === 'semi') {
    const actualField = document.getElementById('actualValue');
    if (actualField) {
      actualField.value = elapsedSeconds;
    }
  }
}

function resetTimer() {
  // Timer should work regardless of automation state
  console.log('Timer reset');
  
  stopTimer();
  elapsed = 0;
  updateTimerDisplay();
}

function setTimerFor(seconds) {
  timerDuration = seconds * 1000; // Convert to milliseconds
  resetTimer();
  startTimer();
  
  // Set a timeout to stop the timer after the specified duration
  setTimeout(() => {
    if (timerInterval) {
      stopTimer();
      speakFeedback("Timer completed!");
    }
  }, timerDuration);
}

function speakTimeFeedback(seconds) {
  if (!('speechSynthesis' in window)) return;
  
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  
  let timeText = '';
  if (minutes > 0) {
    timeText = `${minutes} minute${minutes > 1 ? 's' : ''}`;
    if (remainingSeconds > 0) {
      timeText += ` and ${remainingSeconds} second${remainingSeconds > 1 ? 's' : ''}`;
    }
  } else {
    timeText = `${seconds} second${seconds > 1 ? 's' : ''}`;
  }
  
  // Use the configurable feedback system for timer intervals
  const setting = feedbackSettings['timerInterval'];
  if (setting && setting.mode === 'tts' && setting.message) {
    speakFeedback(timeText + " " + setting.message, 'timerInterval');
  } else {
    // Fall back to default message
    speakFeedback(timeText + " passed", 'timerInterval');
  }
}

// Individual Feedback System
let feedbackSettings = JSON.parse(localStorage.getItem('feedbackSettings') || '{}');
let currentEditingFeedback = null;
let modalMediaRecorder = null;
let modalRecordedChunks = [];
let modalCurrentRecordingBlob = null;

// Default feedback messages
const defaultFeedbacks = {
  startTimer: 'Timer started',
  stopTimer: 'Timer stopped', 
  resetTimer: 'Timer reset',
  timerSetFor: 'Timer set for',
  timerInterval: 'passed',
  startJog: 'Jogging started',
  stopJog: 'Jogging stopped',
  addEntry: 'Entry added',
  logExercise: 'Exercise logged',
  setActualReps: 'Actual reps set to',
  navigation: 'Navigated to'
};

function initializeFeedbackSystem() {
  // Initialize feedback settings with defaults
  Object.keys(defaultFeedbacks).forEach(key => {
    if (!feedbackSettings[key]) {
      feedbackSettings[key] = {
        mode: 'tts',
        message: defaultFeedbacks[key],
        customAudio: null
      };
    }
  });
  
  // Request persistent storage for voice recordings
  requestPersistentStorage();
  
  // Check storage usage and recording sizes
  checkStorageUsage();
  getRecordingStorageSize();
  
  // Update UI to reflect current settings
  updateAllFeedbackDisplays();
  localStorage.setItem('feedbackSettings', JSON.stringify(feedbackSettings));
}

async function requestPersistentStorage() {
  if ('storage' in navigator && 'persist' in navigator.storage) {
    try {
      const isPersistent = await navigator.storage.persist();
      if (isPersistent) {
        console.log('‚úÖ Persistent storage granted - voice recordings will be preserved');
      } else {
        console.log('‚ö†Ô∏è Persistent storage denied - voice recordings may be deleted by browser');
        // Still show a user-friendly message if recordings exist
        const hasRecordings = Object.keys(customRecordings).length > 0 || 
                             Object.values(feedbackSettings).some(setting => setting.customAudio);
        if (hasRecordings) {
          console.warn('üíæ Backup your voice recordings via Export Data to prevent loss');
        }
      }
    } catch (error) {
      console.warn('Storage persistence check failed:', error);
    }
  } else {
    console.log('‚ÑπÔ∏è Persistent storage API not supported');
  }
}

async function checkStorageUsage() {
  if ('storage' in navigator && 'estimate' in navigator.storage) {
    try {
      const estimate = await navigator.storage.estimate();
      const usedMB = (estimate.usage / (1024 * 1024)).toFixed(2);
      const quotaMB = (estimate.quota / (1024 * 1024)).toFixed(2);
      const usagePercent = ((estimate.usage / estimate.quota) * 100).toFixed(1);
      
      console.log(`üìä Storage Usage: ${usedMB}MB / ${quotaMB}MB (${usagePercent}%)`);
      
      // Warn if usage is high
      if (usagePercent > 80) {
        console.warn('‚ö†Ô∏è Storage usage is high. Consider cleaning up old recordings.');
        return { warning: true, usage: usagePercent, usedMB, quotaMB };
      }
      
      return { warning: false, usage: usagePercent, usedMB, quotaMB };
    } catch (error) {
      console.warn('Storage estimation failed:', error);
      return null;
    }
  }
  return null;
}

function getRecordingStorageSize() {
  try {
    // Calculate size of custom recordings
    const customRecordingsSize = JSON.stringify(customRecordings).length;
    
    // Calculate size of feedback settings with custom audio
    const feedbackSettingsSize = JSON.stringify(feedbackSettings).length;
    
    const totalBytes = customRecordingsSize + feedbackSettingsSize;
    const totalMB = (totalBytes / (1024 * 1024)).toFixed(2);
    
    console.log(`üéôÔ∏è Voice recordings storage: ${totalMB}MB`);
    return { bytes: totalBytes, mb: totalMB };
  } catch (error) {
    console.warn('Failed to calculate recording size:', error);
    return { bytes: 0, mb: '0.00' };
  }
}

// üìÅ File System Access API - Native App-like File Operations
async function saveRecordingToPhone(recordingKey, recording) {
  try {
    // Check if File System Access API is supported
    if (!('showSaveFilePicker' in window)) {
      console.log('File System Access API not supported - using download fallback');
      downloadRecordingFile(recordingKey, recording);
      return;
    }

    // Convert base64 to blob
    const response = await fetch(recording.audioData);
    const blob = await response.blob();
    
    // Show save dialog
    const fileHandle = await window.showSaveFilePicker({
      suggestedName: `${recording.label || recordingKey}_recording.wav`,
      types: [{
        description: 'Audio files',
        accept: {
          'audio/wav': ['.wav'],
          'audio/mpeg': ['.mp3'],
          'audio/*': ['.wav', '.mp3', '.ogg']
        }
      }]
    });

    // Write file to phone storage
    const writable = await fileHandle.createWritable();
    await writable.write(blob);
    await writable.close();

    console.log(`üì± Recording saved to phone storage: ${recording.label}`);
    alert(`‚úÖ Recording "${recording.label}" saved to your device!`);
    
  } catch (error) {
    if (error.name === 'AbortError') {
      console.log('User cancelled file save');
    } else {
      console.error('‚ùå Failed to save recording to phone:', error);
      // Fallback to download
      downloadRecordingFile(recordingKey, recording);
    }
  }
}

async function loadRecordingFromPhone() {
  try {
    // Check if File System Access API is supported
    if (!('showOpenFilePicker' in window)) {
      alert('File picker not supported. Please use the upload button instead.');
      return;
    }

    // Show file picker
    const [fileHandle] = await window.showOpenFilePicker({
      types: [{
        description: 'Audio files',
        accept: {
          'audio/wav': ['.wav'],
          'audio/mpeg': ['.mp3'],
          'audio/*': ['.wav', '.mp3', '.ogg']
        }
      }],
      multiple: false
    });

    const file = await fileHandle.getFile();
    
    // Convert to base64 for storage
    const reader = new FileReader();
    reader.onload = function(e) {
      const audioData = e.target.result;
      const label = file.name.replace(/\.[^/.]+$/, ""); // Remove extension
      
      // Save as custom recording
      const recordingId = Date.now().toString();
      customRecordings[label.toLowerCase()] = {
        id: recordingId,
        label: label,
        audioData: audioData,
        type: 'uploaded',
        createdAt: new Date().toISOString(),
        fileName: file.name
      };
      
      try {
        localStorage.setItem('customRecordings', JSON.stringify(customRecordings));
        updateCustomRecordingsList();
        alert(`‚úÖ Recording "${label}" loaded from your device!`);
        console.log(`üì± Recording loaded from phone: ${label}`);
      } catch (error) {
        delete customRecordings[label.toLowerCase()];
        if (error.name === 'QuotaExceededError') {
          alert('‚ùå Storage quota exceeded! Cannot load recording. Try clearing old recordings first.');
        } else {
          alert('‚ùå Failed to save recording: ' + error.message);
        }
      }
    };
    
    reader.readAsDataURL(file);
    
  } catch (error) {
    if (error.name === 'AbortError') {
      console.log('User cancelled file selection');
    } else {
      console.error('‚ùå Failed to load recording from phone:', error);
      alert('‚ùå Failed to load recording from device');
    }
  }
}

function downloadRecordingFile(recordingKey, recording) {
  // Fallback download method for browsers without File System Access API
  try {
    const link = document.createElement('a');
    link.href = recording.audioData;
    link.download = `${recording.label || recordingKey}_recording.wav`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    console.log(`üíæ Recording downloaded: ${recording.label}`);
    alert(`üì• Recording "${recording.label}" downloaded!`);
  } catch (error) {
    console.error('‚ùå Failed to download recording:', error);
    alert('‚ùå Failed to download recording');
  }
}
async function exportAppDataToPhone() {
  try {
    // Create comprehensive app data export
    const exportData = {
      timestamp: new Date().toISOString(),
      version: '1.0.0',
      app: 'Performa Voice Fitness Tracker',
      data: {
        feedbackSettings: feedbackSettings,
        customRecordings: customRecordings,
        voiceFeedbackInterval: voiceFeedbackInterval,
        voiceFeedbackEnabled: voiceFeedbackEnabled,
        // Include other app settings
        exportedAt: new Date().toISOString()
      }
    };

    const jsonString = JSON.stringify(exportData, null, 2);
    const blob = new Blob([jsonString], { type: 'application/json' });

    // Check if File System Access API is supported
    if ('showSaveFilePicker' in window) {
      try {
        const fileHandle = await window.showSaveFilePicker({
          suggestedName: `performa_voice_backup_${new Date().toISOString().split('T')[0]}.json`,
          types: [{
            description: 'JSON files',
            accept: {
              'application/json': ['.json']
            }
          }]
        });

        const writable = await fileHandle.createWritable();
        await writable.write(blob);
        await writable.close();

        console.log('üì± App data exported to phone storage');
        alert('‚úÖ App data (including voice recordings) saved to your device!');
        return;
      } catch (error) {
        if (error.name !== 'AbortError') {
          console.error('File System API failed, using download fallback:', error);
        }
      }
    }

    // Fallback to download
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `performa_voice_backup_${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(link.href);

    console.log('üíæ App data exported via download');
    alert('üì• App data backup downloaded to your device!');

  } catch (error) {
    console.error('‚ùå Failed to export app data:', error);
    alert('‚ùå Failed to export app data');
  }
}

function cleanupOldRecordings() {
  // This function can be called to remove unused recordings
  const recordingKeys = Object.keys(customRecordings);
  const feedbackKeys = Object.keys(feedbackSettings);
  
  // Find recordings that are not used in any feedback setting
  const unusedRecordings = recordingKeys.filter(key => {
    const isUsed = feedbackKeys.some(feedbackKey => {
      const setting = feedbackSettings[feedbackKey];
      return setting.mode === 'custom' && setting.customAudio;
    });
    return !isUsed;
  });
  
  if (unusedRecordings.length > 0) {
    console.log(`üßπ Found ${unusedRecordings.length} unused recordings that could be cleaned up`);
    return unusedRecordings;
  } else {
    console.log('‚úÖ No unused recordings found');
    return [];
  }
}

// üöÄ Enhanced Storage Strategy with IndexedDB for PWA
class PerformaStorage {
  constructor() {
    this.dbName = 'PerformaVoiceDB';
    this.version = 1;
    this.db = null;
  }

  async init() {
    try {
      this.db = await this.openDB();
      console.log('‚úÖ IndexedDB initialized for enhanced PWA storage');
      return true;
    } catch (error) {
      console.error('‚ùå IndexedDB initialization failed:', error);
      return false;
    }
  }

  openDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve(request.result);
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        
        // Voice recordings store
        if (!db.objectStoreNames.contains('voiceRecordings')) {
          const voiceStore = db.createObjectStore('voiceRecordings', { keyPath: 'id' });
          voiceStore.createIndex('label', 'label', { unique: false });
          voiceStore.createIndex('type', 'type', { unique: false });
          voiceStore.createIndex('createdAt', 'createdAt', { unique: false });
        }
        
        // Feedback settings store
        if (!db.objectStoreNames.contains('feedbackSettings')) {
          const feedbackStore = db.createObjectStore('feedbackSettings', { keyPath: 'key' });
          feedbackStore.createIndex('mode', 'mode', { unique: false });
        }
        
        // App data backup store
        if (!db.objectStoreNames.contains('appBackups')) {
          const backupStore = db.createObjectStore('appBackups', { keyPath: 'timestamp' });
          backupStore.createIndex('version', 'version', { unique: false });
        }
        
        console.log('üîß IndexedDB schema created/updated');
      };
    });
  }

  async saveVoiceRecording(recording) {
    try {
      const transaction = this.db.transaction(['voiceRecordings'], 'readwrite');
      const store = transaction.objectStore('voiceRecordings');
      
      const recordingData = {
        id: recording.id || Date.now().toString(),
        label: recording.label,
        audioData: recording.audioData,
        type: recording.type || 'recorded',
        createdAt: recording.createdAt || new Date().toISOString(),
        size: recording.audioData ? recording.audioData.length : 0
      };
      
      await store.put(recordingData);
      console.log(`üíæ Voice recording saved to IndexedDB: ${recording.label}`);
      return true;
    } catch (error) {
      console.error('‚ùå Failed to save recording to IndexedDB:', error);
      return false;
    }
  }

  async getVoiceRecording(id) {
    try {
      const transaction = this.db.transaction(['voiceRecordings'], 'readonly');
      const store = transaction.objectStore('voiceRecordings');
      const request = store.get(id);
      
      return new Promise((resolve, reject) => {
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    } catch (error) {
      console.error('‚ùå Failed to get recording from IndexedDB:', error);
      return null;
    }
  }

  async getAllVoiceRecordings() {
    try {
      const transaction = this.db.transaction(['voiceRecordings'], 'readonly');
      const store = transaction.objectStore('voiceRecordings');
      const request = store.getAll();
      
      return new Promise((resolve, reject) => {
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    } catch (error) {
      console.error('‚ùå Failed to get all recordings from IndexedDB:', error);
      return [];
    }
  }

  async deleteVoiceRecording(id) {
    try {
      const transaction = this.db.transaction(['voiceRecordings'], 'readwrite');
      const store = transaction.objectStore('voiceRecordings');
      await store.delete(id);
      console.log(`üóëÔ∏è Voice recording deleted from IndexedDB: ${id}`);
      return true;
    } catch (error) {
      console.error('‚ùå Failed to delete recording from IndexedDB:', error);
      return false;
    }
  }

  async getStorageQuota() {
    if ('storage' in navigator && 'estimate' in navigator.storage) {
      try {
        const estimate = await navigator.storage.estimate();
        return {
          used: estimate.usage,
          quota: estimate.quota,
          usedMB: (estimate.usage / (1024 * 1024)).toFixed(2),
          quotaMB: (estimate.quota / (1024 * 1024)).toFixed(2),
          usagePercent: ((estimate.usage / estimate.quota) * 100).toFixed(1)
        };
      } catch (error) {
        console.error('Failed to get storage estimate:', error);
        return null;
      }
    }
    return null;
  }

  async getIndexedDBSize() {
    try {
      const recordings = await this.getAllVoiceRecordings();
      let totalSize = 0;
      
      recordings.forEach(recording => {
        totalSize += recording.size || 0;
      });
      
      return {
        recordingCount: recordings.length,
        totalBytes: totalSize,
        totalMB: (totalSize / (1024 * 1024)).toFixed(2)
      };
    } catch (error) {
      console.error('Failed to calculate IndexedDB size:', error);
      return { recordingCount: 0, totalBytes: 0, totalMB: '0.00' };
    }
  }

  async createBackup() {
    try {
      const recordings = await this.getAllVoiceRecordings();
      const backup = {
        timestamp: Date.now(),
        version: '1.0.0',
        recordings: recordings,
        feedbackSettings: feedbackSettings,
        customRecordings: customRecordings,
        createdAt: new Date().toISOString()
      };
      
      const transaction = this.db.transaction(['appBackups'], 'readwrite');
      const store = transaction.objectStore('appBackups');
      await store.put(backup);
      
      console.log('üíæ App backup created in IndexedDB');
      return backup;
    } catch (error) {
      console.error('‚ùå Failed to create backup:', error);
      return null;
    }
  }
}

// Initialize enhanced storage
const performaStorage = new PerformaStorage();

function saveFeedbackSettingsWithErrorHandling() {
  try {
    localStorage.setItem('feedbackSettings', JSON.stringify(feedbackSettings));
    return true;
  } catch (error) {
    if (error.name === 'QuotaExceededError') {
      alert('‚ùå Storage quota exceeded! Cannot save feedback settings. Try:\n\n1. Export your data as backup\n2. Clear old recordings\n3. Free up storage space');
      console.error('Storage quota exceeded when saving feedback settings:', error);
      
      // Show storage usage info
      checkStorageUsage().then(usage => {
        if (usage) {
          console.warn(`Current usage: ${usage.usedMB}MB / ${usage.quotaMB}MB (${usage.usage}%)`);
        }
      });
    } else {
      alert('‚ùå Failed to save feedback settings: ' + error.message);
      console.error('Feedback settings save error:', error);
    }
    return false;
  }
}

function setFeedbackMode(feedbackKey, mode) {
  if (!feedbackSettings[feedbackKey]) {
    feedbackSettings[feedbackKey] = {
      mode: 'tts',
      message: defaultFeedbacks[feedbackKey] || '',
      customAudio: null
    };
  }
  
  feedbackSettings[feedbackKey].mode = mode;
  localStorage.setItem('feedbackSettings', JSON.stringify(feedbackSettings));
  
  // Update toggle buttons
  const ttsBtn = document.getElementById(`${feedbackKey}_tts_btn`);
  const customBtn = document.getElementById(`${feedbackKey}_custom_btn`);
  
  if (mode === 'tts') {
    ttsBtn.style.background = '#4299e1';
    ttsBtn.style.color = 'white';
    customBtn.style.background = 'transparent';
    customBtn.style.color = '#718096';
  } else {
    ttsBtn.style.background = 'transparent';
    ttsBtn.style.color = '#718096';
    customBtn.style.background = '#4299e1';
    customBtn.style.color = 'white';
  }
  
  // Update content display
  updateFeedbackDisplay(feedbackKey);
}

function updateFeedbackDisplay(feedbackKey) {
  const contentDiv = document.getElementById(`${feedbackKey}_content`);
  const setting = feedbackSettings[feedbackKey];
  
  if (!setting) return;
  
  if (setting.mode === 'tts') {
    contentDiv.innerHTML = `<div class="feedback-message">${setting.message || defaultFeedbacks[feedbackKey]}</div>`;
  } else {
    const hasCustomAudio = setting.customAudio !== null;
    if (hasCustomAudio) {
      contentDiv.innerHTML = `<div class="feedback-recording">üéôÔ∏è Custom recording ready</div>`;
    } else {
      contentDiv.innerHTML = `<div class="feedback-recording no-recording">‚ùå No recording set</div>`;
    }
  }
}

function resetFeedback(feedbackKey) {
  if (confirm(`Reset "${feedbackKey}" feedback to default?`)) {
    feedbackSettings[feedbackKey] = {
      mode: 'tts',
      message: defaultFeedbacks[feedbackKey],
      customAudio: null
    };
    
    localStorage.setItem('feedbackSettings', JSON.stringify(feedbackSettings));
    
    // Update UI
    setFeedbackMode(feedbackKey, 'tts');
    updateFeedbackDisplay(feedbackKey);
  }
}

function updateAllFeedbackDisplays() {
  Object.keys(defaultFeedbacks).forEach(key => {
    const setting = feedbackSettings[key];
    if (setting) {
      setFeedbackMode(key, setting.mode);
      updateFeedbackDisplay(key);
    }
  });
}

function openFeedbackModal(feedbackKey, mode) {
  currentEditingFeedback = feedbackKey;
  
  // If no mode specified, check current mode
  if (!mode) {
    const setting = feedbackSettings[feedbackKey];
    mode = setting ? setting.mode : 'tts';
  }
  
  if (mode === 'tts') {
    openTTSModal(feedbackKey);
  } else {
    openCustomRecordModal(feedbackKey);
  }
}

function openTTSModal(feedbackKey) {
  const modal = document.getElementById('ttsEditModal');
  const label = document.getElementById('ttsModalLabel');
  const input = document.getElementById('ttsMessageInput');
  
  const feedbackName = feedbackKey.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
  label.textContent = `${feedbackName} Message:`;
  
  const setting = feedbackSettings[feedbackKey];
  input.value = setting ? setting.message : defaultFeedbacks[feedbackKey];
  
  modal.style.display = 'block';
}

function closeTTSModal() {
  document.getElementById('ttsEditModal').style.display = 'none';
  currentEditingFeedback = null;
}

function testTTSMessage() {
  const input = document.getElementById('ttsMessageInput');
  const message = input.value.trim();
  if (message) {
    speakWithSystemVoice(message);
  }
}

function saveTTSMessage() {
  const input = document.getElementById('ttsMessageInput');
  const message = input.value.trim();
  
  if (!message) {
    alert('Please enter a message');
    return;
  }
  
  if (!feedbackSettings[currentEditingFeedback]) {
    feedbackSettings[currentEditingFeedback] = {
      mode: 'tts',
      message: '',
      customAudio: null
    };
  }
  
  feedbackSettings[currentEditingFeedback].message = message;
  localStorage.setItem('feedbackSettings', JSON.stringify(feedbackSettings));
  
  updateFeedbackDisplay(currentEditingFeedback);
  closeTTSModal();
}

function openCustomRecordModal(feedbackKey) {
  const modal = document.getElementById('customRecordModal');
  const feedbackNameSpan = document.getElementById('customModalFeedbackName');
  
  const feedbackName = feedbackKey.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
  feedbackNameSpan.textContent = feedbackName;
  
  updateCustomRecordingDisplay(feedbackKey);
  modal.style.display = 'block';
}

function closeCustomRecordModal() {
  document.getElementById('customRecordModal').style.display = 'none';
  currentEditingFeedback = null;
  
  // Reset recording state
  if (modalMediaRecorder && modalMediaRecorder.state !== 'inactive') {
    modalMediaRecorder.stop();
  }
  modalCurrentRecordingBlob = null;
  document.getElementById('customSaveRecordBtn').disabled = true;
  document.getElementById('customSaveRecordBtn').style.opacity = '0.5';
  document.getElementById('customRecordingStatus').textContent = '';
  document.getElementById('customRecordBtn').textContent = 'üéôÔ∏è Start Recording';
  document.getElementById('customRecordBtn').style.background = '#e53e3e';
}

 async function toggleCustomRecording() {
  const recordBtn = document.getElementById('customRecordBtn');
  const saveBtn = document.getElementById('customSaveRecordBtn');
  const statusDiv = document.getElementById('customRecordingStatus');
  
  if (!modalMediaRecorder || modalMediaRecorder.state === 'inactive') {
    // Start recording
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      modalMediaRecorder = new MediaRecorder(stream);
      modalRecordedChunks = [];
      
      modalMediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          modalRecordedChunks.push(event.data);
        }
      };
      
      modalMediaRecorder.onstop = () => {
        modalCurrentRecordingBlob = new Blob(modalRecordedChunks, { type: 'audio/wav' });
        saveBtn.disabled = false;
        saveBtn.style.opacity = '1';
        statusDiv.textContent = 'Recording ready to save';
        statusDiv.style.color = '#38a169';
        
        // Stop all tracks
        stream.getTracks().forEach(track => track.stop());
      };
      
      modalMediaRecorder.start();
      recordBtn.textContent = '‚èπÔ∏è Stop Recording';
      recordBtn.style.background = '#718096';
      statusDiv.textContent = 'Recording...';
      statusDiv.style.color = '#e53e3e';
      
    } catch (error) {
      console.error('Error accessing microphone:', error);
      alert('Could not access microphone. Please check permissions.');
    }
  } else {
    // Stop recording
    modalMediaRecorder.stop();
    recordBtn.textContent = 'üéôÔ∏è Start Recording';
    recordBtn.style.background = '#e53e3e';
  }
}

function saveCustomRecording() {
  if (!modalCurrentRecordingBlob || !currentEditingFeedback) {
    alert('No recording to save');
    return;
  }
  
  // Convert blob to base64 for storage
  const reader = new FileReader();
  reader.onload = function() {
    const audioData = reader.result;
    
    if (!feedbackSettings[currentEditingFeedback]) {
      feedbackSettings[currentEditingFeedback] = {
        mode: 'custom',
        message: defaultFeedbacks[currentEditingFeedback] || '',
        customAudio: null
      };
    }
    
    feedbackSettings[currentEditingFeedback].customAudio = audioData;
    feedbackSettings[currentEditingFeedback].mode = 'custom';
    
    try {
      localStorage.setItem('feedbackSettings', JSON.stringify(feedbackSettings));
    } catch (error) {
      // Revert the changes if storage failed
      delete feedbackSettings[currentEditingFeedback].customAudio;
      feedbackSettings[currentEditingFeedback].mode = 'tts';
      
      if (error.name === 'QuotaExceededError') {
        alert('‚ùå Storage quota exceeded! Cannot save custom audio feedback. Try:\n\n1. Export your data as backup\n2. Clear old recordings\n3. Use shorter audio recordings');
        console.error('Storage quota exceeded when saving feedback recording:', error);
        
        // Show storage usage info
        checkStorageUsage().then(usage => {
          if (usage) {
            console.warn(`Current usage: ${usage.usedMB}MB / ${usage.quotaMB}MB (${usage.usage}%)`);
          }
        });
      } else {
        alert('‚ùå Failed to save custom audio feedback: ' + error.message);
        console.error('Feedback recording save error:', error);
      }
      return; // Exit early if save failed
    }
    
    // Update UI
    setFeedbackMode(currentEditingFeedback, 'custom');
    updateCustomRecordingDisplay(currentEditingFeedback);
    
    // Reset recording state
    modalCurrentRecordingBlob = null;
    document.getElementById('customSaveRecordBtn').disabled = true;
    document.getElementById('customSaveRecordBtn').style.opacity = '0.5';
    document.getElementById('customRecordingStatus').textContent = '';
    document.getElementById('customRecordBtn').textContent = 'üéôÔ∏è Start Recording';
    document.getElementById('customRecordBtn').style.background = '#e53e3e';
    
    alert('Recording saved successfully!');
  };
  
  reader.readAsDataURL(modalCurrentRecordingBlob);
}

function uploadCustomAudioFile() {
  const fileInput = document.getElementById('customAudioUpload');
  const file = fileInput.files[0];
  
  if (!file || !currentEditingFeedback) {
    alert('Please select a file');
    return;
  }
  
  if (file.size > 5 * 1024 * 1024) { // 5MB limit
    alert('File size must be less than 5MB');
    return;
  }
  
  const reader = new FileReader();
  reader.onload = function() {
    const audioData = reader.result;
    
    if (!feedbackSettings[currentEditingFeedback]) {
      feedbackSettings[currentEditingFeedback] = {
        mode: 'custom',
        message: defaultFeedbacks[currentEditingFeedback] || '',
        customAudio: null
      };
    }
    
    feedbackSettings[currentEditingFeedback].customAudio = audioData;
    feedbackSettings[currentEditingFeedback].mode = 'custom';
    
    // Save with error handling
    if (!saveFeedbackSettingsWithErrorHandling()) {
      // Revert changes if save failed
      delete feedbackSettings[currentEditingFeedback].customAudio;
      feedbackSettings[currentEditingFeedback].mode = 'tts';
      return;
    }
    
    // Update UI
    setFeedbackMode(currentEditingFeedback, 'custom');
    updateCustomRecordingDisplay(currentEditingFeedback);
    
    // Reset form
    fileInput.value = '';
    
    alert('Audio file uploaded successfully!');
  };
  
  reader.readAsDataURL(file);
}
function updateCustomRecordingDisplay(feedbackKey) {
  const displayDiv = document.getElementById('currentRecordingDisplay');
  const testBtn = document.getElementById('testCustomBtn');
  const removeBtn = document.getElementById('removeCustomBtn');
  
  const setting = feedbackSettings[feedbackKey];
  
  if (setting && setting.customAudio) {
    displayDiv.innerHTML = `
      <div style="color: #38a169; font-weight: 600;">
        ‚úÖ Custom recording is set
        <br>
        <small style="color: #666; font-weight: normal;">
          Recording will be played instead of text-to-speech
        </small>
      </div>
    `;
    testBtn.disabled = false;
    testBtn.style.opacity = '1';
    removeBtn.disabled = false;
    removeBtn.style.opacity = '1';
  } else {
    displayDiv.innerHTML = `
      <div style="color: #666; font-style: italic;">
        No custom recording set. Use recording or upload above.
      </div>
    `;
    testBtn.disabled = true;
    testBtn.style.opacity = '0.5';
    removeBtn.disabled = true;
    removeBtn.style.opacity = '0.5';
  }
}

function testCurrentCustomRecording() {
  if (!currentEditingFeedback) return;
  
  const setting = feedbackSettings[currentEditingFeedback];
  if (setting && setting.customAudio) {
    playCustomAudioData(setting.customAudio);
  }
}

function removeCustomRecording() {
  if (!currentEditingFeedback) return;
  
  if (confirm('Remove the custom recording? This will switch back to text-to-speech.')) {
    const setting = feedbackSettings[currentEditingFeedback];
    if (setting) {
      setting.customAudio = null;
      setting.mode = 'tts';
      localStorage.setItem('feedbackSettings', JSON.stringify(feedbackSettings));
      
      // Update UI
      setFeedbackMode(currentEditingFeedback, 'tts');
      updateCustomRecordingDisplay(currentEditingFeedback);
    }
  }
}

function saveRecording() {
  const labelInput = document.getElementById('recordLabel');
  const label = labelInput.value.trim();
  
  if (!label || !currentRecordingBlob) {
    alert('No recording to save or missing label');
    return;
  }
  
  // Convert blob to base64 for storage
  const reader = new FileReader();
  reader.onload = function() {
    const audioData = reader.result;
    const recordingId = Date.now().toString();
    
    customRecordings[label.toLowerCase()] = {
      id: recordingId,
      label: label,
      audioData: audioData,
      type: 'recorded',
      createdAt: new Date().toISOString()
    };
    
    try {
      localStorage.setItem('customRecordings', JSON.stringify(customRecordings));
      updateCustomRecordingsList();
    } catch (error) {
      // Remove the recording from memory if storage failed
      delete customRecordings[label.toLowerCase()];
      
      if (error.name === 'QuotaExceededError') {
        alert('‚ùå Storage quota exceeded! Cannot save recording. Try:\n\n1. Export your data as backup\n2. Clear old recordings\n3. Use shorter recordings');
        console.error('Storage quota exceeded when saving recording:', error);
        
        // Show storage usage info
        checkStorageUsage().then(usage => {
          if (usage) {
            console.warn(`Current usage: ${usage.usedMB}MB / ${usage.quotaMB}MB (${usage.usage}%)`);
          }
        });
      } else {
        alert('‚ùå Failed to save recording: ' + error.message);
        console.error('Recording save error:', error);
      }
      return; // Exit early if save failed
    }
    
    // Reset form
    labelInput.value = '';
    currentRecordingBlob = null;
    document.getElementById('saveRecordBtn').disabled = true;
    document.getElementById('saveRecordBtn').style.opacity = '0.5';
    document.getElementById('recordingStatus').textContent = '';
    
    alert(`Recording "${label}" saved successfully!`);
  };
  
  reader.readAsDataURL(currentRecordingBlob);
}
function uploadCustomAudio() {
  const fileInput = document.getElementById('audioUpload');
  const labelInput = document.getElementById('audioLabel');
  const file = fileInput.files[0];
  const label = labelInput.value.trim();
  
  if (!file || !label) {
    alert('Please select a file and enter a label');
    return;
  }
  
  if (file.size > 5 * 1024 * 1024) { // 5MB limit
    alert('File size must be less than 5MB');
    return;
  }
  
  const reader = new FileReader();
  reader.onload = function() {
    const audioData = reader.result;
    const recordingId = Date.now().toString();
    
    customRecordings[label.toLowerCase()] = {
      id: recordingId,
      label: label,
      audioData: audioData,
      type: 'uploaded',
      fileName: file.name,
      createdAt: new Date().toISOString()
    };
    
    localStorage.setItem('customRecordings', JSON.stringify(customRecordings));
    updateCustomRecordingsList();
    
    // Reset form
    fileInput.value = '';
    labelInput.value = '';
    
    alert(`Audio file "${label}" uploaded successfully!`);
  };
  
  reader.readAsDataURL(file);
}

function updateCustomRecordingsList() {
  const listContainer = document.getElementById('customRecordingsList');
  const recordings = Object.values(customRecordings);
  
  if (recordings.length === 0) {
    listContainer.innerHTML = '<div style="padding: 10px; text-align: center; color: #666; font-style: italic;">No custom recordings yet</div>';
    return;
  }
  
  listContainer.innerHTML = recordings.map(recording => `
    <div style="padding: 10px; border-bottom: 1px solid #e2e8f0; display: flex; justify-content: space-between; align-items: center;">
      <div>
        <strong>${recording.label}</strong>
        <br>
        <small style="color: #666;">
          ${recording.type === 'recorded' ? 'üéôÔ∏è Recorded' : 'üìÅ Uploaded'} 
          ${recording.fileName ? `(${recording.fileName})` : ''} 
          - ${new Date(recording.createdAt).toLocaleDateString()}
        </small>
      </div>
      <div style="display: flex; gap: 5px;">
        <button onclick="playCustomRecording('${recording.label.toLowerCase()}')" style="background: #3182ce; color: white; padding: 4px 8px; border: none; border-radius: 3px; cursor: pointer; font-size: 0.8rem;">‚ñ∂Ô∏è Play</button>
        <button onclick="deleteCustomRecording('${recording.label.toLowerCase()}')" style="background: #e53e3e; color: white; padding: 4px 8px; border: none; border-radius: 3px; cursor: pointer; font-size: 0.8rem;">üóëÔ∏è</button>
      </div>
    </div>
  `).join('');
}

function playCustomRecording(key) {
  const recording = customRecordings[key];
  if (!recording) return;
  
  const audio = new Audio(recording.audioData);
  audio.play().catch(error => {
    console.error('Error playing custom recording:', error);
    alert('Could not play recording');
  });
}

function deleteCustomRecording(key) {
  const recording = customRecordings[key];
  if (!recording) return;
  
  if (confirm(`Delete recording "${recording.label}"?`)) {
    delete customRecordings[key];
    localStorage.setItem('customRecordings', JSON.stringify(customRecordings));
    updateCustomRecordingsList();
  }
}

function testCurrentVoiceMode() {
  const testMessage = "This is a test of your current voice feedback system.";
  
  if (currentVoiceMode === 'custom') {
    // Try to find a "test" or "hello" recording
    const testKeys = ['test', 'hello', 'timer started', 'entry added'];
    let foundRecording = null;
    
    for (const key of testKeys) {
      if (customRecordings[key]) {
        foundRecording = customRecordings[key];
        break;
      }
    }
    
    if (foundRecording) {
      playCustomRecording(foundRecording.label.toLowerCase());
    } else {
      alert('No custom recordings available for testing. Please record or upload an audio file first.');
    }
  } else {
    speakFeedback(testMessage);
  }
}

function getPremiumVoices() {
    return [
      // Premium Female Voices
      {
        name: "Aria Premium",
        description: "Premium Female Voice - Clear & Natural",
        lang: "en-US",
        rate: 1.0,
        pitch: 1.0,
        voiceURI: "premium-aria",
        isPremium: true,
        gender: "female"
      },
      {
        name: "Sophia Premium",
        description: "Premium Female Voice - Warm & Professional",
        lang: "en-US",
        rate: 1.0,
        pitch: 1.0,
        voiceURI: "premium-sophia",
        isPremium: true,
        gender: "female"
      },
      {
        name: "Emma Premium",
        description: "Premium Female Voice - Friendly & Engaging",
        lang: "en-US",
        rate: 1.0,
        pitch: 1.0,
        voiceURI: "premium-emma",
        isPremium: true,
        gender: "female"
      },
      
      // Premium Male Voices
      {
        name: "James Premium",
        description: "Premium Male Voice - Deep & Authoritative",
        lang: "en-US",
        rate: 1.0,
        pitch: 1.0,
        voiceURI: "premium-james",
        isPremium: true,
        gender: "male"
      },
      {
        name: "Oliver Premium",
        description: "Premium Male Voice - Smooth & Professional",
        lang: "en-US",
        rate: 1.0,
        pitch: 1.0,
        voiceURI: "premium-oliver",
        isPremium: true,
        gender: "male"
      },
      {
        name: "Alexander Premium",
        description: "Premium Male Voice - Clear & Confident",
        lang: "en-US",
        rate: 1.0,
        pitch: 1.0,
        voiceURI: "premium-alexander",
        isPremium: true,
        gender: "male"
      },
      
      // Premium British Voices
      {
        name: "Charlotte Premium",
        description: "Premium British Female - Elegant & Refined",
        lang: "en-GB",
        rate: 1.0,
        pitch: 1.0,
        voiceURI: "premium-charlotte",
        isPremium: true,
        gender: "female"
      },
      {
        name: "William Premium",
        description: "Premium British Male - Distinguished & Clear",
        lang: "en-GB",
        rate: 1.0,
        pitch: 1.0,
        voiceURI: "premium-william",
        isPremium: true,
        gender: "male"
      },
      
      // Premium Australian Voices
      {
        name: "Ruby Premium",
        description: "Premium Australian Female - Bright & Friendly",
        lang: "en-AU",
        rate: 1.0,
        pitch: 1.0,
        voiceURI: "premium-ruby",
        isPremium: true,
        gender: "female"
      },
      {
        name: "Jack Premium",
        description: "Premium Australian Male - Casual & Natural",
        lang: "en-AU",
        rate: 1.0,
        pitch: 1.0,
        voiceURI: "premium-jack",
        isPremium: true,
        gender: "male"
      }
    ];
  }
  
  function getHighQualityVoices(voices) {
  console.log('=== QUALITY FILTERING DEBUG ===');
  
  // Filter voices by quality indicators
  let qualityVoices = [];
  
  // 1. First priority: Google voices (highest quality)
  const googleVoices = voices.filter(voice => {
    const isGoogle = voice.name.toLowerCase().includes('google') && voice.lang.toLowerCase().startsWith('en');
    if (isGoogle) console.log('‚úÖ Google voice found:', voice.name);
    return isGoogle;
  });
  console.log('Google voices found:', googleVoices.length);
  
  // 2. Second priority: Apple voices (iOS/macOS)
  const appleVoices = voices.filter(voice => {
    const isApple = (voice.name.toLowerCase().includes('apple') || 
     voice.name.toLowerCase().includes('siri') ||
     // iOS/macOS system voices that are high quality
     (voice.localService && (
       voice.name.includes('Samantha') || 
       voice.name.includes('Alex') || 
       voice.name.includes('Victoria') ||
       voice.name.includes('Daniel') ||
       voice.name.includes('Karen') ||
       voice.name.includes('Moira') ||
       voice.name.includes('Tessa')
     ))) &&
    voice.lang.toLowerCase().startsWith('en') &&
    !isLowQualityVoice(voice);
    
    if (isApple) console.log('‚úÖ Apple voice found:', voice.name);
    return isApple;
  });
  console.log('Apple voices found:', appleVoices.length);
  
  // 3. Third priority: Microsoft voices
  const microsoftVoices = voices.filter(voice => {
    const isMicrosoft = voice.name.toLowerCase().includes('microsoft') && 
      voice.lang.toLowerCase().startsWith('en') &&
      !isLowQualityVoice(voice);
    
    if (isMicrosoft) console.log('‚úÖ Microsoft voice found:', voice.name);
    return isMicrosoft;
  });
  console.log('Microsoft voices found:', microsoftVoices.length);
  
  // 4. Other high-quality indicators - STRICT whitelist approach
  const otherQualityVoices = voices.filter(voice => {
    if (!voice.lang.toLowerCase().startsWith('en')) return false;
    if (voice.name.toLowerCase().includes('google')) return false;
    if (voice.name.toLowerCase().includes('microsoft')) return false;
    if (voice.name.toLowerCase().includes('apple')) return false;
    
    const voiceName = voice.name.toLowerCase();
    
    // Strict whitelist of quality indicators - must have one of these
    const qualityIndicators = [
      'enhanced', 'natural', 'premium', 'neural', 'wavenet', 'standard',
      'english united states', 'english united kingdom', 'english australia', 'english canada',
      'samsung', 'high quality', 'enhanced', 'neural', 'studio',
      // Known good system voice names
      'samantha', 'alex', 'victoria', 'daniel', 'karen', 'moira', 'tessa',
      'zira', 'david', 'mark', 'hazel', 'susan'
    ];
    
    const hasQualityIndicator = qualityIndicators.some(indicator => 
      voiceName.includes(indicator)
    );
    
    // Additional check: must not be a simple language code pattern
    const isSimpleCode = /^[a-z]{2}[-_]?[a-z]{2}$/i.test(voice.name);
    const isVeryShort = voice.name.length <= 6;
    
    // Must have quality indicator AND not be a simple code AND be reasonable length
    const isQuality = hasQualityIndicator && !isSimpleCode && !isVeryShort && !isLowQualityVoice(voice);
    
    if (isQuality) {
      console.log('‚úÖ Other quality voice found:', voice.name);
    } else {
      console.log(`‚ùå Rejected voice "${voice.name}" - hasQuality: ${hasQualityIndicator}, isSimpleCode: ${isSimpleCode}, isVeryShort: ${isVeryShort}`);
    }
    
    return isQuality;
  });
  console.log('Other quality voices found:', otherQualityVoices.length);
  
  // Combine in priority order
  qualityVoices = [
    ...googleVoices,
    ...appleVoices, 
    ...microsoftVoices,
    ...otherQualityVoices
  ];
  
  // Remove duplicates while preserving order
  const uniqueVoices = [];
  const seenNames = new Set();
  
  for (const voice of qualityVoices) {
    if (!seenNames.has(voice.name)) {
      seenNames.add(voice.name);
      uniqueVoices.push(voice);
    }
  }
  
  // If no high-quality voices found, use a more permissive fallback
  if (uniqueVoices.length === 0) {
    console.log('No high-quality voices found, using permissive fallback');
    
    // Try to find ANY decent English voice (not just language codes)
    const decentVoices = voices.filter(voice => 
      voice.lang.toLowerCase().startsWith('en') &&
      voice.name.length > 5 &&  // Not just language codes
      !voice.name.match(/^[a-z]{2}[-_]?[a-z]{2}$/i) // Not simple codes like en-US
    );
    
    if (decentVoices.length > 0) {
      console.log('Found decent fallback voices:', decentVoices.map(v => v.name));
      uniqueVoices.push(...decentVoices.slice(0, 3)); // Take first 3 decent ones
    } else {
      // Last resort: take the first English voice
      const fallbackVoice = voices.find(voice => voice.lang.toLowerCase().startsWith('en'));
      if (fallbackVoice) {
        console.log('Using last resort fallback:', fallbackVoice.name);
        uniqueVoices.push(fallbackVoice);
      }
    }
  }
  
  return uniqueVoices;
}

function isLowQualityVoice(voice) {
  const lowQualityIndicators = [
    // Generic system voice codes that are typically robotic
    /^en-[A-Z]{2}$/,  // Matches en-US, en-GB, en-IN, etc.
    /^[a-z]{2}-[A-Z]{2}$/,  // Matches any basic locale code like hi-IN, ta-IN
    
    // Known low-quality voice engines
    'espeak',
    'festival',
    'flite',
    'pico',
    'robot',
    'synthetic',
    'mechanical',
    
    // Android low-quality indicators
    'hindi',
    'tamil',
    'marathi',
    'gujarati',
    'bengali',
    'telugu',
    'kannada',
    'malayalam',
    'punjabi',
    'urdu',
    
    // Very short names (usually system defaults)
    /^[a-zA-Z]{1,3}$/,
    
    // Common robotic voice patterns
    /^[a-z]{2}$/,  // Like "en", "hi", etc.
    /^[a-z]{2}_[a-z]{2}$/,  // Like "en_us", "hi_in"
  ];
  
  const voiceName = voice.name.toLowerCase();
  const voiceLang = voice.lang.toLowerCase();
  
  // Filter out non-English voices for this app first
  if (!voiceLang.startsWith('en')) {
    console.log(`‚ùå Filtered out non-English voice: "${voice.name}" (${voice.lang})`);
    return true;
  }
  
  // Check against low-quality indicators
  for (const indicator of lowQualityIndicators) {
    if (typeof indicator === 'string' && (voiceName.includes(indicator) || voiceLang.includes(indicator))) {
      console.log(`‚ùå Filtered out low-quality voice (${indicator}): "${voice.name}" (${voice.lang})`);
      return true;
    }
    if (indicator instanceof RegExp && (indicator.test(voice.name) || indicator.test(voice.lang))) {
      console.log(`‚ùå Filtered out low-quality voice (regex): "${voice.name}" (${voice.lang})`);
      return true;
    }
  }
  
  // Filter out voices that are just language codes or very basic names
  if (voice.name.length <= 5 && /^[a-zA-Z-_]+$/.test(voice.name)) {
    console.log(`‚ùå Filtered out short/basic name: "${voice.name}" (${voice.lang})`);
    return true;
  }
  
  // Android specific: Filter out voices with 'network' in name as they're often low quality
  if (voiceName.includes('network') && !voiceName.includes('google')) {
    console.log(`‚ùå Filtered out network voice: "${voice.name}" (${voice.lang})`);
    return true;
  }
  
  console.log(`‚úÖ Voice passed quality check: "${voice.name}" (${voice.lang})`);
  return false;
}

// Old voice initialization function removed - now using custom recording system

// Old voice selection functions removed - now using custom recording system

function speakFeedback(text, feedbackKey = null) {
  if (!voiceFeedbackEnabled) {
    console.log('Voice feedback disabled');
    return;
  }
  
  // Ensure speechSynthesis is available
  if (!('speechSynthesis' in window)) {
    console.warn('Speech synthesis not supported');
    return;
  }
  
  // Stop any currently speaking utterance
  if (currentVoiceUtterance) {
    speechSynthesis.cancel();
  }
  
  // Add a small delay to prevent audio conflicts
  setTimeout(() => {
    // Clean up text by removing any JSON-like content
    text = text.replace(/\{.*?\}/g, '').trim();
    if (!text) return;
    
    // If we have a specific feedback key, use its settings
    if (feedbackKey && feedbackSettings[feedbackKey]) {
      const setting = feedbackSettings[feedbackKey];
      
      if (setting.mode === 'custom' && setting.customAudio) {
        // Play custom recording
        playCustomAudioData(setting.customAudio);
        addVoiceMessage('custom', `üéôÔ∏è Custom: ${text}`);
        return;
      } else if (setting.mode === 'tts') {
        // Use custom TTS message
        speakWithSystemVoice(setting.message);
        return;
      }
    }
    
    // Fall back to default TTS
    speakWithSystemVoice(text);
  }, 100); // Small delay to prevent audio conflicts
}

function playCustomAudioData(audioData) {
  try {
    const audio = new Audio(audioData);
    audio.play().catch(error => {
      console.error('Error playing custom audio:', error);
      // Fall back to TTS if audio fails
      speakWithSystemVoice('Audio playback failed');
    });
  } catch (error) {
    console.error('Error creating audio:', error);
    speakWithSystemVoice('Audio error');
  }
}
function findMatchingCustomRecording(text) {
  const lowerText = text.toLowerCase();
  
  // Direct matches first
  if (customRecordings[lowerText]) {
    return lowerText;
  }
  
  // Keyword matching for common feedback messages
  const keywordMap = {
    'timer': ['timer started', 'timer stopped', 'timer reset', 'timer completed'],
    'entry': ['entry added', 'entry saved', 'entry deleted'],
    'reps': ['reps set', 'repetitions set'],
    'category': ['category set', 'category changed'],
    'workout': ['workout started', 'workout completed', 'workout mode'],
    'progress': ['progress view', 'showing progress'],
    'archive': ['archive view', 'showing archive'],
    'settings': ['settings', 'opening settings'],
    'hello': ['hello', 'welcome', 'good morning', 'good evening'],
    'great': ['great job', 'excellent', 'well done', 'good work'],
    'completed': ['completed', 'finished', 'done']
  };
  
  // Check each keyword category
  for (const [keyword, phrases] of Object.entries(keywordMap)) {
    if (lowerText.includes(keyword)) {
      // Look for matching recordings
      for (const phrase of phrases) {
        if (customRecordings[phrase]) {
          return phrase;
        }
      }
    }
  }
  
  // Check for partial matches in recording labels
  for (const [key, recording] of Object.entries(customRecordings)) {
    if (lowerText.includes(key) || key.includes(lowerText)) {
      return key;
    }
  }
  
  return null;
}

function speakWithPremiumVoice(text, premiumVoice) {
  // Enhanced premium voice with better speech patterns
  const utterance = new SpeechSynthesisUtterance(text);
  
  // Premium voice settings for more natural speech
  utterance.rate = premiumVoice.rate || 0.9; // Slightly slower for clarity
  utterance.pitch = premiumVoice.pitch || (premiumVoice.gender === 'female' ? 1.1 : 0.9);
  utterance.volume = 1.0;
  
  // Apply premium voice characteristics
  if (premiumVoice.gender === 'female') {
    utterance.pitch = Math.min(1.2, utterance.pitch + 0.1);
  } else {
    utterance.pitch = Math.max(0.8, utterance.pitch - 0.1);
  }
  
  // Enhanced text processing for premium voices
  let enhancedText = text;
  
  // Add natural pauses and emphasis
  enhancedText = enhancedText.replace(/\. /g, '.  '); // Longer pauses between sentences
  enhancedText = enhancedText.replace(/([!?])/g, '$1 '); // Pause after exclamations
  enhancedText = enhancedText.replace(/,/g, ', '); // Slight pause after commas
  
  // Improve pronunciation of common fitness terms
  enhancedText = enhancedText.replace(/\breps\b/gi, 'repetitions');
  enhancedText = enhancedText.replace(/\bC\.S\.A\b/gi, 'C S A');
  enhancedText = enhancedText.replace(/\bC\.P\.E\b/gi, 'C P E');
  enhancedText = enhancedText.replace(/\bCA\.P\b/gi, 'C A P');
  enhancedText = enhancedText.replace(/\bL\.B\.S\b/gi, 'L B S');
  
  utterance.text = enhancedText;
  
  // Try to find a similar system voice as fallback
  const systemVoices = speechSynthesis.getVoices();
  let fallbackVoice = null;
  
  if (premiumVoice.gender === 'female') {
    fallbackVoice = systemVoices.find(v => 
      v.lang.startsWith('en') && 
      (v.name.toLowerCase().includes('female') || 
       v.name.toLowerCase().includes('woman') ||
       v.name.toLowerCase().includes('samantha') ||
       v.name.toLowerCase().includes('zira'))
    );
  } else {
    fallbackVoice = systemVoices.find(v => 
      v.lang.startsWith('en') && 
      (v.name.toLowerCase().includes('male') || 
       v.name.toLowerCase().includes('man') ||
       v.name.toLowerCase().includes('david') ||
       v.name.toLowerCase().includes('mark'))
    );
  }
  
  if (fallbackVoice) {
    utterance.voice = fallbackVoice;
  }
  
  currentVoiceUtterance = utterance;
  
  utterance.onstart = () => {
    updateVoiceStatus(`Premium Voice: ${premiumVoice.name}`, 'feedback');
  };
  
  utterance.onend = () => {
    currentVoiceUtterance = null;
    updateVoiceStatus('Premium Voice: Ready', 'ready');
  };
  
  utterance.onerror = () => {
    console.log('Premium voice failed, falling back to system voice');
    speakWithSystemVoice(text);
  };
  
  speechSynthesis.speak(utterance);
  addVoiceMessage('premium', `üéôÔ∏è ${premiumVoice.name}: ${text}`);
}
function speakWithSystemVoice(text) {
  if (!('speechSynthesis' in window)) return;
  
  const utterance = new SpeechSynthesisUtterance(text);
  utterance.rate = 1.0;
  utterance.pitch = 1.05;
  utterance.volume = 1;
  
  // Use default system voice - let browser choose the best one
  const voices = speechSynthesis.getVoices();
  if (voices.length > 0) {
    // Try to find a good English voice
    const englishVoice = voices.find(v => v.lang.startsWith('en') && v.default) ||
                        voices.find(v => v.lang.startsWith('en')) ||
                        voices[0];
    
    if (englishVoice) {
      utterance.voice = englishVoice;
    }
  }
  
  // Add slight pauses between sentences for more natural speech
  utterance.text = utterance.text.replace(/\. /g, '.  ');
  
  currentVoiceUtterance = utterance;
  
  utterance.onstart = () => {
    updateVoiceStatus('TTS Feedback', 'feedback');
  };
  
  utterance.onend = () => {
    currentVoiceUtterance = null;
    updateVoiceStatus('Voice: Ready', 'ready');
  };
  
  utterance.onerror = (event) => {
    console.error('Speech synthesis error:', event);
    currentVoiceUtterance = null;
    updateVoiceStatus('Voice: Ready', 'ready');
  };
  
  speechSynthesis.speak(utterance);
  addVoiceMessage('tts', `ü§ñ TTS: ${text}`);
}

// UI functions
function toggleSidebar() {
  // Allow sidebar toggle even during automation
  const sidebar = document.getElementById("sidebar");
  const overlay = document.getElementById("overlay");
  const isOpen = sidebar.style.left === "0px";
  sidebar.style.left = isOpen ? "-220px" : "0px";
  overlay.style.display = isOpen ? "none" : "block";
  
  console.log(`Sidebar ${isOpen ? 'closed' : 'opened'}`);
}

function toggleDarkMode() {
  const isDark = document.body.classList.toggle("dark-mode");
  localStorage.setItem("darkMode", isDark ? "on" : "off");
}

function toggleVoiceCommands() {
  voiceFeedbackEnabled = document.getElementById("voiceCommandsToggle").checked;
  localStorage.setItem("voiceCommandsEnabled", voiceFeedbackEnabled ? "on" : "off");
}

function toggleVoiceFeedback() {
  const enabled = document.getElementById("voiceFeedbackToggle").checked;
  localStorage.setItem("voiceFeedbackEnabled", enabled ? "on" : "off");
  voiceFeedbackEnabled = enabled;
}

function getVoiceCommands() {
  return {
    startTimer: localStorage.getItem("startTimerCommand") || "start timer",
    stopTimer: localStorage.getItem("stopTimerCommand") || "stop timer",
    resetTimer: localStorage.getItem("resetTimerCommand") || "reset timer",
    startTimerFor: localStorage.getItem("startTimerForCommand") || "start timer for",
    startJog: localStorage.getItem("startJogCommand") || "start jog",
    stopJog: localStorage.getItem("stopJogCommand") || "stop jog",
    addEntry: localStorage.getItem("addEntryCommand") || "add entry",
    logExercise: localStorage.getItem("logExerciseCommand") || "log for",
    setActualReps: localStorage.getItem("setActualRepsCommand") || "actual reps are",
    showProgress: localStorage.getItem("showProgressCommand") || "show progress",
    showArchive: localStorage.getItem("showArchiveCommand") || "show archive",
    openSettings: localStorage.getItem("openSettingsCommand") || "open settings",
    goHome: localStorage.getItem("goHomeCommand") || "go home",
    startTimerFeedback: localStorage.getItem("startTimerFeedback") || "Timer started",
    stopTimerFeedback: localStorage.getItem("stopTimerFeedback") || "Timer stopped",
    resetTimerFeedback: localStorage.getItem("resetTimerFeedback") || "Timer reset",
    timerSetFeedback: localStorage.getItem("timerSetFeedback") || "Timer set for",
    startJogFeedback: localStorage.getItem("startJogFeedback") || "Jogging started",
    stopJogFeedback: localStorage.getItem("stopJogFeedback") || "Jogging stopped",
    addEntryFeedback: localStorage.getItem("addEntryFeedback") || "Entry added",
    logExerciseFeedback: localStorage.getItem("logExerciseFeedback") || "Exercise logged",
    setActualRepsFeedback: localStorage.getItem("setActualRepsFeedback") || "Actual reps set to",
    navigationFeedback: localStorage.getItem("navigationFeedback") || "Navigated to"
  };
}

// Smart Exercise Logging with Activity Type Detection
function handleSmartExerciseLogging(exerciseName) {
  console.log('handleSmartExerciseLogging called with:', exerciseName);
  detectAndSetExerciseDataForVoice(exerciseName); // Voice command version
}

// Timer Duration Handler
function handleTimerForDuration(timeText) {
  const commands = getVoiceCommands();
  let seconds = 0;
  
  // Enhanced parsing for multiple time formats
  console.log('Parsing timer duration from:', timeText);
  
  // Parse hours, minutes, and seconds
  const hourMatch = timeText.match(/(\d+)\s*(?:hour[s]?|hr[s]?|h)/i);
  const minuteMatch = timeText.match(/(\d+)\s*(?:minute[s]?|min[s]?|m)/i);
  const secondMatch = timeText.match(/(\d+)\s*(?:second[s]?|sec[s]?|s)\b/i);
  
  if (hourMatch) {
    seconds += parseInt(hourMatch[1]) * 3600;
    console.log('Found hours:', hourMatch[1]);
  }
  if (minuteMatch) {
    seconds += parseInt(minuteMatch[1]) * 60;
    console.log('Found minutes:', minuteMatch[1]);
  }
  if (secondMatch) {
    seconds += parseInt(secondMatch[1]);
    console.log('Found seconds:', secondMatch[1]);
  }
  
  // Support common time formats like "1:30" (1 minute 30 seconds) or "2:00:00" (2 hours)
  if (seconds === 0) {
    const timeFormatMatch = timeText.match(/(\d+):(\d+)(?::(\d+))?/);
    if (timeFormatMatch) {
      if (timeFormatMatch[3]) {
        // HH:MM:SS format
        seconds = parseInt(timeFormatMatch[1]) * 3600 + parseInt(timeFormatMatch[2]) * 60 + parseInt(timeFormatMatch[3]);
        console.log('Parsed HH:MM:SS format:', timeFormatMatch[0]);
      } else {
        // MM:SS format
        seconds = parseInt(timeFormatMatch[1]) * 60 + parseInt(timeFormatMatch[2]);
        console.log('Parsed MM:SS format:', timeFormatMatch[0]);
      }
    }
  }
  
  // If no specific format, try to parse as just a number (assume seconds)
  if (seconds === 0) {
    const numberMatch = timeText.match(/(\d+)/);
    if (numberMatch) {
      seconds = parseInt(numberMatch[1]);
      console.log('Parsed as plain number (seconds):', numberMatch[1]);
    }
  }
  
  if (seconds > 0) {
    timerDuration = seconds * 1000; // Convert to milliseconds
    resetTimer();
    startTimer();
    
    // Set a timeout to stop the timer after the specified duration
    setTimeout(() => {
      if (timerInterval) {
        stopTimer();
        speakFeedback("Timer completed!");
      }
    }, timerDuration);
    
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const remainingSeconds = seconds % 60;
    let timeDescription = '';
    
    if (hours > 0) {
      timeDescription = `${hours} hour${hours > 1 ? 's' : ''}`;
      if (minutes > 0) {
        timeDescription += ` and ${minutes} minute${minutes > 1 ? 's' : ''}`;
      }
      if (remainingSeconds > 0) {
        timeDescription += ` and ${remainingSeconds} second${remainingSeconds > 1 ? 's' : ''}`;
      }
    } else if (minutes > 0) {
      timeDescription = `${minutes} minute${minutes > 1 ? 's' : ''}`;
      if (remainingSeconds > 0) {
        timeDescription += ` and ${remainingSeconds} second${remainingSeconds > 1 ? 's' : ''}`;
      }
    } else {
      timeDescription = `${seconds} second${seconds > 1 ? 's' : ''}`;
    }
    
    console.log('Timer set for:', timeDescription);
            speakFeedback(`${commands.timerSetFeedback} ${timeDescription}`, 'timerSetFor');
  } else {
    speakFeedback("Sorry, I couldn't understand the time duration. Please try again.");
  }
}

// Complex Task Management
function addComplexTaskCommand() {
  const container = document.getElementById('complexTasksContainer');
  const taskId = Date.now();
  
  const taskDiv = document.createElement('div');
  taskDiv.id = `complexTask_${taskId}`;
  taskDiv.className = 'complex-task-item';
  
  taskDiv.innerHTML = `
    <div style="margin-bottom: 15px;">
      <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #00796b;">Command Phrases (one per line):</label>
      <textarea id="taskCommand_${taskId}" placeholder="e.g., workout mode&#10;start workout&#10;begin training" style="width: 100%; height: 60px; padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-size: 1rem; resize: vertical;"></textarea>
      <small style="color: #666; font-style: italic;">You can set multiple voice commands that trigger the same task</small>
    </div>
    <div style="margin-bottom: 15px;">
      <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #00796b;">
        Actions (comma separated):
        <button onclick="showComplexTaskHelp()" style="background: #2196F3; color: white; border: none; border-radius: 50%; width: 20px; height: 20px; cursor: pointer; font-size: 12px; margin-left: 5px; display: inline-flex; align-items: center; justify-content: center;" title="Show available commands">i</button>
      </label>
      <textarea id="taskActions_${taskId}" placeholder="turn off dark mode, show progress view, start timer" style="width: 100%; height: 80px; resize: vertical; padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-family: inherit; font-size: 0.95rem;"></textarea>
      <small style="color: #666; font-style: italic;">Examples: "turn on dark mode", "show progress", "start timer", "set category to C.S.A"</small>
    </div>
    <div style="margin-bottom: 15px;">
      <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #00796b;">Voice Feedback:</label>
      <input type="text" id="taskFeedback_${taskId}" placeholder="Workout mode activated!" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-size: 1rem;">
    </div>
    <div style="text-align: right; display: flex; gap: 10px; justify-content: flex-end;">
      <button onclick="saveComplexTask(${taskId})" style="background: linear-gradient(135deg, #4CAF50, #45a049); color: white; padding: 8px 16px; border: none; border-radius: 20px; cursor: pointer; font-weight: 600; transition: all 0.3s ease;">üíæ Save Task</button>
      <button onclick="removeComplexTask(${taskId})" style="background: linear-gradient(135deg, #f44336, #d32f2f); color: white; padding: 8px 16px; border: none; border-radius: 20px; cursor: pointer; font-weight: 600; transition: all 0.3s ease;">Remove Task</button>
    </div>
  `;
  
  container.appendChild(taskDiv);
}

function saveComplexTask(taskId) {
  const commandField = document.getElementById(`taskCommand_${taskId}`);
  const actionsField = document.getElementById(`taskActions_${taskId}`);
  const feedbackField = document.getElementById(`taskFeedback_${taskId}`);
  
  if (!commandField || !actionsField || !feedbackField) {
    alert('Error: Cannot find task fields');
    return;
  }
  
  const commands = commandField.value.trim().split('\n').filter(cmd => cmd.trim());
  const actions = actionsField.value.trim();
  const feedback = feedbackField.value.trim();
  
  if (!commands.length || !actions) {
    alert('Please fill in command phrases and actions');
    return;
  }
  
  // Find existing task or create new one
  let taskIndex = complexTasks.findIndex(task => task.id === taskId);
  const taskData = {
    id: taskId,
    commands: commands,
    actions: actions, // Keep as string for consistency
    feedback: feedback || 'Task completed'
  };
  
  if (taskIndex >= 0) {
    complexTasks[taskIndex] = taskData;
  } else {
    complexTasks.push(taskData);
  }
  
  localStorage.setItem('complexTasks', JSON.stringify(complexTasks));
  updateComplexTasksDisplay();
  
  // Remove the task input form after saving
  const taskDiv = document.getElementById(`complexTask_${taskId}`);
  if (taskDiv) {
    taskDiv.remove();
  }
  
  // Provide immediate user feedback
  const notification = document.createElement('div');
  notification.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #4CAF50; color: white; padding: 15px 20px; border-radius: 8px; z-index: 10000; box-shadow: 0 4px 12px rgba(0,0,0,0.3);';
  notification.textContent = 'Complex task saved successfully!';
  document.body.appendChild(notification);
  
  setTimeout(() => {
    if (notification.parentNode) {
      notification.parentNode.removeChild(notification);
    }
  }, 3000);
  
  speakFeedback('Complex task saved successfully');
}

function removeComplexTask(taskId) {
  const taskDiv = document.getElementById(`complexTask_${taskId}`);
  if (taskDiv) {
    taskDiv.remove();
  }
  
  // Remove from saved complex tasks
  complexTasks = complexTasks.filter(task => task.id !== taskId);
  localStorage.setItem('complexTasks', JSON.stringify(complexTasks));
  updateComplexTasksDisplay();
}

function showComplexTaskHelp() {
  // Check if dark mode is active for dynamic colors
  const isDarkMode = document.body.classList.contains('dark-mode');
  const primaryColor = isDarkMode ? '#4db6ac' : '#00796b';
  const secondaryColor = isDarkMode ? '#80cbc4' : '#004d40';
  const tipBgColor = isDarkMode ? 'rgba(76, 175, 80, 0.2)' : '#e8f5e8';
  const tipTextColor = isDarkMode ? '#a5d6a7' : '#2e7d32';
  const tipBorderColor = isDarkMode ? '#66bb6a' : '#4CAF50';
  
  const helpContent = '<h3 style="margin-top: 0; color: ' + primaryColor + ';">üìã Available Commands for Complex Tasks</h3>' +
'<div style="margin-bottom: 20px;">' +
'  <h4 style="color: ' + secondaryColor + '; margin-bottom: 10px;">üéõÔ∏è Interface Controls:</h4>' +
'  <ul style="line-height: 1.6; margin: 0; padding-left: 20px;">' +
'    <li><strong>Dark Mode:</strong> "turn on dark mode", "turn off dark mode", "toggle dark mode"</li>' +
'    <li><strong>Settings:</strong> "show settings", "open settings", "hide settings"</li>' +
'    <li><strong>Categories:</strong> "set category to C.S.A", "set category to C.P.E", "set category to CA.P", "set category to L.B.S"</li>' +
'  </ul>' +
'</div>' +
'<div style="margin-bottom: 20px;">' +
'  <h4 style="color: ' + secondaryColor + '; margin-bottom: 10px;">üìä Views & Navigation:</h4>' +
'  <ul style="line-height: 1.6; margin: 0; padding-left: 20px;">' +
'    <li><strong>Views:</strong> "show progress", "show archive", "show mastered", "show ideals", "show streak"</li>' +
'    <li><strong>Filters:</strong> "filter entries to all", "filter entries to reps", "filter entries to iso", "filter entries to semi", "filter entries to jog"</li>' +
'    <li><strong>Homepage:</strong> "go to homepage", "show homepage", "hide all views"</li>' +
'  </ul>' +
'</div>' +
'<div style="margin-bottom: 20px;">' +
'  <h4 style="color: ' + secondaryColor + '; margin-bottom: 10px;">‚è±Ô∏è Timer Controls:</h4>' +
'  <ul style="line-height: 1.6; margin: 0; padding-left: 20px;">' +
'    <li><strong>Basic:</strong> "start timer", "stop timer", "reset timer"</li>' +
'    <li><strong>Set Timer:</strong> "set timer for 30 seconds", "set timer for 2 minutes"</li>' +
'  </ul>' +
'</div>' +
'<div style="margin-bottom: 20px;">' +
'  <h4 style="color: ' + secondaryColor + '; margin-bottom: 10px;">üèÉ Activity Controls:</h4>' +
'  <ul style="line-height: 1.6; margin: 0; padding-left: 20px;">' +
'    <li><strong>Activity Type:</strong> "set activity type to reps", "set activity type to iso", "set activity type to semi", "set activity type to jog"</li>' +
'    <li><strong>Jogging:</strong> "start jogging", "stop jogging"</li>' +
'  </ul>' +
'</div>' +
'<div style="margin-bottom: 20px;">' +
'  <h4 style="color: ' + secondaryColor + '; margin-bottom: 10px;">üìù Data Entry:</h4>' +
'  <ul style="line-height: 1.6; margin: 0; padding-left: 20px;">' +
'    <li><strong>Exercise:</strong> "set exercise name to push ups", "set exercise name to squats"</li>' +
'    <li><strong>Actual Values:</strong> "set actual value to 20"</li>' +
'    <li><strong>Ideal Values (Single):</strong> "set ideal value to 25" (for reps, iso, jog)</li>' +
'    <li><strong>Ideal Values (Semi):</strong> "set ideal time to 60", "set ideal reps to 15"</li>' +
'    <li><strong>Ideal Values (Auto):</strong> "set ideal values to 60 and 15" (detects activity type)</li>' +
'    <li><strong>Add Entry:</strong> "add entry", "save entry", "log exercise"</li>' +
'  </ul>' +
'</div>' +
'<div style="background: ' + tipBgColor + '; padding: 15px; border-radius: 8px; border-left: 4px solid ' + tipBorderColor + ';">' +
'  <h4 style="color: ' + tipTextColor + '; margin-top: 0;">üí° Pro Tips:</h4>' +
'  <ul style="line-height: 1.6; margin: 0; padding-left: 20px;">' +
'    <li>Commands are case-insensitive</li>' +
'    <li>You can combine multiple actions with commas</li>' +
'    <li>Actions execute in sequence with small delays</li>' +
'    <li>Use specific values: numbers for reps/time, exact category names</li>' +
'  </ul>' +
'</div>';
  
  // Create modal
  const modal = document.createElement('div');
  modal.id = 'complexTaskHelpModal';
  modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 100000; display: flex; align-items: center; justify-content: center; padding: 20px;';
  
  const content = document.createElement('div');
  
  // Use the same dark mode variables from above
  const backgroundColor = isDarkMode ? '#1e1e1e' : 'white';
  const textColor = isDarkMode ? '#e0e0e0' : '#333';
  const shadowColor = isDarkMode ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.3)';
  
  content.style.cssText = 'background: ' + backgroundColor + '; color: ' + textColor + '; padding: 25px; border-radius: 15px; max-width: 600px; max-height: 80vh; overflow-y: auto; position: relative; box-shadow: 0 10px 30px ' + shadowColor + ';';
  
  content.innerHTML = helpContent + '<div style="text-align: center; margin-top: 20px;"><button onclick="closeComplexTaskHelp()" style="background: #00796b; color: white; padding: 12px 24px; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: 600;">Got it!</button></div>';
  
  modal.appendChild(content);
  document.body.appendChild(modal);
  
  // Close on click outside
  modal.addEventListener('click', (e) => {
    if (e.target === modal) closeComplexTaskHelp();
  });
}

function closeComplexTaskHelp() {
  const modal = document.getElementById('complexTaskHelpModal');
  if (modal) modal.remove();
}
function executeComplexTask(task) {
  if (!task.actions || (Array.isArray(task.actions) ? task.actions.length === 0 : !task.actions.trim())) {
    console.warn('No actions to execute in complex task');
    return false;
  }
  
  // Handle both string and array formats for actions
  const actions = Array.isArray(task.actions) 
    ? task.actions.map(action => action.toLowerCase().trim())
    : task.actions.toLowerCase().split(',').map(action => action.trim());
  
  let executedActions = [];
  let failedActions = [];
  
  console.log('Executing complex task:', task.name || 'Unnamed', 'Actions:', actions);
  
  actions.forEach((action, index) => {
    setTimeout(() => {
      try {
        let actionExecuted = false;
        
        // Dark mode controls
        if (action.includes('dark mode')) {
          const toggle = document.getElementById('darkModeToggle');
          if (toggle) {
            if (action.includes('turn on') || action.includes('enable')) {
              toggle.checked = true;
              toggleDarkMode();
              executedActions.push('enabled dark mode');
              actionExecuted = true;
            } else if (action.includes('turn off') || action.includes('disable')) {
              toggle.checked = false;
              toggleDarkMode();
              executedActions.push('disabled dark mode');
              actionExecuted = true;
            } else if (action.includes('toggle')) {
              toggle.click();
              executedActions.push('toggled dark mode');
              actionExecuted = true;
            }
          }
        }
        
        // Navigation commands
        else if (action.includes('show progress') || action.includes('progress view')) {
          showProgressView();
          executedActions.push('opened progress view');
          actionExecuted = true;
        } else if (action.includes('show archive') || action.includes('archive view')) {
          showArchiveView();
          executedActions.push('opened archive view');
          actionExecuted = true;
        } else if (action.includes('show ideals') || action.includes('ideals view')) {
          showIdealsPage();
          executedActions.push('opened ideals view');
          actionExecuted = true;
        } else if (action.includes('show mastered') || action.includes('mastered view')) {
          showMasteredView();
          executedActions.push('opened mastered view');
          actionExecuted = true;
        } else if (action.includes('show streak') || action.includes('streak view')) {
          showStreakTracker();
          executedActions.push('opened streak tracker');
          actionExecuted = true;
        } else if (action.includes('show settings') || action.includes('settings view') || action.includes('open settings')) {
          showSettingsView();
          executedActions.push('opened settings');
          actionExecuted = true;
        } else if (action.includes('show homepage') || action.includes('homepage') || action.includes('home')) {
          hideAllViews();
          executedActions.push('returned to homepage');
          actionExecuted = true;
        }
        
        // Timer controls
        else if (action.includes('start timer')) {
          startTimer();
          executedActions.push('started timer');
          actionExecuted = true;
        } else if (action.includes('stop timer')) {
          stopTimer();
          executedActions.push('stopped timer');
          actionExecuted = true;
        } else if (action.includes('reset timer')) {
          resetTimer();
          executedActions.push('reset timer');
          actionExecuted = true;
        } else if (action.includes('set timer for')) {
          const timeMatch = action.match(/(\d+)\s*(second|minute|hour)s?/);
          if (timeMatch) {
            const value = parseInt(timeMatch[1]);
            const unit = timeMatch[2];
            let seconds = value;
            if (unit === 'minute') seconds *= 60;
            if (unit === 'hour') seconds *= 3600;
            
            setTimerFor(seconds);
            executedActions.push(`set timer for ${value} ${unit}${value > 1 ? 's' : ''}`);
            actionExecuted = true;
          }
        }
        
        // Activity controls
        else if (action.includes('start jogging') || action.includes('start jog')) {
          startJogging();
          executedActions.push('started jogging');
          actionExecuted = true;
        } else if (action.includes('stop jogging') || action.includes('stop jog')) {
          stopJogging();
          executedActions.push('stopped jogging');
          actionExecuted = true;
        }
        
        // Activity type setting
        else if (action.includes('set activity type to') || action.includes('activity type')) {
          const types = ['reps', 'iso', 'semi', 'jog'];
          types.forEach(type => {
            if (action.includes(type)) {
              document.getElementById('type').value = type;
              renderFields();
              executedActions.push(`set activity type to ${type}`);
              actionExecuted = true;
            }
          });
        }
        
        // Category setting
        else if (action.includes('set category to') || action.includes('category')) {
          const categories = ['c.s.a', 'c.p.e', 'ca.p', 'l.b.s'];
          categories.forEach(cat => {
            if (action.includes(cat)) {
              setCategory(cat.toUpperCase());
              executedActions.push(`set category to ${cat.toUpperCase()}`);
              actionExecuted = true;
            }
          });
        }
        
        // Exercise name setting
        else if (action.includes('set exercise name to')) {
          const nameMatch = action.match(/set exercise name to (.+)/);
          if (nameMatch) {
            const exerciseName = nameMatch[1].trim();
            const nameField = document.getElementById('exerciseName');
            if (nameField) {
              nameField.value = exerciseName;
              executedActions.push(`set exercise name to ${exerciseName}`);
              actionExecuted = true;
            }
          }
        }
        
        // Value setting
        else if (action.includes('set actual value to')) {
          const valueMatch = action.match(/set actual value to (\d+)/);
          if (valueMatch) {
            const value = valueMatch[1];
            const actualField = document.getElementById('actualValue');
            if (actualField) {
              actualField.value = value;
              executedActions.push(`set actual value to ${value}`);
              actionExecuted = true;
            }
          }
        } else if (action.includes('set ideal value to')) {
          const valueMatch = action.match(/set ideal value to (\d+)/);
          if (valueMatch) {
            const value = valueMatch[1];
            const idealField = document.getElementById('idealValue');
            if (idealField) {
              idealField.value = value;
              executedActions.push(`set ideal value to ${value}`);
              actionExecuted = true;
            }
          }
        }
        
        // Semi-isometric specific ideal values
        else if (action.includes('set ideal time to')) {
          const valueMatch = action.match(/set ideal time to (\d+)/);
          if (valueMatch) {
            const value = valueMatch[1];
            const idealTimeField = document.getElementById('idealTime');
            if (idealTimeField) {
              idealTimeField.value = value;
              executedActions.push(`set ideal time to ${value} seconds`);
              actionExecuted = true;
            }
          }
        } else if (action.includes('set ideal reps to')) {
          const valueMatch = action.match(/set ideal reps to (\d+)/);
          if (valueMatch) {
            const value = valueMatch[1];
            const idealRepsField = document.getElementById('idealReps');
            if (idealRepsField) {
              idealRepsField.value = value;
              executedActions.push(`set ideal reps to ${value}`);
              actionExecuted = true;
            }
          }
        }
        
        // Comprehensive ideal value setting (automatically detects activity type)
        else if (action.includes('set ideal values to')) {
          const valuesMatch = action.match(/set ideal values to (\d+)(?:\s*and\s*(\d+))?/);
          if (valuesMatch) {
            const value1 = valuesMatch[1];
            const value2 = valuesMatch[2];
            
            // Check current activity type to determine which fields to fill
            const typeField = document.getElementById('type');
            const activityType = typeField ? typeField.value : null;
            
            if (activityType === 'semi') {
              // Semi-isometric: first value = time, second value = reps
              const idealTimeField = document.getElementById('idealTime');
              const idealRepsField = document.getElementById('idealReps');
              
              if (idealTimeField && value1) {
                idealTimeField.value = value1;
                executedActions.push(`set ideal time to ${value1} seconds`);
              }
              if (idealRepsField && value2) {
                idealRepsField.value = value2;
                executedActions.push(`set ideal reps to ${value2}`);
              }
              actionExecuted = true;
            } else {
              // Single ideal value types (reps, iso, jog uses different fields)
              const idealField = document.getElementById('idealValue');
              if (idealField && value1) {
                idealField.value = value1;
                executedActions.push(`set ideal value to ${value1}`);
                actionExecuted = true;
              }
            }
          }
        }
        
        // Entry management
        else if (action.includes('add entry') || action.includes('save entry') || action.includes('log exercise')) {
          const addBtn = document.getElementById('addEntry');
          if (addBtn) {
            addBtn.click();
            executedActions.push('added entry');
            actionExecuted = true;
          }
        }
        
        // Filter controls
        else if (action.includes('filter entries to')) {
          const filterMatch = action.match(/filter entries to (\w+)/);
          if (filterMatch) {
            const filterType = filterMatch[1];
            filterEntries(filterType);
            executedActions.push(`filtered entries to ${filterType}`);
            actionExecuted = true;
          }
        }
        
        if (!actionExecuted) {
          console.warn(`Unknown complex task action: ${action}`);
          failedActions.push(action);
        }
        
      } catch (error) {
        console.error(`Error executing complex task action "${action}":`, error);
        failedActions.push(action);
      }
      
      // If this is the last action, provide feedback
      if (index === actions.length - 1) {
        setTimeout(() => {
          if (task.feedback && task.feedback.trim()) {
            speakFeedback(task.feedback);
          } else if (executedActions.length > 0) {
            const summary = `Complex task completed. ${executedActions.length} actions succeeded.`;
            speakFeedback(summary);
          } else {
            speakFeedback('Complex task completed, but no actions were executed.');
          }
          
          if (failedActions.length > 0) {
            console.warn('Failed actions:', failedActions);
          }
        }, 100);
      }
    }, index * 300); // 300ms delay between actions
  });
  
  return true;
}

function saveVoiceSettings() {
  // Save command triggers
  localStorage.setItem("startTimerCommand", document.getElementById("startTimerCommand").value.trim().toLowerCase());
  localStorage.setItem("stopTimerCommand", document.getElementById("stopTimerCommand").value.trim().toLowerCase());
  localStorage.setItem("resetTimerCommand", document.getElementById("resetTimerCommand").value.trim().toLowerCase());
  localStorage.setItem("startTimerForCommand", document.getElementById("startTimerForCommand").value.trim().toLowerCase());
  localStorage.setItem("startJogCommand", document.getElementById("startJogCommand").value.trim().toLowerCase());
  localStorage.setItem("stopJogCommand", document.getElementById("stopJogCommand").value.trim().toLowerCase());
  localStorage.setItem("addEntryCommand", document.getElementById("addEntryCommand").value.trim().toLowerCase());
  localStorage.setItem("logExerciseCommand", document.getElementById("logExerciseCommand").value.trim().toLowerCase());
  localStorage.setItem("setActualRepsCommand", document.getElementById("setActualRepsCommand").value.trim().toLowerCase());
  
  // Save navigation commands
  localStorage.setItem("showProgressCommand", document.getElementById("showProgressCommand").value.trim().toLowerCase());
  localStorage.setItem("showArchiveCommand", document.getElementById("showArchiveCommand").value.trim().toLowerCase());
  localStorage.setItem("openSettingsCommand", document.getElementById("openSettingsCommand").value.trim().toLowerCase());
  localStorage.setItem("goHomeCommand", document.getElementById("goHomeCommand").value.trim().toLowerCase());
  
  // Save complex tasks
  saveComplexTasks();
  
  // Save feedback messages
  localStorage.setItem("startTimerFeedback", document.getElementById("startTimerFeedback").value.trim());
  localStorage.setItem("stopTimerFeedback", document.getElementById("stopTimerFeedback").value.trim());
  localStorage.setItem("resetTimerFeedback", document.getElementById("resetTimerFeedback").value.trim());
  localStorage.setItem("timerSetFeedback", document.getElementById("timerSetFeedback").value.trim());
  localStorage.setItem("startJogFeedback", document.getElementById("startJogFeedback").value.trim());
  localStorage.setItem("stopJogFeedback", document.getElementById("stopJogFeedback").value.trim());
  localStorage.setItem("addEntryFeedback", document.getElementById("addEntryFeedback").value.trim());
  localStorage.setItem("logExerciseFeedback", document.getElementById("logExerciseFeedback").value.trim());
  localStorage.setItem("setActualRepsFeedback", document.getElementById("setActualRepsFeedback").value.trim());
  localStorage.setItem("navigationFeedback", document.getElementById("navigationFeedback").value.trim());
  
  alert("Voice settings saved!");
  updateComplexTasksDisplay();
}

function saveComplexTasks() {
  const container = document.getElementById('complexTasksContainer');
  const taskDivs = container.querySelectorAll('[id^="complexTask_"]');
  
  complexTasks = [];
  taskDivs.forEach(div => {
    const taskId = div.id.split('_')[1];
    const commandText = document.getElementById(`taskCommand_${taskId}`).value.trim();
    const actions = document.getElementById(`taskActions_${taskId}`).value.trim();
    const feedback = document.getElementById(`taskFeedback_${taskId}`).value.trim();
    
    if (commandText && actions) {
      // Parse multiple commands (one per line)
      const commands = commandText.split('\n')
        .map(cmd => cmd.trim().toLowerCase())
        .filter(cmd => cmd.length > 0);
      
      if (commands.length > 0) {
        complexTasks.push({
          id: parseInt(taskId),
          commands: commands, // Array of commands instead of single command
          primaryCommand: commands[0], // For display purposes
          actions,
          feedback
        });
      }
    }
  });
  
  localStorage.setItem('complexTasks', JSON.stringify(complexTasks));
}

// Automation Recording Functions
function showAutomationRecorder() {
  document.getElementById('automationRecorderModal').style.display = 'block';
  initializeAutomationRecorder();
}

function initializeAutomationRecorder() {
  // Reset recording state
  isRecording = false;
  recordedActions = [];
  recordingStartTime = null;
  lastActionTime = null;
  currentRecordingMode = 'timestamp';
  
  // Load the actual Performa app in iframe
  loadFullPerformaApp();
  
  // Initialize recording mode toggle
  updateRecordingModeInfo();
  
  // Reset UI elements
  updateActionCount();
  resetAutomationButtons();
  
  console.log('Automation recorder initialized with iframe');
}

function loadFullPerformaApp() {
  const iframe = document.getElementById('performaAppIframe');
  const overlay = document.getElementById('loadingOverlay');
  
  // Show loading
  overlay.style.display = 'flex';
  
  // Get current page URL and load it in iframe
  const currentUrl = window.location.href;
  iframe.src = currentUrl;
  
  console.log('Loading full Performa app in iframe:', currentUrl);
}

// Old function removed - now using real iframe integration

function resetAutomationButtons() {
  document.getElementById('saveAutomationBtn').disabled = true;
  document.getElementById('saveAutomationBtn').style.opacity = '0.6';
}

// Automation recording variables
let recordingStartTime = null;
let lastActionTime = null;
let recordingTimer = null;
let currentRecordingMode = 'timestamp';

// iframe load handler
function onIframeLoad() {
  const iframe = document.getElementById('performaAppIframe');
  const overlay = document.getElementById('loadingOverlay');
  
  console.log('iframe loaded');
  
  // Hide loading overlay
  overlay.style.display = 'none';
  
  // Set up iframe message communication
  setupIframeRecording();
}

// Recording mode toggle functionality
function setRecordingMode(mode) {
  currentRecordingMode = mode;
  updateRecordingModeToggle();
  updateRecordingModeInfo();
}

function updateRecordingModeToggle() {
  const timestampBtn = document.getElementById('timestampModeBtn');
  const sequenceBtn = document.getElementById('sequenceModeBtn');
  
  if (currentRecordingMode === 'timestamp') {
    timestampBtn.style.background = 'rgba(255,255,255,0.9)';
    timestampBtn.style.color = '#333';
    sequenceBtn.style.background = 'transparent';
    sequenceBtn.style.color = 'rgba(255,255,255,0.8)';
  } else {
    timestampBtn.style.background = 'transparent';
    timestampBtn.style.color = 'rgba(255,255,255,0.8)';
    sequenceBtn.style.background = 'rgba(255,255,255,0.9)';
    sequenceBtn.style.color = '#333';
  }
}

function updateRecordingModeInfo() {
  // Recording mode info UI removed for mobile optimization
}

// iframe message communication
let automationMessageListener = null;
let iframeRecordingSetup = false;

function setupIframeRecording() {
  const iframe = document.getElementById('performaAppIframe');
  
  // Remove any existing message listener to prevent duplicates
  if (automationMessageListener) {
    window.removeEventListener('message', automationMessageListener);
    console.log('Removed existing automation message listener');
  }
  
  // Create new message listener function
  automationMessageListener = function(event) {
    // Only accept messages from our iframe
    if (event.source !== iframe.contentWindow) return;
    
    if (event.data.type === 'automation-action' && isRecording) {
      handleRecordedAction(event.data.action);
    }
  };
  
  // Add the new listener
  window.addEventListener('message', automationMessageListener);
  console.log('Added automation message listener');
  
  // Always inject recording script to ensure latest version (force refresh)
  injectRecordingScript();
  iframeRecordingSetup = true;
  console.log('Injected/refreshed recording script into iframe');
}
function injectRecordingScript() {
  const iframe = document.getElementById('performaAppIframe');
  
  try {
    const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
    const script = iframeDoc.createElement('script');
    
    script.textContent = `
      // Automation recording functionality injected into iframe
      let automationRecordingActive = false;
      let automationEventListeners = [];
      let lastRecordedAction = null;
      let actionDebounceTimeout = null;
      
              function startAutomationRecording() {
          automationRecordingActive = true;
          lastRecordedAction = null; // Reset tracking
          console.log('Started automation recording in iframe');
          attachAutomationListeners();
        }
      
      function stopAutomationRecording() {
        automationRecordingActive = false;
        console.log('Stopped automation recording in iframe');
        removeAutomationListeners();
      }
      
      function attachAutomationListeners() {
        // Track clicks on all interactive elements
        document.addEventListener('click', handleAutomationClick, true);
        document.addEventListener('input', handleAutomationInput, true);
        document.addEventListener('change', handleAutomationChange, true);
      }
      
      function removeAutomationListeners() {
        document.removeEventListener('click', handleAutomationClick, true);
        document.removeEventListener('input', handleAutomationInput, true);
        document.removeEventListener('change', handleAutomationChange, true);
      }
      
      function getElementIdentifier(element) {
        if (element.id) return '#' + element.id;
        if (element.className) return '.' + element.className.split(' ')[0];
        return element.tagName.toLowerCase();
      }
      
      function getElementLabel(element) {
        if (element.textContent && element.textContent.trim()) {
          return element.textContent.trim().substring(0, 50);
        }
        if (element.placeholder) return element.placeholder;
        if (element.value && element.type !== 'password') return element.value;
        if (element.title) return element.title;
        return element.tagName.toLowerCase();
      }
      
      function handleAutomationClick(event) {
        if (!automationRecordingActive) return;
        
        const element = event.target;
        
        // Skip non-meaningful clicks
        if (!isClickWorthRecording(element, event)) {
          console.log('Skipped click on:', element, 'Reason: Not worth recording');
          return;
        }
        
        // Detect timer actions by checking onclick attribute
        const onclick = element.getAttribute('onclick') || '';
        let actionType = 'click';
        let actionValue = '';
        
        if (onclick.includes('startTimer()')) {
          actionType = 'startTimer';
          actionValue = 'start';
          console.log('Iframe detected startTimer action');
        } else if (onclick.includes('stopTimer()')) {
          actionType = 'stopTimer';
          actionValue = 'stop';
          console.log('Iframe detected stopTimer action');
        } else if (onclick.includes('resetTimer()')) {
          actionType = 'resetTimer';
          actionValue = 'reset';
          console.log('Iframe detected resetTimer action');
        }
        
        const action = {
          type: 'click',
          action: actionType,
          target: getElementIdentifier(element),
          label: getElementLabel(element),
          value: actionValue,
          timestamp: Date.now()
        };
        
        // Check for duplicate or too rapid actions
        if (shouldRecordAction(action)) {
          console.log('Recording action:', action);
          // Send to parent window
          window.parent.postMessage({
            type: 'automation-action',
            action: action
          }, '*');
          
          // Store as last recorded action
          lastRecordedAction = action;
        } else {
          console.log('Skipped duplicate/rapid action:', action);
        }
      }
      
      function isClickWorthRecording(element, event) {
        // Skip if element or event is invalid
        if (!element || !event) return false;
        
        // Skip scroll-related clicks (mousedown/mouseup without actual interaction)
        if (event.detail === 0) return false; // Detail is 0 for programmatic clicks
        
        // Skip clicks on document, body, or non-interactive elements
        const tagName = element.tagName.toLowerCase();
        const nonInteractiveTags = ['html', 'body', 'div', 'span', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'];
        
        // Allow clicks only if element has clear interactive purpose
        const isInteractiveTag = ['button', 'a', 'input', 'select', 'textarea', 'label'].includes(tagName);
        const hasClickHandler = element.onclick || element.getAttribute('onclick');
        const hasRole = element.getAttribute('role');
        const isClickable = element.style.cursor === 'pointer' || getComputedStyle(element).cursor === 'pointer';
        const hasInteractiveClass = element.className && (
          element.className.includes('btn') || 
          element.className.includes('button') || 
          element.className.includes('clickable') ||
          element.className.includes('link') ||
          element.className.includes('tab') ||
          element.className.includes('toggle') ||
          // Performa app specific classes
          element.className.includes('cat-btn') ||
          element.className.includes('settings-btn') ||
          element.className.includes('jog-btn') ||
          element.className.includes('filter-btn') ||
          element.className.includes('chart-type-btn') ||
          element.className.includes('save-btn') ||
          element.className.includes('edit-btn') ||
          element.className.includes('delete-btn') ||
          element.className.includes('view-back-btn') ||
          element.className.includes('timer') ||
          element.className.includes('close-btn') ||
          element.className.includes('cancel-btn') ||
          element.className.includes('confirm-btn')
        );
        
        // Skip purely layout/scroll elements
        if (nonInteractiveTags.includes(tagName) && !hasClickHandler && !hasRole && !isClickable && !hasInteractiveClass) {
          return false;
        }
        
        // Skip if element has no meaningful content or identifier
        const hasId = element.id && element.id.trim();
        const hasClass = element.className && element.className.trim();
        const hasText = element.textContent && element.textContent.trim();
        const hasValue = element.value && element.value.trim();
        
        // Check for Performa app specific IDs that are always meaningful
        const hasImportantId = hasId && (
          element.id.includes('btn') || 
          element.id.includes('Button') ||
          element.id.includes('timer') ||
          element.id.includes('scorePanel') ||
          element.id.includes('addEntry') ||
          element.id.includes('cancel') ||
          element.id.includes('save') ||
          element.id.includes('Edit') ||
          element.id.includes('start') ||
          element.id.includes('stop')
        );
        
        if (!hasId && !hasClass && !hasText && !hasValue && !isInteractiveTag && !hasImportantId) {
          return false;
        }
        
        // Skip very small elements that are likely decorative
        const rect = element.getBoundingClientRect();
        if (rect.width < 10 || rect.height < 10) {
          return false;
        }
        
        // Skip hidden or invisible elements
        const style = getComputedStyle(element);
        if (style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0') {
          return false;
        }
        
        // Allow the click if any interactive indicator is present
        return isInteractiveTag || hasClickHandler || hasRole || isClickable || hasInteractiveClass;
      }
      
      function handleAutomationInput(event) {
        if (!automationRecordingActive) return;
        
        const element = event.target;
        
        // Skip non-meaningful input events
        if (!isInputWorthRecording(element, event)) {
          return;
        }
        
        const action = {
          type: 'input',
          target: getElementIdentifier(element),
          label: getElementLabel(element),
          value: element.type === 'password' ? '[PASSWORD]' : element.value,
          timestamp: Date.now()
        };
        
        // Check for duplicate or too rapid actions
        if (shouldRecordAction(action)) {
          window.parent.postMessage({
            type: 'automation-action',
            action: action
          }, '*');
          
          // Store as last recorded action
          lastRecordedAction = action;
        }
      }
      
      function isInputWorthRecording(element, event) {
        // Only record input events for actual form inputs
        const tagName = element.tagName.toLowerCase();
        const inputTypes = ['input', 'textarea', 'select'];
        
        if (!inputTypes.includes(tagName)) {
          return false;
        }
        
        // Skip if input is readonly, disabled, or hidden
        if (element.readOnly || element.disabled || element.type === 'hidden') {
          return false;
        }
        
        // Skip empty values unless it's a deliberate clear
        const value = element.value;
        if (!value || value.trim() === '') {
          return false;
        }
        
        // Skip if value hasn't meaningfully changed (debounce rapid typing)
        const lastRecordedValue = element.getAttribute('data-last-recorded-value');
        if (lastRecordedValue === value) {
          return false;
        }
        
        // Store the current value for next comparison
        element.setAttribute('data-last-recorded-value', value);
        
        return true;
      }
      
      function handleAutomationChange(event) {
        if (!automationRecordingActive) return;
        
        const element = event.target;
        
        // Skip non-meaningful change events
        if (!isChangeWorthRecording(element, event)) {
          return;
        }
        
        const action = {
          type: 'change',
          target: getElementIdentifier(element),
          label: getElementLabel(element),
          value: element.value,
          timestamp: Date.now()
        };
        
        // Check for duplicate or too rapid actions
        if (shouldRecordAction(action)) {
          window.parent.postMessage({
            type: 'automation-action',
            action: action
          }, '*');
          
          // Store as last recorded action
          lastRecordedAction = action;
        }
      }
      
      function isChangeWorthRecording(element, event) {
        // Only record change events for form elements
        const tagName = element.tagName.toLowerCase();
        const changeableTypes = ['select', 'input', 'textarea'];
        
        if (!changeableTypes.includes(tagName)) {
          return false;
        }
        
        // Skip if element is disabled or readonly
        if (element.disabled || element.readOnly) {
          return false;
        }
        
        // For select elements, always record changes as they're deliberate
        if (tagName === 'select') {
          return true;
        }
        
        // For input elements, check if it's a meaningful change
        if (tagName === 'input') {
          const type = element.type.toLowerCase();
          
          // Always record checkbox, radio, and file changes
          if (['checkbox', 'radio', 'file'].includes(type)) {
            return true;
          }
          
          // For text inputs, only record if there's a meaningful value
          const value = element.value;
          return value && value.trim().length > 0;
        }
        
        // For textarea, record if there's content
        if (tagName === 'textarea') {
          const value = element.value;
          return value && value.trim().length > 0;
        }
        
        return false;
      }
      
      function shouldRecordAction(action) {
        // Skip if no last action to compare
        if (!lastRecordedAction) {
          return true;
        }
        
        // Skip duplicate actions (same target and type)
        if (lastRecordedAction.target === action.target && lastRecordedAction.type === action.type) {
          // For clicks, allow if more than 500ms have passed
          if (action.type === 'click') {
            const timeDiff = action.timestamp - lastRecordedAction.timestamp;
            return timeDiff > 500;
          }
          
          // For input events, check if value actually changed
          if (action.type === 'input' || action.type === 'change') {
            return lastRecordedAction.value !== action.value;
          }
        }
        
        // Check for rapid successive actions on different elements (might be scroll/navigation)
        const timeDiff = action.timestamp - lastRecordedAction.timestamp;
        if (timeDiff < 100 && action.type === 'click') {
          return false; // Skip very rapid clicks as they're likely scrolling
        }
        
        return true;
      }
      
      // Listen for commands from parent
      window.addEventListener('message', function(event) {
        if (event.data.command === 'start-recording') {
          startAutomationRecording();
        } else if (event.data.command === 'stop-recording') {
          stopAutomationRecording();
        }
      });
    `;
    
    iframeDoc.head.appendChild(script);
    console.log('Automation recording script injected into iframe');
    
  } catch (error) {
    console.warn('Could not inject recording script (cross-origin):', error);
    document.getElementById('iframeStatus').textContent = '‚ö†Ô∏è Limited recording (cross-origin)';
  }
}

function handleRecordedAction(action) {
  const currentTime = Date.now();
  

  
  // Prevent duplicate actions within a short time window (500ms)
  const lastAction = recordedActions[recordedActions.length - 1];
  if (lastAction && 
      lastAction.type === action.type && 
      lastAction.target === action.target && 
      (currentTime - lastAction.timestamp) < 500) {

    return;
  }
  
  // Calculate timing if in timestamp mode
  if (currentRecordingMode === 'timestamp') {
    if (lastActionTime) {
      action.timeSinceLastAction = currentTime - lastActionTime;
    } else {
      action.timeSinceLastAction = 0;
    }
  }
  
  // Add action to recorded sequence
  recordedActions.push(action);
  lastActionTime = currentTime;
  
  // Update UI
  updateActionCount();
  updateConnectionStatus();
  
  // Enable save button
  if (recordedActions.length > 0) {
    document.getElementById('saveAutomationBtn').disabled = false;
    document.getElementById('saveAutomationBtn').style.opacity = '1';
  }
  
  console.log('Recorded action:', action);
}

// Direct automation tracking (no iframe needed)
function setupAutomationTracking() {
  // Set up activity type change handler
  const activitySelect = document.getElementById('automationActivityType');
  if (activitySelect) {
    activitySelect.addEventListener('change', function() {
      updateDynamicFields(this.value);
    });
  }
  
  // Add click listeners to all trackable elements
  const trackableElements = document.querySelectorAll('.auto-trackable');
  trackableElements.forEach(element => {
    element.addEventListener('click', handleTrackedClick);
    if (element.tagName === 'INPUT' || element.tagName === 'SELECT') {
      element.addEventListener('change', handleTrackedChange);
      element.addEventListener('input', handleTrackedInput);
    }
  });
  
  // Add tracking to main form elements for real automation recording
  setupMainFormTracking();
  
  console.log('Automation tracking set up for', trackableElements.length, 'trackable elements + main form elements');
}

function setupMainFormTracking() {
  // Main form elements that should be tracked for automation
  const mainElements = [
    '#type', '#category', '#exerciseName', '#actualValue', '#idealValue', 
    '#addEntry', '#cancelEdit', '#darkModeToggle', '#voiceBtn',
    '.filter-btn', '.sidebar-btn', '.settings-btn',
    // Timer control buttons
    'button[onclick*="startTimer"]', 'button[onclick*="stopTimer"]', 'button[onclick*="resetTimer"]',
    // Navigation elements
    '#overlay', '#menuBtn', '.hamburger-btn',
    // Other important buttons
    '#saveIdeal', '.save-btn', '.edit-btn', '.delete-btn'
  ];
  
  mainElements.forEach(selector => {
    const elements = document.querySelectorAll(selector);
    elements.forEach(element => {
      // Remove existing automation listeners to avoid duplicates
      element.removeEventListener('click', trackMainElementClick);
      element.removeEventListener('change', trackMainElementChange);
      element.removeEventListener('input', trackMainElementInput);
      
      // Add automation tracking listeners
      element.addEventListener('click', trackMainElementClick);
      if (element.tagName === 'INPUT' || element.tagName === 'SELECT') {
        element.addEventListener('change', trackMainElementChange);
        if (element.type !== 'button' && element.type !== 'submit') {
          element.addEventListener('input', trackMainElementInput);
        }
      }
    });
  });
}

function trackMainElementClick(event) {
  if (!isRecording) return;
  

  
  const element = event.target;
  const elementType = element.tagName.toLowerCase();
  const onclick = element.getAttribute('onclick') || '';
  
  // Determine action based on element
  let actionType = 'click';
  let actionValue = '';
  
  // Timer actions - detect by onclick content
  if (onclick.includes('startTimer()')) {
    actionType = 'startTimer';
    actionValue = 'start';
    // showMobileDebug('üìù RECORDED STARTTIMER ACTION', 'success');
    // showMobileDebug(`üìù Button: ${element.textContent.trim()}`, 'info');
  } else if (onclick.includes('stopTimer()')) {
    actionType = 'stopTimer';
    actionValue = 'stop';
    console.log('Recorded stopTimer action');
  } else if (onclick.includes('resetTimer()')) {
    actionType = 'resetTimer';
    actionValue = 'reset';
    console.log('Recorded resetTimer action');
  }
  // Form actions
  else if (element.id === 'addEntry') {
    actionType = 'addEntry';
  } else if (element.classList.contains('filter-btn')) {
    actionType = 'filterEntries';
    actionValue = element.textContent.trim();
  } else if (element.classList.contains('sidebar-btn')) {
    actionType = 'navigation';
    actionValue = element.textContent.trim();
  }
  // Settings actions  
  else if (element.id === 'darkModeToggle') {
    actionType = 'toggleDarkMode';
    actionValue = element.checked ? 'on' : 'off';
  }
  // Navigation back to home (check multiple ways)
  else if (element.id === 'overlay' || 
           (element.classList && element.classList.contains('back-btn')) || 
           (element.classList && element.classList.contains('view-back-btn')) ||
           (element.onclick && element.onclick.toString().includes('hide') && element.onclick.toString().includes('View')) ||
           (element.textContent && element.textContent.includes('‚Üê Back'))) {
    actionType = 'goHome';
    actionValue = 'home';
  }
  // General button actions
  else if (elementType === 'button') {
    actionValue = element.textContent.trim();
  }
  

  
  recordAutomationAction({
    type: 'click',
    action: actionType,
    target: getElementSelector(element),
    label: getElementLabel(element),
    value: actionValue,
    elementId: element.id || null
  });
}

function trackMainElementChange(event) {
  if (!isRecording) return;
  
  const element = event.target;
  
  recordAutomationAction({
    type: 'change',
    action: 'setValue',
    target: getElementSelector(element),
    label: getElementLabel(element),
    value: element.value,
    elementId: element.id || null
  });
}

function trackMainElementInput(event) {
  if (!isRecording) return;
  
  const element = event.target;
  
  // Only record input for text fields, not on every keystroke
  clearTimeout(element._inputTimeout);
  element._inputTimeout = setTimeout(() => {
    recordAutomationAction({
      type: 'input',
      action: 'setValue',
      target: getElementSelector(element),
      label: getElementLabel(element),
      value: element.value,
      elementId: element.id || null
    });
  }, 500); // Wait 500ms after user stops typing
}

function updateDynamicFields(activityType) {
  const container = document.getElementById('automationDynamicFields');
  if (!container) return;
  
  container.innerHTML = '';
  
  if (activityType === 'reps') {
    container.innerHTML = `
      <label style="display: block; margin-bottom: 10px; font-size: 1rem; color: #333;">Actual reps:</label>
      <input type="number" id="automationRepsActual" class="auto-trackable" data-action="setActualReps" placeholder="Enter actual reps" style="display: block; margin-bottom: 15px; width: 100%; font-size: 1rem; padding: 8px; border: 1px solid #ccc; border-radius: 8px;">
      <label style="display: block; margin-bottom: 10px; font-size: 1rem; color: #333;">Ideal reps:</label>
      <input type="number" id="automationRepsIdeal" class="auto-trackable" data-action="setIdealReps" placeholder="Enter ideal reps" style="display: block; margin-bottom: 15px; width: 100%; font-size: 1rem; padding: 8px; border: 1px solid #ccc; border-radius: 8px;">
    `;
  } else if (activityType === 'iso') {
    container.innerHTML = `
      <label style="display: block; margin-bottom: 10px; font-size: 1rem; color: #333;">Actual time (seconds):</label>
      <input type="number" id="automationIsoActual" class="auto-trackable" data-action="setActualTime" placeholder="Enter actual time" style="display: block; margin-bottom: 15px; width: 100%; font-size: 1rem; padding: 8px; border: 1px solid #ccc; border-radius: 8px;">
      <label style="display: block; margin-bottom: 10px; font-size: 1rem; color: #333;">Ideal time (seconds):</label>
      <input type="number" id="automationIsoIdeal" class="auto-trackable" data-action="setIdealTime" placeholder="Enter ideal time" style="display: block; margin-bottom: 15px; width: 100%; font-size: 1rem; padding: 8px; border: 1px solid #ccc; border-radius: 8px;">
    `;
  } else if (activityType === 'semi') {
    container.innerHTML = `
      <label style="display: block; margin-bottom: 10px; font-size: 1rem; color: #333;">Actual time (seconds):</label>
      <input type="number" id="automationSemiActual" class="auto-trackable" data-action="setActualTime" placeholder="Enter actual time" style="display: block; margin-bottom: 15px; width: 100%; font-size: 1rem; padding: 8px; border: 1px solid #ccc; border-radius: 8px;">
      <label style="display: block; margin-bottom: 10px; font-size: 1rem; color: #333;">Ideal reps:</label>
      <input type="number" id="automationSemiIdeal" class="auto-trackable" data-action="setIdealReps" placeholder="Enter ideal reps" style="display: block; margin-bottom: 15px; width: 100%; font-size: 1rem; padding: 8px; border: 1px solid #ccc; border-radius: 8px;">
    `;
  } else if (activityType === 'jog') {
    container.innerHTML = `
      <label style="display: block; margin-bottom: 10px; font-size: 1rem; color: #333;">Distance (km):</label>
      <input type="number" id="automationDistance" class="auto-trackable" data-action="setDistance" placeholder="Enter distance" style="display: block; margin-bottom: 15px; width: 100%; font-size: 1rem; padding: 8px; border: 1px solid #ccc; border-radius: 8px;">
      <label style="display: block; margin-bottom: 10px; font-size: 1rem; color: #333;">Duration (minutes):</label>
      <input type="number" id="automationDuration" class="auto-trackable" data-action="setDuration" placeholder="Enter duration" style="display: block; margin-bottom: 15px; width: 100%; font-size: 1rem; padding: 8px; border: 1px solid #ccc; border-radius: 8px;">
    `;
  }
  
  // Re-setup tracking for new elements
  setupAutomationTracking();
}

function handleTrackedClick(event) {
  if (!isRecording) return;
  
  const element = event.target;
  const action = element.dataset.action || 'click';
  const value = element.dataset.value || element.textContent?.trim() || '';
  
  recordAutomationAction({
    type: 'click',
    action: action,
    target: getElementSelector(element),
    label: getElementLabel(element),
    value: value
  });
}
function handleTrackedChange(event) {
  if (!isRecording) return;
  
  const element = event.target;
  const action = element.dataset.action || 'change';
  
  recordAutomationAction({
    type: 'change',
    action: action,
    target: getElementSelector(element),
    label: getElementLabel(element),
    value: element.value
  });
}
function handleTrackedInput(event) {
  if (!isRecording) return;
  
  const element = event.target;
  const action = element.dataset.action || 'input';
  
  recordAutomationAction({
    type: 'input',
    action: action,
    target: getElementSelector(element),
    label: getElementLabel(element),
    value: element.value
  });
}

function getElementSelector(element) {
  if (element.id) return '#' + element.id;
  if (element.className) return '.' + element.className.split(' ')[0];
  return element.tagName.toLowerCase() + (element.type ? '[type="' + element.type + '"]' : '');
}

function getElementLabel(element) {
  if (element.textContent && element.textContent.trim()) {
    return element.textContent.trim().substring(0, 50);
  }
  if (element.placeholder) return element.placeholder;
  if (element.dataset.action) return element.dataset.action;
  if (element.title) return element.title;
  return element.tagName.toLowerCase();
}

function recordAutomationAction(actionData) {
  const currentTime = Date.now();
  const mode = document.getElementById('recordingMode').value;
  
  // Calculate timing if in timestamp mode
  let timeSinceLastAction = 0;
  if (mode === 'timestamp') {
    if (lastActionTime) {
      timeSinceLastAction = currentTime - lastActionTime;
    }
    actionData.timeSinceLastAction = timeSinceLastAction;
  }
  
  actionData.timestamp = currentTime;
  
  // Add action to recorded sequence
  recordedActions.push(actionData);
  lastActionTime = currentTime;
  
  // Update UI
  updateActionCount();
  updateConnectionStatus();
  
  // Enable save button if we have actions
  if (recordedActions.length > 0) {
    document.getElementById('saveAutomationBtn').disabled = false;
    document.getElementById('saveAutomationBtn').style.opacity = '1';
  }
  
  console.log('Recorded action:', actionData);
}

function updateActionCount() {
  const count = recordedActions.length;
  document.getElementById('recordedActionsCount').textContent = `${count} action${count !== 1 ? 's' : ''}`;
}

function updateConnectionStatus() {
  // Status UI elements removed for mobile optimization
}

function updateRecordingTimer() {
  if (!recordingStartTime) return;
  
  const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
  const minutes = Math.floor(elapsed / 60);
  const seconds = elapsed % 60;
  document.getElementById('recordingTime').textContent = 
    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}

// Old automation functions removed - iframe handles all app functionality

// Legacy automation functions removed - iframe provides all real app functionality

// All old automation functions removed - iframe provides real Performa app functionality

// Legacy automation functions removed - now using iframe-based recording

function startRecording() {
  const nameInput = document.getElementById('automationName');
  if (!nameInput.value.trim()) {
    alert('Please enter an automation name first!');
    nameInput.focus();
    return;
  }
  
  // Start recording
  isRecording = true;
  recordedActions = [];
  recordingStartTime = Date.now();
  lastActionTime = null;
  
  // Update UI
  document.getElementById('recordingButtonText').textContent = 'Stop';
  document.getElementById('recordingIndicator').textContent = '‚èπ';
  document.getElementById('recordingIndicator').classList.add('recording');
  document.getElementById('startRecordingBtn').onclick = stopRecording;
  document.getElementById('recordingStatus').style.display = 'block';
  document.getElementById('recordingTimer').style.display = 'inline';
  
  // Start recording timer
  recordingTimer = setInterval(updateRecordingTimer, 1000);
  
  // Send command to iframe to start recording
  const iframe = document.getElementById('performaAppIframe');
  if (iframe.contentWindow) {
    iframe.contentWindow.postMessage({ command: 'start-recording' }, '*');
  }
  
  // Update status
  updateConnectionStatus();
  
  console.log('Started automation recording');
}

function stopRecording() {
  // Stop recording
  isRecording = false;
  
  // Update UI
  document.getElementById('recordingButtonText').textContent = 'Record';
  document.getElementById('recordingIndicator').textContent = '‚è∫';
  document.getElementById('recordingIndicator').classList.remove('recording');
  document.getElementById('startRecordingBtn').onclick = startRecording;
  document.getElementById('recordingStatus').style.display = 'none';
  document.getElementById('recordingTimer').style.display = 'none';
  
  // Stop recording timer
  if (recordingTimer) {
    clearInterval(recordingTimer);
    recordingTimer = null;
  }
  
  // Send command to iframe to stop recording
  const iframe = document.getElementById('performaAppIframe');
  if (iframe.contentWindow) {
    iframe.contentWindow.postMessage({ command: 'stop-recording' }, '*');
  }
  
  // Update status
  updateConnectionStatus();
  
  console.log('Stopped automation recording');
}

function recordAction(action, value = null) {
  if (!isRecording) return;
  
  const actionObj = {
    type: action,
    value: value,
    timestamp: Date.now()
  };
  
  recordedActions.push(actionObj);
  
  // Provide visual feedback
  const status = document.getElementById('recordingStatus');
  const countDisplay = document.getElementById('recordedActionsCount');
  status.textContent = `üî¥ Recorded: ${action}${value ? ` (${value})` : ''}`;
  countDisplay.textContent = `${recordedActions.length} actions recorded`;
  
  // Enable save button if actions are recorded
  document.getElementById('saveAutomationBtn').disabled = false;
  document.getElementById('saveAutomationBtn').style.opacity = '1';
}

function saveAutomationSequence() {
  const nameInput = document.getElementById('automationName');
  const name = nameInput.value.trim();
  const mode = currentRecordingMode;
  
  if (!name) {
    alert('Please enter an automation name!');
    return;
  }
  
  if (recordedActions.length === 0) {
    alert('No actions recorded! Please record some actions first.');
    return;
  }
  
  // Stop recording if still active
  if (isRecording) {
    stopRecording();
  }
  
  // Create automation object with new format
  const automation = {
    id: Date.now(),
    name: name,
    mode: mode,
    recordedAt: new Date().toISOString(),
    actions: recordedActions.map(action => {
      // Clean up action object based on mode
      const cleanAction = {
        type: action.type,
        action: action.action, // IMPORTANT: Include the action field for timer detection!
        target: action.target,
        label: action.label || action.value || '',
        value: action.value
      };
      
      // Include timing only in timestamp mode
      if (mode === 'timestamp' && action.timeSinceLastAction !== undefined) {
        cleanAction.timeSinceLastAction = action.timeSinceLastAction;
      }
      
      return cleanAction;
    }),
    actionCount: recordedActions.length,
    totalDuration: recordingStartTime ? Date.now() - recordingStartTime : 0,
    commands: [name.toLowerCase()], // Support multiple commands from the start
    command: name.toLowerCase() // Keep for backward compatibility
  };
  
  // Save to storage
  automationSequences.push(automation);
  localStorage.setItem('automationSequences', JSON.stringify(automationSequences));
  
  // Show success message with details
  const modeText = mode === 'timestamp' ? 'with exact timing' : 'sequence only';
  const durationText = automation.totalDuration ? 
    ` (${Math.round(automation.totalDuration / 1000)}s duration)` : '';
  
  alert(`‚úÖ Automation "${name}" saved successfully!\n\n` +
        `Mode: ${mode.charAt(0).toUpperCase() + mode.slice(1)} ${modeText}\n` +
        `Actions: ${recordedActions.length}${durationText}\n\n` +
        `You can now trigger it by saying "${name}"`);
  
  // Reset and close
  cancelAutomationRecording();
  updateComplexTasksDisplay();
}

function cancelAutomationRecording() {
  // Stop recording if active
  if (isRecording) {
    stopRecording();
  }
  
  // Stop recording timer
  if (recordingTimer) {
    clearInterval(recordingTimer);
    recordingTimer = null;
  }
  
  // Clean up automation message listener
  if (automationMessageListener) {
    window.removeEventListener('message', automationMessageListener);
    automationMessageListener = null;
    console.log('Cleaned up automation message listener');
  }
  
  // Reset iframe setup flag
  iframeRecordingSetup = false;
  
  // Reset recording state
  isRecording = false;
  recordedActions = [];
  recordingStartTime = null;
  lastActionTime = null;
  
  // Reset UI elements
  document.getElementById('automationName').value = '';
  document.getElementById('recordingButtonText').textContent = 'Record';
  document.getElementById('recordingIndicator').textContent = '‚è∫';
  document.getElementById('recordingIndicator').classList.remove('recording');
  document.getElementById('startRecordingBtn').onclick = startRecording;
  document.getElementById('recordingStatus').style.display = 'none';
  document.getElementById('recordingTimer').style.display = 'none';
  resetAutomationButtons();
  updateActionCount();
  document.getElementById('recordingTime').textContent = '00:00';
  
  // Close modal
  document.getElementById('automationRecorderModal').style.display = 'none';
}
// Function to optimize actions for sequence mode
function optimizeSequenceActions(actions) {
  const optimized = [];
  const inputTracker = {}; // Track the latest value for each input field
  
  // First pass: collect final values for input fields
  actions.forEach(action => {
    if (action.type === 'input' && action.elementId) {
      inputTracker[action.elementId] = action;
    }
  });
  
  // Second pass: build optimized action list
  actions.forEach(action => {
    if (action.type === 'input' && action.elementId) {
      // Only keep the final input value for each field
      if (inputTracker[action.elementId] === action) {
        optimized.push(action);
        console.log(`Kept final input for ${action.elementId}: "${action.value}"`);
      } else {
        console.log(`Skipped intermediate input for ${action.elementId}: "${action.value}"`);
      }
    } else {
      // Keep all non-input actions
      optimized.push(action);
    }
  });
  
  return optimized;
}
function executeAutomationSequence(automation) {
  console.log('Starting automation execution:', automation);
  console.log(`Running ${automation.name} automation...`);
  

  
  if (!automation.actions || automation.actions.length === 0) {
    console.warn('No actions found in automation:', automation);

    return;
  }
  
  // Set automation running flag
  isAutomationRunning = true;
  
  // Set up timer monitoring during automation (TEMPORARILY DISABLED FOR DEBUGGING)
  /*
  let timerMonitor = setInterval(() => {
    if (!isAutomationRunning) {
      clearInterval(timerMonitor);
      return;
    }
    
    // Check if timer should be running but isn't
    if (window.activeTimerInterval && !timerInterval) {
      console.warn('Timer stopped during automation - attempting to restart');
      const wasRunning = !!window.activeTimerInterval;
      if (wasRunning) {
        startTimer();
      }
    }
  }, 2000); // Check every 2 seconds
  */
  console.log('‚ö†Ô∏è Timer monitoring temporarily disabled for debugging');
  
  // Display helpful message about manual controls remaining available
  console.log('ü§ñ Automation running - Timer, sidebar, and navigation buttons remain fully functional!');
  
  // Create mobile-friendly status display
  let statusDiv = document.createElement('div');
  statusDiv.id = 'automationStatus';
  statusDiv.style.cssText = `
    position: fixed; top: 10px; left: 10px; right: 10px; 
    background: rgba(0,0,0,0.8); color: white; padding: 10px;
    border-radius: 8px; z-index: 99999; font-size: 14px;
    text-align: center; pointer-events: none;
  `;
  statusDiv.textContent = 'ü§ñ Automation Running...';
  document.body.appendChild(statusDiv);
  
  let executedActions = 0;
  let failedActions = 0;
  let currentActionIndex = 0;
  
  console.log('Automation mode:', automation.mode);
  console.log('Actions:', automation.actions);
  
  // Optimize actions for sequence mode
  if (automation.mode === 'sequence') {
    automation.actions = optimizeSequenceActions(automation.actions);
    console.log('Optimized actions for sequence mode:', automation.actions);
  }
  
  // Sequential execution function
  function executeNextAction() {
    if (currentActionIndex >= automation.actions.length) {
      // All actions completed
      isAutomationRunning = false; // Clear automation flag
      
      // Clear any remaining automation timeouts
      automationTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
      automationTimeouts = [];
      
      const successRate = ((executedActions / automation.actions.length) * 100).toFixed(0);
      speakFeedback(`Automation completed. ${executedActions} of ${automation.actions.length} actions succeeded (${successRate}% success rate). Manual controls are now fully restored.`);
      if (failedActions > 0) {
        console.warn(`Automation had ${failedActions} failed actions out of ${automation.actions.length} total actions`);
      }
      
      // Note: Sidebar state is now managed by individual button clicks
      // No need to force close sidebar at automation end
      console.log('Automation completed - sidebar state managed by button interactions');
      
      // Remove mobile status display
      const statusDiv = document.getElementById('automationStatus');
      if (statusDiv) {
        statusDiv.textContent = '‚úÖ Automation Complete!';
        setTimeout(() => {
          statusDiv.remove();
        }, 2000);
      }
      
      return;
    }
    
    const action = automation.actions[currentActionIndex];
    const index = currentActionIndex;
    
    // Calculate delay BEFORE executing action
    let actionDelay = 0;
    
    if (automation.mode === 'timestamp' && action.timeSinceLastAction !== undefined && index > 0) {
      // Timestamp mode: Use recorded timing delays
      actionDelay = Math.max(action.timeSinceLastAction, 300);
      console.log(`Timestamp mode: Waiting ${actionDelay}ms before action ${index + 1} (recorded: ${action.timeSinceLastAction}ms)`);
    } else if (automation.mode === 'sequence' && index > 0) {
      // Sequence mode: Minimal delays for DOM updates only
      const prevAction = automation.actions[index - 1];
      if (prevAction.action === 'navigation' || prevAction.action === 'toggleDarkMode') {
        actionDelay = 300; // Minimal delay for view transitions
      } else if (prevAction.elementId === 'type') {
        actionDelay = 100; // Minimal delay for field rendering
      } else if (prevAction.action === 'addEntry') {
        actionDelay = 200; // Minimal delay for form submission
      } else {
        actionDelay = 50; // Minimal delay for DOM updates
      }
      console.log(`Sequence mode: Minimal delay ${actionDelay}ms before action ${index + 1} (after: ${prevAction.action || prevAction.type})`);
    }
    
    // Execute action after calculated delay
    const timeoutId = setTimeout(() => {
      // Remove this timeout from tracking once it executes
      automationTimeouts.splice(automationTimeouts.indexOf(timeoutId), 1);
      
      // Note: Removed conflict detection to allow proper automation execution
      // Timer and navigation buttons work independently
      
      console.log(`Executing action ${index + 1}/${automation.actions.length}:`, action);
      
      // Update mobile status display
      const statusDiv = document.getElementById('automationStatus');
      if (statusDiv) {
        let actionDesc = action.label || action.action || action.type;
        if (action.label && ['start', 'stop', 'reset'].includes(action.label.toLowerCase())) {
          actionDesc = `‚è±Ô∏è ${action.label} Timer`;
        } else if (action.action === 'goHome') {
          actionDesc = 'üè† Go Back';
        } else if (action.action === 'navigation') {
          actionDesc = `üì± ${action.label}`;
        }
        statusDiv.textContent = `ü§ñ Step ${index + 1}/${automation.actions.length}: ${actionDesc}`;
      }
      
      try {
        let actionExecuted = false;
        

        
        switch(action.type) {
        case 'click':
          // Handle all click actions uniformly - just click the element
          let clickElement = null;
          
          // Try to find element by ID first (most reliable)
          if (action.elementId) {
            clickElement = document.getElementById(action.elementId);
          }
          
          // Try by target selector
          if (!clickElement && action.target) {
            try {
              clickElement = document.querySelector(action.target);
            } catch (e) {
              console.warn('Invalid selector:', action.target);
            }
          }
          
          // Fallback: try finding element by text content (be more specific for sidebar buttons)
          if (!clickElement && action.label) {
            // First try to find sidebar buttons specifically
            if (action.label && action.label.includes('‚ò∞')) {
              clickElement = Array.from(document.querySelectorAll('button')).find(el => 
                el.textContent.trim().includes('‚ò∞')
              );
              console.log('Found hamburger menu button via ‚ò∞ symbol');
            } else if (action.action === 'navigation' && action.label && action.label.includes('Settings')) {
              clickElement = document.querySelector('button.sidebar-btn-blue');
              console.log('Found settings button via sidebar-btn-blue class');
            } else if (action.action === 'navigation' && action.label && action.label.includes('Progress')) {
              clickElement = document.querySelector('button.sidebar-btn-green');
              console.log('Found progress button via sidebar-btn-green class');
            } else if (action.action === 'navigation' && action.label && action.label.includes('Archive')) {
              clickElement = document.querySelector('button.sidebar-btn-purple');
              console.log('Found archive button via sidebar-btn-purple class');
            } else if (action.action === 'navigation' && action.label && action.label.includes('Mastered')) {
              clickElement = document.querySelector('button.sidebar-btn-orange');
              console.log('Found mastered button via sidebar-btn-orange class');
            } else if (action.action === 'navigation' && action.label && action.label.includes('Ideals')) {
              clickElement = document.querySelector('button.sidebar-btn-teal');
              console.log('Found ideals button via sidebar-btn-teal class');
            } else if (action.action === 'goHome' || (action.label && action.label.includes('‚Üê'))) {
              // Find any visible back button regardless of exact text match
              clickElement = Array.from(document.querySelectorAll('.view-back-btn')).find(btn => 
                btn.offsetParent !== null
              );
              if (clickElement) {
                console.log('Found visible back button');
              } else {
                // Try alternative searches
                clickElement = document.querySelector('.view-back-btn') || 
                              document.querySelector('button[onclick*="hide"][onclick*="View"]');
                if (clickElement) {
                  console.log('Found back button via fallback search');
                }
              }
            } else {
              // Check for timer buttons specifically by text content
              if (action.label && action.label.toLowerCase().trim() === 'start') {
                clickElement = Array.from(document.querySelectorAll('button')).find(el => 
                  el.textContent.trim().toLowerCase() === 'start' && 
                  el.closest('.timer-btns')
                );
                if (clickElement) {
                  console.log('Found start timer button via text content');
                } else {
                  // Fallback: any button with onclick containing startTimer
                  clickElement = Array.from(document.querySelectorAll('button')).find(el => 
                    el.onclick && el.onclick.toString().includes('startTimer')
                  );
                  if (clickElement) console.log('Found start timer button via onclick');
                }
              } else if (action.label && action.label.toLowerCase().trim() === 'stop') {
                clickElement = Array.from(document.querySelectorAll('button')).find(el => 
                  el.textContent.trim().toLowerCase() === 'stop' && 
                  el.closest('.timer-btns')
                );
                if (clickElement) {
                  console.log('Found stop timer button via text content');
                } else {
                  clickElement = Array.from(document.querySelectorAll('button')).find(el => 
                    el.onclick && el.onclick.toString().includes('stopTimer')
                  );
                  if (clickElement) console.log('Found stop timer button via onclick');
                }
              } else if (action.label && action.label.toLowerCase().trim() === 'reset') {
                clickElement = Array.from(document.querySelectorAll('button')).find(el => 
                  el.textContent.trim().toLowerCase() === 'reset' && 
                  el.closest('.timer-btns')
                );
                if (clickElement) {
                  console.log('Found reset timer button via text content');
                } else {
                  clickElement = Array.from(document.querySelectorAll('button')).find(el => 
                    el.onclick && el.onclick.toString().includes('resetTimer')
                  );
                  if (clickElement) console.log('Found reset timer button via onclick');
                }
              } else {
                // General text-based search for other elements
                clickElement = Array.from(document.querySelectorAll('button, a, [onclick], input[type="button"], input[type="submit"]')).find(el => {
                  const text = el.textContent || el.value || el.getAttribute('aria-label') || '';
                  return text.trim().toLowerCase().includes(action.label.trim().toLowerCase());
                });
                
                // Special case: if this looks like a back button but wasn't caught above
                if (!clickElement && action.label && action.label.includes('‚Üê')) {
                  clickElement = Array.from(document.querySelectorAll('.view-back-btn')).find(btn => 
                    btn.offsetParent !== null
                  );
                  if (clickElement) {
                    console.log('Found back button via special case detection');
                  }
                }
              }
            }
          }
          

          
          if (clickElement && typeof clickElement.click === 'function') {
            try {
              // Click the element
              clickElement.click();
              // Handle timer actions - call the functions directly for reliability
              if (action.action === 'startTimer') {
                startTimer();
                // Verify timer started (without retry for now)
                setTimeout(() => {
                  if (timerInterval) {
                    console.log('Timer confirmed running after automation click');
                  } else {
                    console.error('Timer not running after click');
                  }
                }, 500);
              } else if (action.action === 'stopTimer') {
                console.log('Executing stopTimer function directly after click');
                stopTimer();
              } else if (action.action === 'resetTimer') {
                console.log('Executing resetTimer function directly after click');
                resetTimer();
              }
              
              // Handle specific post-click actions  
              if (action.action === 'goHome') {
                // Let the back button handle its own navigation
                // Don't override with showMainView() call
                console.log('Back button clicked - letting button handle navigation naturally');
                console.log('Current clickElement:', clickElement);
                console.log('Button onclick handler:', clickElement.onclick);
              }
              
              // Note: Sidebar buttons now handle their own toggleSidebar() call
              // No need for automation to manage sidebar state
              if (action.action === 'navigation' && clickElement.classList.contains('sidebar-btn')) {
                console.log('Sidebar navigation clicked - letting button handle sidebar close');
              }
              actionExecuted = true;
            } catch (clickError) {
              console.error('Error clicking element:', clickError);
            }
          } else {
            console.warn(`Element not found or not clickable: ${action.target}`, action);
            
            // For back button actions, try a more aggressive search
            if (action.action === 'goHome' || (action.label && action.label.includes('‚Üê'))) {
              // Force find any visible back button and click it
              const backBtn = Array.from(document.querySelectorAll('.view-back-btn')).find(btn => 
                btn.offsetParent !== null
              );
              if (backBtn) {
                backBtn.click();
                console.log('Force-clicked visible back button');
                actionExecuted = true;
              }
            }
            
            // For timer button actions, try a more aggressive search
            if (action.label && ['start', 'stop', 'reset'].includes(action.label.toLowerCase().trim())) {
              let timerBtn = null;
              if (action.label.toLowerCase().trim() === 'start') {
                timerBtn = document.querySelector('.timer-btns button[onclick*="startTimer"]');
              } else if (action.label.toLowerCase().trim() === 'stop') {
                timerBtn = document.querySelector('.timer-btns button[onclick*="stopTimer"]');
              } else if (action.label.toLowerCase().trim() === 'reset') {
                timerBtn = document.querySelector('.timer-btns button[onclick*="resetTimer"]');
              }
              
              if (timerBtn) {
                timerBtn.click();
                console.log(`Force-clicked ${action.label} timer button`);
                actionExecuted = true;
              }
            }
          }
          break;
        case 'input':
          // Handle recorded input actions
          let inputElement = null;
          
          // Try to find element by ID first
          if (action.elementId) {
            inputElement = document.getElementById(action.elementId);
          }
          
          // Fallback: try by selector
          if (!inputElement && action.target) {
            try {
              inputElement = document.querySelector(action.target);
            } catch (e) {
              console.warn('Invalid input selector:', action.target);
            }
          }
          
          // Additional fallback: try finding input by placeholder or label
          if (!inputElement && action.label) {
            inputElement = Array.from(document.querySelectorAll('input, textarea')).find(el => 
              el.placeholder && el.placeholder.includes(action.label) ||
              el.id && action.label.includes(el.id)
            );
          }
          
          if (inputElement && action.value !== undefined) {
            if (automation.mode === 'sequence') {
              // In sequence mode: Set the value instantly (no typing simulation)
              inputElement.value = action.value;
              inputElement.dispatchEvent(new Event('input', { bubbles: true }));
              inputElement.dispatchEvent(new Event('change', { bubbles: true }));
              
              // Special handling for exercise name input to trigger autofill
              if (inputElement.id === 'exerciseName' && action.value.trim()) {
                setTimeout(() => {
                  triggerIdealAutofill(action.value.trim());
                }, 50);
              }
              
              console.log(`Sequence mode - Input set instantly: ${action.value} in ${action.elementId || action.target}`);
            } else {
              // In timestamp mode: Keep original behavior (could add typing simulation here if needed)
              inputElement.value = action.value;
              inputElement.dispatchEvent(new Event('input', { bubbles: true }));
              inputElement.dispatchEvent(new Event('change', { bubbles: true }));
              console.log(`Timestamp mode - Input set: ${action.value} in ${action.elementId || action.target}`);
            }
            actionExecuted = true;
          } else {
            console.warn(`Element not found for input: ${action.target}`, action);
          }
          break;
        case 'change':
          // Handle recorded change actions
          let changeElement = null;
          
          // Try to find element by ID first
          if (action.elementId) {
            changeElement = document.getElementById(action.elementId);
          }
          
          // Fallback: try by selector
          if (!changeElement && action.target) {
            try {
              changeElement = document.querySelector(action.target);
            } catch (e) {
              console.warn('Invalid change selector:', action.target);
            }
          }
          
          // Additional fallback: try finding select by option text or label
          if (!changeElement && action.label) {
            changeElement = Array.from(document.querySelectorAll('select, input')).find(el => 
              el.id && action.label.includes(el.id) ||
              (el.tagName === 'SELECT' && Array.from(el.options).some(opt => opt.text.includes(action.label)))
            );
          }
          
          if (changeElement && action.value !== undefined) {
            changeElement.value = action.value;
            changeElement.dispatchEvent(new Event('change', { bubbles: true }));
            
            // Special handling for activity type changes that trigger renderFields()
            if (action.elementId === 'type') {
              setTimeout(() => {
                renderFields(); // Ensure fields are updated after activity type change
                console.log(`Activity type changed to: ${action.value}`);
              }, 150);
            } else {
              console.log(`Changed ${action.elementId || action.target} to: ${action.value}`);
            }
            actionExecuted = true;
          } else {
            console.warn(`Element not found for change: ${action.target}`, action);
          }
          break;
        // Timer action types - fallback cases (mainly handled in click case now)
        case 'startTimer':
          try {
            console.log('Executing startTimer automation action...');
            startTimer();
            // Verify timer actually started
            setTimeout(() => {
              if (timerInterval) {
                console.log('Timer started successfully - interval confirmed');
              } else {
                console.warn('Timer action executed but interval not found - retrying');
                startTimer();
              }
            }, 500);
            actionExecuted = true;
          } catch (error) {
            console.error('Error starting timer:', error);
          }
          break;
        case 'stopTimer':
          try {
            console.log('Executing stopTimer automation action...');
            stopTimer();
            console.log('Timer stopped successfully');
            actionExecuted = true;
          } catch (error) {
            console.error('Error stopping timer:', error);
          }
          break;
        case 'resetTimer':
          try {
            console.log('Executing resetTimer automation action...');
            resetTimer();
            console.log('Timer reset successfully');
            actionExecuted = true;
          } catch (error) {
            console.error('Error resetting timer:', error);
          }
          break;
        case 'setActivityType':
          document.getElementById('type').value = action.value;
          renderFields();
          console.log(`Activity type set to: ${action.value}`);
          actionExecuted = true;
          break;
        case 'setExerciseName':
          setTimeout(() => {
            const nameField = document.getElementById('exerciseName');
            if (nameField) {
              nameField.value = action.value;
              console.log(`Exercise name set to: ${action.value}`);
            }
          }, 100);
          actionExecuted = true;
          break;
        case 'setCategory':
          document.getElementById('category').value = action.value;
          console.log(`Category set to: ${action.value}`);
          actionExecuted = true;
          break;
        case 'setActualValue':
          setTimeout(() => {
            const actualField = document.getElementById('actualValue');
            if (actualField) {
              actualField.value = action.value;
              console.log(`Actual value set to: ${action.value}`);
            }
          }, 100);
          actionExecuted = true;
          break;
        case 'setIdealValue':
          setTimeout(() => {
            const idealField = document.getElementById('idealValue');
            if (idealField) {
              idealField.value = action.value;
              console.log(`Ideal value set to: ${action.value}`);
            }
          }, 100);
          actionExecuted = true;
          break;
        case 'addEntry':
          setTimeout(() => {
            const addBtn = document.getElementById('addEntry');
            if (addBtn) {
              addBtn.click();
              console.log('Add entry button clicked');
            }
          }, 100);
          actionExecuted = true;
          break;
        case 'filterEntries':
          filterEntries(action.value);
          console.log(`Filtered entries to: ${action.value}`);
          actionExecuted = true;
          break;
        case 'showProgress':
          showProgressView();
          console.log('Showing progress view');
          actionExecuted = true;
          break;
        case 'showArchive':
          showArchiveView();
          console.log('Showing archive view');
          actionExecuted = true;
          break;
        case 'showMastered':
          showMasteredView();
          console.log('Showing mastered view');
          actionExecuted = true;
          break;
        case 'showIdeals':
          showIdealsPage();
          console.log('Showing ideals view');
          actionExecuted = true;
          break;
        case 'showSettings':
          // Add delay to prevent view conflicts during automation
          setTimeout(() => {
            showSettingsView();
            console.log('Opening settings via automation');
          }, 100);
          actionExecuted = true;
          break;
        case 'showMain':
        case 'goHome':
          // Add delay and ensure clean view switching
          setTimeout(() => {
            showMainView();
            // Extra cleanup for automation-triggered view switches
            const sidebar = document.getElementById("sidebar");
            const overlay = document.getElementById("overlay");
            if (sidebar) sidebar.style.left = "-220px";
            if (overlay) overlay.style.display = "none";
            console.log('Returning to main view via automation');
          }, 100);
          actionExecuted = true;
          break;
        case 'startJogging':
          startJogging();
          console.log('Started jogging');
          actionExecuted = true;
          break;
        case 'stopJogging':
          stopJogging();
          console.log('Stopped jogging');
          actionExecuted = true;
          break;
        default:
          console.warn(`Unknown action type: ${action.type}`, action);
          break;
      }
      
      // Track action execution
      if (actionExecuted) {
        executedActions++;
      } else {
        failedActions++;
      }
      
    } catch (error) {
      console.error(`Error executing action ${index + 1}:`, action, error);
      speakFeedback(`Error executing action: ${action.label || action.type}`);
      failedActions++;
    }
    
    // Move to next action
    currentActionIndex++;
    
    // Schedule next action immediately (delays are handled in executeNextAction)
    executeNextAction();
      
    }, actionDelay);
    
    // Track this timeout to avoid conflicts
    automationTimeouts.push(timeoutId);
  }
  
  // Start the first action immediately
  executeNextAction();
}
// Automation Editing Functions
let editingAutomationId = null;

function editAutomationSequence(automationId) {
  const automation = automationSequences.find(a => a.id === automationId);
  if (!automation) return;
  
  editingAutomationId = automationId;
  
  // Populate edit form
  document.getElementById('editAutomationName').value = automation.name;
  
  // Handle both old single command format and new multiple commands format
  const commandsText = automation.commands ? 
    automation.commands.join('\n') : 
    (automation.command || automation.name);
  document.getElementById('editAutomationCommand').value = commandsText;
  
  // Display actions
  const actionsContainer = document.getElementById('editAutomationActions');
  actionsContainer.innerHTML = automation.actions.map((action, index) => {
    return `
      <div style="padding: 8px; margin: 5px 0; background: #ffffff; border-radius: 6px; border-left: 3px solid #2196F3; display: flex; justify-content: space-between; align-items: center;">
        <span><strong>${index + 1}.</strong> ${action.type}${action.value ? ` (${action.value})` : ''}</span>
        <button onclick="removeActionFromEdit(${index})" style="background: #f44336; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">Remove</button>
      </div>
    `;
  }).join('');
  
  document.getElementById('automationEditModal').style.display = 'flex';
}

function removeActionFromEdit(actionIndex) {
  const automation = automationSequences.find(a => a.id === editingAutomationId);
  if (!automation) return;
  
  automation.actions.splice(actionIndex, 1);
  
  // Refresh the display
  const actionsContainer = document.getElementById('editAutomationActions');
  actionsContainer.innerHTML = automation.actions.map((action, index) => {
    return `
      <div style="padding: 8px; margin: 5px 0; background: #ffffff; border-radius: 6px; border-left: 3px solid #2196F3; display: flex; justify-content: space-between; align-items: center;">
        <span><strong>${index + 1}.</strong> ${action.type}${action.value ? ` (${action.value})` : ''}</span>
        <button onclick="removeActionFromEdit(${index})" style="background: #f44336; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">Remove</button>
      </div>
    `;
  }).join('');
}
function saveEditedAutomation() {
  const name = document.getElementById('editAutomationName').value.trim();
  const commandText = document.getElementById('editAutomationCommand').value.trim();
  
  if (!name || !commandText) {
    alert('Please fill in both name and command fields!');
    return;
  }
  
  const automation = automationSequences.find(a => a.id === editingAutomationId);
  if (!automation) return;
  
  // Parse multiple commands (one per line)
  const commands = commandText.split('\n')
    .map(cmd => cmd.trim().toLowerCase())
    .filter(cmd => cmd.length > 0);
  
  automation.name = name;
  automation.commands = commands;
  automation.command = commands[0]; // Keep primary command for backward compatibility
  automation.modified = new Date().toLocaleString();
  
  localStorage.setItem('automationSequences', JSON.stringify(automationSequences));
  
  alert('Automation updated successfully!');
  cancelEditAutomation();
  updateComplexTasksDisplay();
}

function cancelEditAutomation() {
  document.getElementById('automationEditModal').style.display = 'none';
  editingAutomationId = null;
}

function updateComplexTasksDisplay() {
  const displaySection = document.getElementById('complexTasksDisplay');
  const listContainer = document.getElementById('complexTasksList');
  
  if (complexTasks.length === 0 && automationSequences.length === 0) {
    displaySection.style.display = 'none';
    return;
  }
  
  displaySection.style.display = 'block';
  listContainer.innerHTML = '';
  
  // Show complex tasks
  if (complexTasks.length > 0) {
    const taskHeader = document.createElement('h4');
    taskHeader.textContent = 'üîß Complex Tasks';
    taskHeader.style.color = '#00796b';
    taskHeader.style.marginBottom = '15px';
    taskHeader.style.fontSize = '1.3rem';
    listContainer.appendChild(taskHeader);
    
    complexTasks.forEach(task => {
      const taskDiv = document.createElement('div');
      taskDiv.className = 'complex-task-display';
      const commandsDisplay = task.commands ? 
        task.commands.map(cmd => `"${cmd}"`).join(', ') : 
        `"${task.command || task.primaryCommand}"`;
        
      taskDiv.innerHTML = `
        <div style="margin-bottom: 8px;">
          <strong style="font-size: 1.1rem; color: #2E7D32;">${commandsDisplay}</strong>
          ${task.commands && task.commands.length > 1 ? '<small style="color: #666; font-style: italic;"> (multiple commands)</small>' : ''}
        </div>
        <div style="margin-bottom: 8px; color: #666; font-size: 0.9rem;">
          <strong>Actions:</strong> ${task.actions.length > 50 ? task.actions.substring(0, 50) + '...' : task.actions}
        </div>
        <div style="margin-bottom: 8px; color: #666; font-size: 0.9rem;">
          <strong>Feedback:</strong> ${task.feedback || 'Default feedback'}
        </div>
        <div style="text-align: right; display: flex; gap: 10px; justify-content: flex-end;">
          <button onclick="runComplexTask(${task.id})" class="task-button" style="background: #4CAF50;">‚ñ∂Ô∏è Run</button>
          <button onclick="editComplexTask(${task.id})" class="task-button" style="background: #2196F3;">‚úèÔ∏è Edit</button>
          <button onclick="deleteComplexTask(${task.id})" class="task-button" style="background: #f44336;">üóëÔ∏è Delete</button>
        </div>
      `;
      listContainer.appendChild(taskDiv);
    });
  }
  
  // Show automation sequences
  if (automationSequences.length > 0) {
    const autoHeader = document.createElement('h4');
    autoHeader.textContent = 'üéØ Automation Sequences';
    autoHeader.style.color = '#00796b';
    autoHeader.style.marginTop = '25px';
    autoHeader.style.marginBottom = '15px';
    autoHeader.style.fontSize = '1.3rem';
    listContainer.appendChild(autoHeader);
    
    automationSequences.forEach(automation => {
      const autoDiv = document.createElement('div');
      autoDiv.className = 'automation-task-display';
      const automationCommandsDisplay = automation.commands ? 
        automation.commands.map(cmd => `"${cmd}"`).join(', ') : 
        `"${automation.command || automation.name.toLowerCase()}"`;
        
      autoDiv.innerHTML = `
        <div style="margin-bottom: 8px;">
          <strong style="font-size: 1.1rem; color: #1565C0;">${automationCommandsDisplay}</strong>
          ${automation.commands && automation.commands.length > 1 ? '<small style="color: #666; font-style: italic;"> (multiple commands)</small>' : ''}
        </div>
        <div style="margin-bottom: 8px; color: #666; font-size: 0.9rem;">
          <strong>Actions:</strong> ${automation.actions.length} recorded steps
        </div>
        <div style="margin-bottom: 8px; color: #666; font-size: 0.9rem;">
          <strong>Created:</strong> ${automation.created}
          ${automation.modified ? `<br><strong>Modified:</strong> ${automation.modified}` : ''}
        </div>
        <div style="text-align: right;">
          <button onclick="runAutomationById(${automation.id})" class="task-button run" style="background: #28a745; color: white;">‚ñ∂ Run</button>
          <button onclick="editAutomationSequence(${automation.id})" class="task-button edit">Edit</button>
          <button onclick="deleteAutomationSequence(${automation.id})" class="task-button">Delete</button>
        </div>
      `;
      listContainer.appendChild(autoDiv);
    });
  }
}

function runComplexTask(taskId) {
  const task = complexTasks.find(t => t.id === taskId);
  if (task) {
    console.log('Running complex task:', task);
    executeComplexTask(task);
  } else {
    alert('Complex task not found!');
  }
}

function editComplexTask(taskId) {
  // Find the task in the settings view and focus on it
  const taskElement = document.getElementById(`complexTask_${taskId}`);
  if (taskElement) {
    // Open settings view if not already open
    showSettingsView();
    
    // Scroll to the task
    setTimeout(() => {
      taskElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
      
      // Highlight the task temporarily
      taskElement.style.background = 'rgba(76, 175, 80, 0.1)';
      taskElement.style.border = '2px solid #4CAF50';
      setTimeout(() => {
        taskElement.style.background = '';
        taskElement.style.border = '';
      }, 3000);
      
      // Focus on the first input field
      const firstInput = taskElement.querySelector('textarea, input');
      if (firstInput) {
        firstInput.focus();
      }
    }, 500);
  } else {
    alert('Complex task not found for editing!');
  }
}

function deleteComplexTask(taskId) {
  if (confirm('Are you sure you want to delete this complex task?')) {
    complexTasks = complexTasks.filter(task => task.id !== taskId);
    localStorage.setItem('complexTasks', JSON.stringify(complexTasks));
    updateComplexTasksDisplay();
  }
}

function runAutomationById(automationId) {
  console.log('Attempting to run automation with ID:', automationId);
  const automation = automationSequences.find(auto => auto.id === automationId);
  if (automation) {
    console.log('Found automation:', automation);
    executeAutomationSequence(automation);
  } else {
    console.error('Automation not found for ID:', automationId, 'Available automations:', automationSequences);
    alert('Automation not found!');
  }
}

function deleteAutomationSequence(automationId) {
  if (confirm('Are you sure you want to delete this automation sequence?')) {
    automationSequences = automationSequences.filter(auto => auto.id !== automationId);
    localStorage.setItem('automationSequences', JSON.stringify(automationSequences));
    updateComplexTasksDisplay();
  }
}

function toggleEntrySummary() {
  const enabled = document.getElementById("entrySummaryToggle").checked;
  localStorage.setItem("entrySummaryEnabled", enabled ? "on" : "off");
}

function loadVoiceSettings() {
  const commands = getVoiceCommands();
  const summaryEnabled = localStorage.getItem("entrySummaryEnabled") !== "off";
  const summaryToggle = document.getElementById("entrySummaryToggle");
  if (summaryToggle) summaryToggle.checked = summaryEnabled;
  
  // Load basic commands
  const setCommandValue = (id, value) => {
    const element = document.getElementById(id);
    if (element) element.value = value;
  };
  
  setCommandValue("startTimerCommand", commands.startTimer);
  setCommandValue("stopTimerCommand", commands.stopTimer);
  setCommandValue("resetTimerCommand", commands.resetTimer);
  setCommandValue("startTimerForCommand", commands.startTimerFor);
  setCommandValue("startJogCommand", commands.startJog);
  setCommandValue("stopJogCommand", commands.stopJog);
  setCommandValue("addEntryCommand", commands.addEntry);
  setCommandValue("logExerciseCommand", commands.logExercise);
  setCommandValue("setActualRepsCommand", commands.setActualReps);
  
  // Load navigation commands
  setCommandValue("showProgressCommand", commands.showProgress);
  setCommandValue("showArchiveCommand", commands.showArchive);
  setCommandValue("openSettingsCommand", commands.openSettings);
  setCommandValue("goHomeCommand", commands.goHome);
  
  // Load feedback messages
  setCommandValue("startTimerFeedback", commands.startTimerFeedback);
  setCommandValue("stopTimerFeedback", commands.stopTimerFeedback);
  setCommandValue("resetTimerFeedback", commands.resetTimerFeedback);
  setCommandValue("timerSetFeedback", commands.timerSetFeedback);
  setCommandValue("startJogFeedback", commands.startJogFeedback);
  setCommandValue("stopJogFeedback", commands.stopJogFeedback);
  setCommandValue("addEntryFeedback", commands.addEntryFeedback);
  setCommandValue("logExerciseFeedback", commands.logExerciseFeedback);
  setCommandValue("setActualRepsFeedback", commands.setActualRepsFeedback);
  setCommandValue("navigationFeedback", commands.navigationFeedback);
  
  // Load existing complex tasks
  loadComplexTasks();
}

function loadComplexTasks() {
  const container = document.getElementById('complexTasksContainer');
  container.innerHTML = '';
  
  complexTasks.forEach(task => {
    const taskDiv = document.createElement('div');
    taskDiv.id = `complexTask_${task.id}`;
    taskDiv.className = 'complex-task-item';
    
    // Handle both old single command format and new multiple commands format
    const commandsText = task.commands ? 
      task.commands.join('\n') : 
      (task.command || task.primaryCommand || '');
      
    taskDiv.innerHTML = `
      <div style="margin-bottom: 15px;">
        <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #00796b;">Command Phrases (one per line):</label>
        <textarea id="taskCommand_${task.id}" style="width: 100%; height: 60px; padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-size: 1rem; resize: vertical;">${commandsText}</textarea>
        <small style="color: #666; font-style: italic;">You can set multiple voice commands that trigger the same task</small>
      </div>
      <div style="margin-bottom: 15px;">
        <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #00796b;">
          Actions (comma separated):
          <button onclick="showComplexTaskHelp()" style="background: #2196F3; color: white; border: none; border-radius: 50%; width: 20px; height: 20px; cursor: pointer; font-size: 12px; margin-left: 5px; display: inline-flex; align-items: center; justify-content: center;" title="Show available commands">i</button>
        </label>
        <textarea id="taskActions_${task.id}" style="width: 100%; height: 80px; resize: vertical; padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-family: inherit; font-size: 0.95rem;">${task.actions}</textarea>
        <small style="color: #666; font-style: italic;">Examples: "turn on dark mode", "show progress", "start timer", "set category to C.S.A"</small>
      </div>
      <div style="margin-bottom: 15px;">
        <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #00796b;">Voice Feedback:</label>
        <input type="text" id="taskFeedback_${task.id}" value="${task.feedback}" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-size: 1rem;">
      </div>
      <div style="text-align: right; display: flex; gap: 10px; justify-content: flex-end;">
        <button onclick="saveComplexTask(${task.id})" style="background: linear-gradient(135deg, #4CAF50, #45a049); color: white; padding: 8px 16px; border: none; border-radius: 20px; cursor: pointer; font-weight: 600; transition: all 0.3s ease;">üíæ Save Task</button>
        <button onclick="removeComplexTask(${task.id})" style="background: linear-gradient(135deg, #f44336, #d32f2f); color: white; padding: 8px 16px; border: none; border-radius: 20px; cursor: pointer; font-weight: 600; transition: all 0.3s ease;">Remove Task</button>
      </div>
    `;
    
    container.appendChild(taskDiv);
  });
}

function toggleGPSTracking() {
  gpsTrackingEnabled = document.getElementById("gpsTrackingToggle").checked;
  localStorage.setItem("gpsTrackingEnabled", gpsTrackingEnabled ? "on" : "off");
  if (!gpsTrackingEnabled && watchId) {
    navigator.geolocation.clearWatch(watchId);
    watchId = null;
  }
}

function toggleRoutePreview() {
  routePreviewEnabled = document.getElementById("routePreviewToggle").checked;
  localStorage.setItem("routePreviewEnabled", routePreviewEnabled ? "on" : "off");
}

// View management functions
function showProgressView() {
  // Allow view switching even during automation
  document.getElementById("mainContent").style.display = "none";
  document.getElementById("archiveView").style.display = "none";
  document.getElementById("masteredView").style.display = "none";
  document.getElementById("idealScoreView").style.display = "none";
  document.getElementById("settingsView").style.display = "none";
  document.getElementById("progressView").style.display = "block";
  renderProgressChart(currentChartType);
  
  // Log interaction during automation
  if (isAutomationRunning) {
    console.log('Progress view opened manually during automation');
  }
}

function hideProgressView() {
  // Always allow navigation back to home, even during automation
  console.log('hideProgressView() called');
  
  // Hide ALL views first to prevent conflicts
  const allViews = ["settingsView", "progressView", "archiveView", "masteredView", "idealScoreView"];
  allViews.forEach(viewId => {
    const view = document.getElementById(viewId);
    if (view) view.style.display = "none";
  });
  
  // Show main content with delay
  setTimeout(() => {
    const mainContent = document.getElementById("mainContent");
    if (mainContent) {
      mainContent.style.display = "block";
      mainContent.style.visibility = "visible";
      mainContent.style.opacity = "1";
    }
  }, 100);
  
  // If manually triggered during automation, close sidebar
  if (isAutomationRunning) {
    const sidebar = document.getElementById("sidebar");
    const overlay = document.getElementById("overlay");
    if (sidebar) sidebar.style.left = "-220px";
    if (overlay) overlay.style.display = "none";
  }
}

function showMasteredView() {
  // Allow view switching even during automation
  document.getElementById("mainContent").style.display = "none";
  document.getElementById("progressView").style.display = "none";
  document.getElementById("archiveView").style.display = "none";
  document.getElementById("idealScoreView").style.display = "none";
  document.getElementById("settingsView").style.display = "none";
  document.getElementById("masteredView").style.display = "block";
  loadMasteredEntries();
  
  // Log interaction during automation
  if (isAutomationRunning) {
    console.log('Mastered view opened manually during automation');
  }
}

function hideMasteredView() {
  // Always allow navigation back to home, even during automation
  document.getElementById("masteredView").style.display = "none";
  document.getElementById("mainContent").style.display = "block";
  
  // If manually triggered during automation, close sidebar
  if (isAutomationRunning) {
    const sidebar = document.getElementById("sidebar");
    const overlay = document.getElementById("overlay");
    if (sidebar) sidebar.style.left = "-220px";
    if (overlay) overlay.style.display = "none";
  }
}

function showIdealsPage() {
  // Allow view switching even during automation
  document.getElementById("mainContent").style.display = "none";
  document.getElementById("progressView").style.display = "none";
  document.getElementById("archiveView").style.display = "none";
  document.getElementById("masteredView").style.display = "none";
  document.getElementById("settingsView").style.display = "none";
  document.getElementById("idealScoreView").style.display = "block";
  loadIdealEntries();
  
  // Log interaction during automation
  if (isAutomationRunning) {
    console.log('Ideals view opened manually during automation');
  }
}

function hideIdealScoreView() {
  // Always allow navigation back to home, even during automation
  document.getElementById("idealScoreView").style.display = "none";
  document.getElementById("mainContent").style.display = "block";
  
  // If manually triggered during automation, close sidebar
  if (isAutomationRunning) {
    const sidebar = document.getElementById("sidebar");
    const overlay = document.getElementById("overlay");
    if (sidebar) sidebar.style.left = "-220px";
    if (overlay) overlay.style.display = "none";
  }
}

function showArchiveView() {
  // Allow view switching even during automation
  document.getElementById("mainContent").style.display = "none";
  document.getElementById("archiveView").style.display = "block";
  loadArchiveEntries();
  
  // Log interaction during automation
  if (isAutomationRunning) {
    console.log('Archive view opened manually during automation');
  }
}

function hideArchiveView() {
  // Always allow navigation back to home, even during automation
  document.getElementById("archiveView").style.display = "none";
  document.getElementById("mainContent").style.display = "block";
  
  // If manually triggered during automation, close sidebar
  if (isAutomationRunning) {
    const sidebar = document.getElementById("sidebar");
    const overlay = document.getElementById("overlay");
    if (sidebar) sidebar.style.left = "-220px";
    if (overlay) overlay.style.display = "none";
  }
}

function showSettingsView() {
  // Allow view switching even during automation
  document.getElementById("mainContent").style.display = "none";
  document.getElementById("progressView").style.display = "none";
  document.getElementById("archiveView").style.display = "none";
  document.getElementById("masteredView").style.display = "none";
  document.getElementById("idealScoreView").style.display = "none";
  document.getElementById("settingsView").style.display = "block";
  
  // Note: Sidebar closing is now handled by the button's toggleSidebar() call
  // No need to force close here to avoid conflicts
  
  // Log interaction during automation
  if (isAutomationRunning) {
    console.log('Settings view opened manually during automation');
  }
}

function hideSettingsView() {
  // Always allow navigation back to home, even during automation
  console.log('hideSettingsView() called');
  
  const settingsView = document.getElementById("settingsView");
  const mainContent = document.getElementById("mainContent");
  
  // Hide ALL views first to prevent conflicts
  const allViews = ["settingsView", "progressView", "archiveView", "masteredView", "idealScoreView"];
  allViews.forEach(viewId => {
    const view = document.getElementById(viewId);
    if (view) {
      view.style.display = "none";
    }
  });
  
  // Then show main content with a small delay to ensure DOM updates
  setTimeout(() => {
    if (mainContent) {
      // Force main content to be visible
      mainContent.style.display = "block";
      mainContent.style.visibility = "visible";
      mainContent.style.opacity = "1";
      console.log('All views hidden, main content shown');
      
      // Update mobile status if automation is running
      const statusDiv = document.getElementById('automationStatus');
      if (statusDiv && isAutomationRunning) {
        statusDiv.textContent = 'üè† Back to Home View';
      }
    }
  }, 100);
  
  // Ensure sidebar is properly closed when returning from settings
  const sidebar = document.getElementById("sidebar");
  const overlay = document.getElementById("overlay");
  if (sidebar) {
    sidebar.style.left = "-220px";
  }
  if (overlay) {
    overlay.style.display = "none";
  }
  
  // Only clear automation flag if not currently running an automation
  // This prevents manual navigation from stopping automation
  if (!isAutomationRunning) {
    console.log('Settings view closed - no automation running');
  } else {
    console.log('Settings view closed during automation - automation continues');
  }
}

function hideAllViews() {
  // Hide all other views
  hideProgressView();
  hideArchiveView();
  hideMasteredView();
  hideIdealScoreView();
  hideSettingsView();
  hideStreakView();
  hideRouteView();
  
  // Show main content
  document.getElementById("mainContent").style.display = "block";
}

function showMainView() {
  console.log('showMainView() called - cleaning up all views');
  
  // Hide all other views
  const viewsToHide = ["progressView", "archiveView", "masteredView", "idealScoreView", "settingsView"];
  viewsToHide.forEach(viewId => {
    const view = document.getElementById(viewId);
    if (view) {
      view.style.display = "none";
      console.log(`Hidden view: ${viewId}`);
    }
  });
  
  // Show main content
  const mainContent = document.getElementById("mainContent");
  if (mainContent) {
    mainContent.style.display = "block";
    console.log('Main content shown');
  }
  
  // Ensure sidebar is properly closed
  const sidebar = document.getElementById("sidebar");
  const overlay = document.getElementById("overlay");
  if (sidebar) {
    sidebar.style.left = "-220px";
  }
  if (overlay) {
    overlay.style.display = "none";
  }
  
  // Only clear automation flag if called from non-automation context
  // This prevents manual navigation from stopping automation
  const wasAutomationRunning = isAutomationRunning;
  if (!wasAutomationRunning) {
    console.log('showMainView() completed - no automation was running');
  } else {
    console.log('showMainView() completed - automation continues running');
  }
}

function showRouteView() {
  document.getElementById("routeView").style.display = "block";
  renderRouteMap();
}

function hideRouteView() {
  document.getElementById("routeView").style.display = "none";
  if (map) {
    map.remove();
    map = null;
  }
  if (polyline) {
    polyline.remove();
    polyline = null;
  }
}
// Form and entry functions
function renderFields() {
  const type = document.getElementById('type').value;
  const fields = document.getElementById('fields');
  console.log("renderFields called with type:", type);
  fields.innerHTML = '';

  if (type === 'reps') {
    fields.innerHTML = `
      <input placeholder="Exercise name" id="exerciseName" oninput="showSuggestions(this.value); triggerIdealAutofill(this.value)" onchange="triggerIdealAutofill(this.value)" onblur="triggerIdealAutofill(this.value)" autocomplete="off" list="nameSuggestions">
      <input type="number" placeholder="Actual reps" id="actualValue">
      <input type="number" placeholder="Ideal reps" id="idealValue">
    `;
    document.getElementById('jogControls').style.display = 'none';
  } else if (type === 'iso') {
    fields.innerHTML = `
      <input placeholder="Exercise name" id="exerciseName" oninput="showSuggestions(this.value); triggerIdealAutofill(this.value)" onchange="triggerIdealAutofill(this.value)" onblur="triggerIdealAutofill(this.value)" autocomplete="off" list="nameSuggestions">
      <input type="number" placeholder="Actual time (sec)" id="actualValue">
      <input type="number" placeholder="Ideal time (sec)" id="idealValue">
    `;
    document.getElementById('jogControls').style.display = 'none';
  } else if (type === 'semi') {
    fields.innerHTML = `
      <input placeholder="Exercise name" id="exerciseName" oninput="showSuggestions(this.value); triggerIdealAutofill(this.value)" onchange="triggerIdealAutofill(this.value)" onblur="triggerIdealAutofill(this.value)" autocomplete="off" list="nameSuggestions">
      <input type="number" placeholder="Actual time (sec)" id="actualValue">
      <input type="number" placeholder="Actual reps" id="reps">
      <input type="number" placeholder="Ideal time (sec)" id="idealTime">
      <input type="number" placeholder="Ideal reps" id="idealReps">
    `;
    document.getElementById('jogControls').style.display = 'none';
  } else if (type === 'jog') {
    fields.innerHTML = `
      <input placeholder="Jog Title (optional)" id="exerciseName" oninput="showSuggestions(this.value); triggerIdealAutofill(this.value)" onchange="triggerIdealAutofill(this.value)" onblur="triggerIdealAutofill(this.value)" autocomplete="off" list="nameSuggestions">
      <input type="number" placeholder="Ideal distance (km)" id="idealDistance">
      <input type="number" placeholder="Ideal avg speed (km/h)" id="idealSpeed">
    `;
    document.getElementById('jogControls').style.display = 'block';
  }
}

function renderIdealInputs() {
  const type = document.getElementById('idealType').value;
  const container = document.getElementById('idealFields');
  container.innerHTML = '';
  if (type === 'reps') {
    container.innerHTML = '<label for="idealReps">Ideal Reps:</label><input type="number" id="idealReps">';
  } else if (type === 'iso') {
    container.innerHTML = '<label for="idealTime">Ideal Time (seconds):</label><input type="number" id="idealTime">';
  } else if (type === 'semi') {
    container.innerHTML = '<label for="idealTime">Ideal Time (seconds):</label><input type="number" id="idealTime"><label for="idealReps">Ideal Reps:</label><input type="number" id="idealReps">';
  } else if (type === 'jog') {
    container.innerHTML = '<label for="idealDistance">Ideal Distance (km):</label><input type="number" id="idealDistance"><label for="idealSpeed">Ideal Speed (km/h):</label><input type="number" id="idealSpeed">';
  }
}
// Jogging Tracker functions
async function startJogging() {
  if (isJogging) {
    stopJogging();
    return;
  }
  
  if (!('geolocation' in navigator)) {
    showGPSError("Geolocation not supported");
    return;
  }

  try {
    const permission = await navigator.permissions.query({ name: 'geolocation' });
    if (permission.state === 'denied') {
      showGPSError("Location access denied. Please enable in settings.");
      return;
    }

      isJogging = true;
  joggingPositions = [];
  joggingStartTime = Date.now();
  document.getElementById('startJogBtn').textContent = 'Stop Jog';
  document.getElementById('jogStats').style.display = 'block';
  document.getElementById('jogDistance').textContent = '0';
  document.getElementById('jogDuration').textContent = '0';
  document.getElementById('jogAvgSpeed').textContent = '0';
  
  // Automatically select jogging activity type
  document.getElementById('type').value = 'jog';
  document.getElementById('category').value = 'CA.P';
  renderFields();
    
    resetTimer();
    startTimer();
    
    if (gpsTrackingEnabled) {
      // Initialize enhanced jogging tracking
      initializeJoggingSession();
      
      // High-accuracy GPS configuration for precise tracking
      const gpsOptions = {
        enableHighAccuracy: true,
        maximumAge: 1000,        // Accept 1-second old locations (reduced from 10 seconds)
        timeout: 8000,           // Increased timeout for better accuracy
        frequency: 1000          // Request updates every second
      };
      
      watchId = navigator.geolocation.watchPosition(
        position => {
          document.getElementById('gpsError').style.display = 'none';
          
          // Process high-accuracy location data
          processLocationUpdate(position);
        },
        error => {
          showGPSError(getGeolocationError(error));
        },
        gpsOptions
      );
    }
  } catch (e) {
    showGPSError("Could not check location permissions");
  }
}

function getGeolocationError(error) {
  switch(error.code) {
    case 1: return "Location access denied";
    case 2: return "Location unavailable";
    case 3: return "Location request timed out";
    default: return "Location error occurred";
  }
}

function showGPSError(message) {
  document.getElementById('gpsError').textContent = message;
  document.getElementById('gpsError').style.display = 'block';
}

function stopJogging() {
  if (!isJogging) return;
  
  isJogging = false;
  document.getElementById('startJogBtn').textContent = 'Start Jog';
  stopTimer();
  
  if (watchId) {
    navigator.geolocation.clearWatch(watchId);
    watchId = null;
  }
  
  // Clear enhanced jogging session
  isPaused = false;
  clearJoggingSession();
  
  // Remove status indicator
  const statusElement = document.getElementById('jogStatus');
  if (statusElement) {
    statusElement.remove();
  }
  
  updateJogStats();
  
  // Show confirmation dialog with live route
  if (joggingPositions.length > 1 && routePreviewEnabled) {
    showSaveConfirmation();
  } else {
    saveJogEntry();
  }
}

function showSaveConfirmation() {
  document.getElementById('confirmationDialog').style.display = 'flex';
  
  // Initialize a new map for the confirmation dialog
  if (confirmationMap) confirmationMap.remove();
  
  // Check if Leaflet is available
  if (typeof L === 'undefined') {
    document.getElementById('confirmationMapView').innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">üó∫Ô∏è Maps require internet connection<br>Your route data is still saved!</div>';
    return;
  }
  
  const firstPos = joggingPositions[0];
  confirmationMap = L.map('confirmationMapView').setView([firstPos.latitude, firstPos.longitude], 15);
  
  // Add OpenStreetMap tiles (with offline fallback)
  if (navigator.onLine) {
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(confirmationMap);
  } else {
    // Show offline notice
    document.getElementById('confirmationMapView').innerHTML = '<div class="offline-notice" style="display: flex;">You are offline</div>';
  }
  
  // Convert positions to Leaflet LatLng objects
  const latlngs = joggingPositions.map(pos => [pos.latitude, pos.longitude]);
  
  // Add polyline to map
  confirmationPolyline = L.polyline(latlngs, {color: 'red'}).addTo(confirmationMap);
  
  // Add start and end markers
  L.marker(latlngs[0]).addTo(confirmationMap)
    .bindPopup("Start")
    .openPopup();
  
  if (latlngs.length > 1) {
    L.marker(latlngs[latlngs.length - 1]).addTo(confirmationMap)
      .bindPopup("End");
  }
  
  // Fit map to route bounds
  confirmationMap.fitBounds(confirmationPolyline.getBounds(), {padding: [20, 20]});
}

function confirmSaveJogEntry() {
  // Capture the map image before saving
  captureMap(true);
}

function cancelSaveJogEntry() {
  document.getElementById('confirmationDialog').style.display = 'none';
  if (confirmationMap) {
    confirmationMap.remove();
    confirmationMap = null;
  }
  routeImageData = null; // Don't save the image
  saveJogEntry();
}

// üèÉ‚Äç‚ôÇÔ∏è Enhanced Jogging Session Management
let joggingSessionId = null;
let lastLocationTime = null;
let locationHistory = [];
let isPaused = false;
let pausedTime = 0;
let lastPauseTime = null;
let movementThreshold = 2; // meters per second to detect movement
let locationSmoothingWindow = 3; // number of points to average for smoothing

function initializeJoggingSession() {
  joggingSessionId = `jog_${Date.now()}`;
  lastLocationTime = Date.now();
  locationHistory = [];
  isPaused = false;
  pausedTime = 0;
  lastPauseTime = null;
  
  // Restore previous session if exists
  restoreJoggingSession();
  
  console.log('üèÉ‚Äç‚ôÇÔ∏è Enhanced jogging session initialized:', joggingSessionId);
}

function processLocationUpdate(position) {
  const currentTime = Date.now();
  const { latitude, longitude, accuracy, speed } = position.coords;
  
  // Validate GPS accuracy (reject very inaccurate readings)
  if (accuracy > 50) {
    console.warn(`‚ö†Ô∏è GPS accuracy too low (${accuracy}m), skipping update`);
    return;
  }
  
  const locationData = {
    latitude,
    longitude,
    accuracy,
    speed: speed || 0,
    timestamp: currentTime,
    isPaused: false
  };
  
  // Smooth location data to reduce GPS glitches
  const smoothedLocation = smoothLocationData(locationData);
  
  // Auto pause/resume detection
  const movementDetected = detectMovement(smoothedLocation);
  handleAutoPauseResume(movementDetected, currentTime);
  
  // Only add location if not paused
  if (!isPaused) {
    smoothedLocation.isPaused = false;
    joggingPositions.push(smoothedLocation);
    locationHistory.push(smoothedLocation);
    
    // Persist session data
    persistJoggingSession();
    
    updateJogStats();
    updateMapDisplay();
  } else {
    console.log('‚è∏Ô∏è Jogging paused - location not recorded');
  }
  
  lastLocationTime = currentTime;
}

function smoothLocationData(newLocation) {
  locationHistory.push(newLocation);
  
  // Keep only recent locations for smoothing
  if (locationHistory.length > locationSmoothingWindow) {
    locationHistory = locationHistory.slice(-locationSmoothingWindow);
  }
  
  // If we have multiple points, apply smoothing
  if (locationHistory.length >= 2) {
    // Weighted average with more weight on recent locations
    let totalWeight = 0;
    let smoothedLat = 0;
    let smoothedLon = 0;
    
    locationHistory.forEach((loc, index) => {
      const weight = index + 1; // More recent locations get higher weight
      smoothedLat += loc.latitude * weight;
      smoothedLon += loc.longitude * weight;
      totalWeight += weight;
    });
    
    return {
      ...newLocation,
      latitude: smoothedLat / totalWeight,
      longitude: smoothedLon / totalWeight
    };
  }
  
  return newLocation;
}

function detectMovement(location) {
  if (joggingPositions.length < 2) return true; // Assume moving at start
  
  const lastPosition = joggingPositions[joggingPositions.length - 1];
  const timeDiff = (location.timestamp - lastPosition.timestamp) / 1000; // seconds
  
  if (timeDiff === 0) return true;
  
  const distance = haversineDistance(
    lastPosition.latitude, lastPosition.longitude,
    location.latitude, location.longitude
  ) * 1000; // Convert to meters
  
  const speed = distance / timeDiff; // meters per second
  
  // Movement detected if speed is above threshold
  return speed > movementThreshold;
}

function handleAutoPauseResume(movementDetected, currentTime) {
  if (!movementDetected && !isPaused) {
    // Auto-pause detected
    isPaused = true;
    lastPauseTime = currentTime;
    
    // Pause the timer
    if (timerInterval) {
      clearInterval(timerInterval);
      timerInterval = null;
    }
    
    showPauseNotification();
    console.log('‚è∏Ô∏è Auto-pause detected - user stopped moving');
    
  } else if (movementDetected && isPaused) {
    // Auto-resume detected
    isPaused = false;
    
    // Add paused time to total
    if (lastPauseTime) {
      pausedTime += currentTime - lastPauseTime;
      lastPauseTime = null;
    }
    
    // Resume the timer
    if (!timerInterval) {
      startTimer();
    }
    
    showResumeNotification();
    console.log('‚ñ∂Ô∏è Auto-resume detected - user started moving');
  }
}

function showPauseNotification() {
  // Update UI to show paused state
  const statusElement = document.getElementById('jogStatus') || createStatusElement();
  statusElement.textContent = '‚è∏Ô∏è Automatically Paused';
  statusElement.style.background = '#ff9800';
  statusElement.style.color = 'white';
}

function showResumeNotification() {
  // Update UI to show resumed state
  const statusElement = document.getElementById('jogStatus') || createStatusElement();
  statusElement.textContent = '‚ñ∂Ô∏è Automatically Resumed';
  statusElement.style.background = '#4caf50';
  statusElement.style.color = 'white';
  
  // Clear notification after 3 seconds
  setTimeout(() => {
    statusElement.textContent = 'üèÉ‚Äç‚ôÇÔ∏è Tracking Active';
    statusElement.style.background = '#00796b';
  }, 3000);
}

function createStatusElement() {
  const statusElement = document.createElement('div');
  statusElement.id = 'jogStatus';
  statusElement.style.cssText = `
    position: fixed;
    top: 10px;
    right: 10px;
    padding: 8px 16px;
    border-radius: 20px;
    font-size: 14px;
    font-weight: bold;
    z-index: 1000;
    background: #00796b;
    color: white;
  `;
  statusElement.textContent = 'üèÉ‚Äç‚ôÇÔ∏è Tracking Active';
  document.body.appendChild(statusElement);
  return statusElement;
}

function persistJoggingSession() {
  try {
    const sessionData = {
      sessionId: joggingSessionId,
      startTime: joggingStartTime,
      positions: joggingPositions,
      isPaused: isPaused,
      pausedTime: pausedTime,
      lastUpdate: Date.now()
    };
    
    localStorage.setItem('activeJoggingSession', JSON.stringify(sessionData));
  } catch (error) {
    console.warn('Failed to persist jogging session:', error);
  }
}

function restoreJoggingSession() {
  try {
    const sessionData = localStorage.getItem('activeJoggingSession');
    if (sessionData) {
      const session = JSON.parse(sessionData);
      
      // Check if session is recent (within last hour)
      const timeSinceLastUpdate = Date.now() - session.lastUpdate;
      if (timeSinceLastUpdate < 60 * 60 * 1000) { // 1 hour
        joggingPositions = session.positions || [];
        pausedTime = session.pausedTime || 0;
        
        if (session.positions && session.positions.length > 0) {
          console.log(`üìç Restored jogging session with ${session.positions.length} positions`);
          updateMapDisplay();
        }
      } else {
        // Clear old session
        localStorage.removeItem('activeJoggingSession');
      }
    }
  } catch (error) {
    console.warn('Failed to restore jogging session:', error);
    localStorage.removeItem('activeJoggingSession');
  }
}

function clearJoggingSession() {
  localStorage.removeItem('activeJoggingSession');
  joggingSessionId = null;
}

function updateMapDisplay() {
  // Update the map in real-time if it's open
  if (map && joggingPositions.length > 0) {
    const latlngs = joggingPositions.map(pos => [pos.latitude, pos.longitude]);
    if (polyline) {
      polyline.setLatLngs(latlngs);
    } else {
      polyline = L.polyline(latlngs, {color: 'red', weight: 4}).addTo(map);
    }
    if (latlngs.length > 0) {
      map.setView(latlngs[latlngs.length - 1], 16); // Slightly more zoomed in
    }
  }
}

function updateJogStats() {
  if (joggingPositions.length < 2) return;
  
  // Calculate actual moving time (excluding paused time)
  const totalElapsed = (Date.now() - joggingStartTime) / 1000; // in seconds
  const actualDuration = totalElapsed - (pausedTime / 1000); // subtract paused time
  const distance = calculateTotalDistance(joggingPositions); // in km
  const avgSpeed = distance / (actualDuration / 3600); // km/h
  
  // Calculate current speed from last few positions
  const currentSpeed = calculateCurrentSpeed();
  
  document.getElementById('jogDistance').textContent = distance.toFixed(3);
  document.getElementById('jogDuration').textContent = Math.round(actualDuration);
  document.getElementById('jogAvgSpeed').textContent = avgSpeed.toFixed(2);
  
  // Update current speed if element exists
  const currentSpeedElement = document.getElementById('jogCurrentSpeed');
  if (currentSpeedElement) {
    currentSpeedElement.textContent = currentSpeed.toFixed(1);
  }
  
  // Also update route stats if the route view is open
  if (document.getElementById('routeView').style.display === 'block') {
    document.getElementById('routeDistance').textContent = distance.toFixed(3);
    document.getElementById('routeDuration').textContent = Math.round(actualDuration);
    document.getElementById('routeAvgSpeed').textContent = avgSpeed.toFixed(2);
  }
}

function calculateCurrentSpeed() {
  if (joggingPositions.length < 3) return 0;
  
  // Use last 3 positions to calculate current speed
  const recentPositions = joggingPositions.slice(-3);
  let totalDistance = 0;
  let totalTime = 0;
  
  for (let i = 1; i < recentPositions.length; i++) {
    const distance = haversineDistance(
      recentPositions[i-1].latitude, recentPositions[i-1].longitude,
      recentPositions[i].latitude, recentPositions[i].longitude
    );
    const time = (recentPositions[i].timestamp - recentPositions[i-1].timestamp) / 1000 / 3600; // hours
    
    totalDistance += distance;
    totalTime += time;
  }
  
  return totalTime > 0 ? totalDistance / totalTime : 0; // km/h
}

function calculateTotalDistance(positions) {
  let totalDistance = 0;
  for (let i = 1; i < positions.length; i++) {
    totalDistance += haversineDistance(
      positions[i-1].latitude, positions[i-1].longitude,
      positions[i].latitude, positions[i].longitude
    );
  }
  return totalDistance;
}

function haversineDistance(lat1, lon1, lat2, lon2) {
  const R = 6371; // Radius of the Earth in km
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = 
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
    Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

function saveJogEntry() {
  const type = 'jog';
  const category = document.getElementById('category').value;
  const name = 'Jogging';
  const duration = parseFloat(document.getElementById('jogDuration').textContent);
  const distance = parseFloat(document.getElementById('jogDistance').textContent);
  const avgSpeed = parseFloat(document.getElementById('jogAvgSpeed').textContent);
  const idealDistance = parseFloat(document.getElementById('idealDistance').value) || 5;
  const idealSpeed = parseFloat(document.getElementById('idealSpeed').value) || 10;
  
  if (!category || category === "Select category") {
    alert("Please select a category.");
    return;
  }
  
  if (!idealDistance || !idealSpeed || idealDistance <= 0 || idealSpeed <= 0) {
    alert("Please enter valid ideal distance and speed.");
    return;
  }

  const entry = {
    type,
    category,
    name,
    date: new Date().toLocaleDateString(),
    duration: `${duration} seconds`,
    distance: `${distance.toFixed(3)} km`,
    avgSpeed: `${avgSpeed.toFixed(2)} km/h`,
    idealDistance,
    idealSpeed,
    score: ((distance * avgSpeed) / (idealDistance * idealSpeed)).toFixed(2),
    positions: joggingPositions,
    routeImage: routeImageData
  };
  
  const tx = db.transaction("entries", "readwrite");
  const store = tx.objectStore("entries");
  const addReq = store.add(entry);
  
  addReq.onsuccess = () => {
    if (parseFloat(entry.score) >= 1.00) {
      const mtx = db.transaction("mastered", "readwrite");
      mtx.objectStore("mastered").add(entry);
    }
    loadEntries();
  };
  
  tx.oncomplete = () => {
    loadEntries();
    updateScorePanel();
    updateNameSuggestions();
    updateStreak();
    
    // Mark today as having activity in calendar
    const today = new Date().toISOString().split('T')[0];
    localStorage.setItem(`log_${today}`, 'true');
    
    // Speak entry summary if enabled
    if (localStorage.getItem("entrySummaryEnabled") !== "off") {
      let summary = `${entry.name} logged`;
      if (entry.type === 'reps') {
        summary += ` for ${entry.actual} reps`;
      } else if (entry.type === 'iso') {
        summary += ` for ${entry.actual} seconds`;
      } else if (entry.type === 'semi') {
        summary += ` for ${entry.actual} seconds and ${entry.reps} reps`;
      } else if (entry.type === 'jog') {
        summary += ` for ${entry.distance}`;
      }
      summary += `. Score: ${entry.score}`;
      speakFeedback(summary);
    }
  };
  
  // Reset jogging data
  document.getElementById('confirmationDialog').style.display = 'none';
  if (confirmationMap) {
    confirmationMap.remove();
    confirmationMap = null;
  }
  routeImageData = null;
}
function viewRoute() {
  if (joggingPositions.length < 1) {
    alert("No position data available yet");
    return;
  }
  
  showRouteView();
}
function renderRouteMap() {
  const mapDisplay = document.getElementById('map');
  const offlineNotice = document.getElementById('offlineNotice');
  
  if (!navigator.onLine) {
    offlineNotice.style.display = 'flex';
    mapDisplay.style.display = 'none';
    return;
  }
  
  offlineNotice.style.display = 'none';
  mapDisplay.style.display = 'block';
  
  // Initialize Leaflet map
  if (map) map.remove();
  
  // Check if Leaflet is available
  if (typeof L === 'undefined') {
    document.getElementById('map').innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">üó∫Ô∏è Maps require internet connection<br>Your route data is still available!</div>';
    return;
  }
  
  const firstPos = joggingPositions[0] || { latitude: 0, longitude: 0 };
  map = L.map('map').setView([firstPos.latitude, firstPos.longitude], 15);
  
  // Add OpenStreetMap tiles
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
  }).addTo(map);
  
  if (joggingPositions.length > 0) {
    // Convert positions to Leaflet LatLng objects
    const latlngs = joggingPositions.map(pos => [pos.latitude, pos.longitude]);
    
    // Add polyline to map
    polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);
    
    // Add start marker
    L.marker(latlngs[0]).addTo(map)
      .bindPopup("Start")
      .openPopup();
    
    // Add end marker if available
    if (latlngs.length > 1) {
      L.marker(latlngs[latlngs.length - 1]).addTo(map)
        .bindPopup("End");
    }
    
    // Fit map to route bounds
    map.fitBounds(polyline.getBounds(), {padding: [20, 20]});
  }
  
  // Update route stats
  const duration = parseFloat(document.getElementById('jogDuration').textContent);
  const distance = parseFloat(document.getElementById('jogDistance').textContent);
  const avgSpeed = parseFloat(document.getElementById('jogAvgSpeed').textContent);
  
  document.getElementById('routeDistance').textContent = distance.toFixed(3);
  document.getElementById('routeDuration').textContent = Math.round(duration);
  document.getElementById('routeAvgSpeed').textContent = avgSpeed.toFixed(2);
}

function captureMap(forConfirmation = false) {
  const targetMap = forConfirmation ? confirmationMap : map;
  if (!targetMap) return;
  
  // Get the map container element
  const mapContainer = forConfirmation ? document.getElementById('confirmationMapView') : document.getElementById('map');
  
  // Check if html2canvas is available
  if (typeof html2canvas === 'undefined') {
    alert('‚úÖ Route saved! (Image capture requires internet connection)');
    routeImageData = null; // Set to null but continue
    return;
  }
  
  // Use html2canvas to capture the map
  html2canvas(mapContainer, {
    backgroundColor: null,
    logging: false,
    useCORS: true,
    allowTaint: true,
    scale: 1
  }).then(canvas => {
    // Convert canvas to data URL
    routeImageData = canvas.toDataURL('image/png');
    
    if (!forConfirmation) {
      // Show success message
      alert('Route image captured successfully! It will be saved with your jog entry.');
      
      // Close the route view
      hideRouteView();
    } else {
      // If this is for confirmation, proceed to save
      document.getElementById('confirmationDialog').style.display = 'none';
      if (confirmationMap) {
        confirmationMap.remove();
        confirmationMap = null;
      }
      saveJogEntry();
    }
  }).catch(err => {
    console.error('Error capturing map:', err);
    alert('Failed to capture route image. Please try again.');
  });
}

function addEntry() {
  // Check if database is initialized
  if (!db) {
    alert("Database not ready. Please wait a moment and try again.");
    return;
  }

  const typeElement = document.getElementById('type');
  const type = typeElement ? typeElement.value : null;
  
  if (!type || type === "") {
    alert("Please select an activity type");
    return;
  }
  
  const category = document.getElementById('category').value;
  if (!category || category === "Select category") {
    alert("Please select a category.");
    return;
  }

  const entry = {
    type,
    category,
    date: new Date().toLocaleDateString(),
    timestamp: Date.now() // Unique identifier for tracking duplicates
  };
  const elapsedSeconds = Math.floor(elapsed / 1000);

  if (type === 'reps') {
    const nameEl = document.getElementById('exerciseName');
    const actualEl = document.getElementById('actualValue');
    const idealEl = document.getElementById('idealValue');
    
    console.log("Reps form elements:", {
      name: !!nameEl, actual: !!actualEl, ideal: !!idealEl
    });
    
    if (!nameEl || !actualEl || !idealEl) {
      alert("Form fields not found. Please select activity type first.");
      return;
    }
    
    const name = nameEl.value.trim();
    const actual = +actualEl.value;
    const ideal = +idealEl.value;
    if (!name || !actual || !ideal) return alert("Please fill all fields.");
    entry.name = name;
    entry.actual = actual;
    entry.ideal = ideal;
    entry.score = (actual / ideal).toFixed(2);
      } else if (type === 'iso') {
      const nameEl = document.getElementById('exerciseName');
      const actualEl = document.getElementById('actualValue');
      const idealEl = document.getElementById('idealValue');
      
      console.log("Iso form elements:", {
        name: !!nameEl, actual: !!actualEl, ideal: !!idealEl
      });
      
      if (!nameEl || !actualEl || !idealEl) {
        alert("Form fields not found. Please select activity type first.");
        return;
      }
      
      const name = nameEl.value.trim();
      const actual = +actualEl.value || elapsedSeconds;
      const ideal = +idealEl.value;
    if (!name || !ideal) return alert("Please fill all fields.");
    entry.name = name;
    entry.actual = actual;
    entry.ideal = ideal;
    entry.score = (actual / ideal).toFixed(2);
  } else if (type === 'semi') {
    const name = document.getElementById('exerciseName').value.trim();
    const actual = +document.getElementById('actualValue').value || elapsedSeconds;
    const reps = +document.getElementById('reps').value;
    const idealTime = +document.getElementById('idealTime').value;
    const idealReps = +document.getElementById('idealReps').value;
    if (!name || !actual || !reps || !idealTime || !idealReps) return alert("Please fill all fields.");
    entry.name = name;
    entry.actual = actual;
    entry.reps = reps;
    entry.idealTime = idealTime;
    entry.idealReps = idealReps;
    entry.score = ((actual * reps) / (idealTime * idealReps)).toFixed(2);
  } else if (type === 'jog') {
    const duration = parseFloat(document.getElementById('jogDuration').textContent);
    const distance = parseFloat(document.getElementById('jogDistance').textContent);
    const avgSpeed = parseFloat(document.getElementById('jogAvgSpeed').textContent);
    const idealDistance = parseFloat(document.getElementById('idealDistance').value) || 5;
    const idealSpeed = parseFloat(document.getElementById('idealSpeed').value) || 10;
    
    if (!duration || !distance || !avgSpeed) return alert("Please complete your jog first.");
    if (!idealDistance || !idealSpeed || idealDistance <= 0 || idealSpeed <= 0) {
      return alert("Please enter valid ideal distance and speed.");
    }
    
    entry.name = "Jogging";
    entry.duration = `${duration} seconds`;
    entry.distance = `${distance.toFixed(3)} km`;
    entry.avgSpeed = `${avgSpeed.toFixed(2)} km/h`;
    entry.idealDistance = idealDistance;
    entry.idealSpeed = idealSpeed;
    entry.score = ((distance * avgSpeed) / (idealDistance * idealSpeed)).toFixed(2);
    entry.positions = joggingPositions;
    entry.routeImage = routeImageData;
  }

  const tx = db.transaction("entries", "readwrite");
  const store = tx.objectStore("entries");
  const addReq = editingId ? store.put({ ...entry, id: editingId }) : store.add(entry);
  
  addReq.onsuccess = () => {
    if (parseFloat(entry.score) >= 1.00) {
      const mtx = db.transaction("mastered", "readwrite");
      mtx.objectStore("mastered").add(entry);
    }
    // Don't call loadEntries() here - wait for tx.oncomplete to avoid duplicates
  };
  
  addReq.onerror = (e) => {
    console.error("Error adding entry:", e.target.error);
    alert("Failed to save entry. Please try again.");
  };
  
  tx.onerror = (e) => {
    console.error("Transaction error:", e.target.error);
    alert("Database error. Please refresh the page and try again.");
  };
  
  tx.oncomplete = () => {
    loadEntries();
    updateScorePanel();
    updateNameSuggestions();
    updateStreak();
    
    // Mark today as having activity in calendar
    const today = new Date().toISOString().split('T')[0];
    localStorage.setItem(`log_${today}`, 'true');
    
    // Speak entry summary if enabled
    if (localStorage.getItem("entrySummaryEnabled") !== "off") {
      let summary = `${entry.name} logged`;
      if (entry.type === 'reps') {
        summary += ` for ${entry.actual} reps`;
      } else if (entry.type === 'iso') {
        summary += ` for ${entry.actual} seconds`;
      } else if (entry.type === 'semi') {
        summary += ` for ${entry.actual} seconds and ${entry.reps} reps`;
      } else if (entry.type === 'jog') {
        summary += ` for ${entry.distance}`;
      }
      summary += `. Score: ${entry.score}`;
      speakFeedback(summary);
    }
    
    // Clear form ONLY after successful completion
    editingId = null;
    document.getElementById('addEntry').textContent = 'Add Entry';
    document.getElementById('cancelEdit').style.display = 'none';
    
    // Clear all form fields properly
    document.getElementById('type').value = '';
    document.getElementById('category').value = 'Select category';
    document.getElementById('fields').innerHTML = '';
    
    // Re-render empty fields
    renderFields();
  };
}

function cancelEdit() {
  editingId = null;
  document.getElementById('addEntry').textContent = 'Add Entry';
  document.getElementById('cancelEdit').style.display = 'none';
  document.getElementById('fields').innerHTML = '';
  renderFields();
}
// Database functions
function loadEntries() {
  showDebugInfo('üîç loadEntries() called');
  
  if (!db) {
    showDebugInfo('‚ö†Ô∏è No database - waiting...');
    // Retry after database initialization
    setTimeout(() => loadEntries(), 200);
    return;
  }
  
  showDebugInfo('üìä DB ready, querying...');
  const tx = db.transaction("entries", "readonly");
  const store = tx.objectStore("entries");
  const req = store.getAll();

  req.onsuccess = () => {
    showDebugInfo('‚úÖ Query successful');
    updateScorePanel();
    updateNameSuggestions();
    const entries = req.result;
    showDebugInfo(`üìã Found ${entries.length} entries`);
    
    const container = document.getElementById('entries');
    showDebugInfo('üì¶ Container: ' + !!container);
    
    if (!container) {
      showDebugInfo('‚ö†Ô∏è No container, retrying...');
      setTimeout(() => loadEntries(), 100);
      return;
    }
    
    container.innerHTML = '';
    showDebugInfo('üßπ Container cleared');

    const uniqueMap = new Map();

    entries.forEach(e => {
      if (currentFilter !== 'all' && e.type !== currentFilter) return;
      if (selectedCategory && e.category !== selectedCategory) return;

      const key = `${e.name}_${e.date}`;
      const existing = uniqueMap.get(key);
      if (!existing || e.id > existing.id) {
        uniqueMap.set(key, e);
      }
    });

    const entriesToDisplay = [...uniqueMap.values()];
    showDebugInfo(`üñ•Ô∏è Displaying ${entriesToDisplay.length} entries`);
    
    entriesToDisplay.forEach(e => {
      const div = document.createElement('div');
      div.className = 'entry';
      div.onclick = ev => {
        if (ev.target.tagName === 'BUTTON') return;
        editEntry(e.id);
      };
      let extra = '';
      if (e.type === 'reps') {
        extra = `Actual: ${e.actual}<br>Ideal: ${e.ideal}`;
      } else if (e.type === 'iso') {
        extra = `Actual: ${e.actual} sec<br>Ideal: ${e.ideal} sec`;
      } else if (e.type === 'semi') {
        extra = `Actual: ${e.actual}s, Reps: ${e.reps}<br>Ideal: ${e.idealTime}s, Reps: ${e.idealReps}`;
      } else if (e.type === 'jog') {
        extra = `Duration: ${e.duration}`;
        if (e.distance) extra += `<br>Distance: ${e.distance}`;
        if (e.avgSpeed) extra += `<br>Avg Speed: ${e.avgSpeed}`;
        if (e.positions && e.positions.length > 1) {
          extra += `<br><button onclick="viewSavedRoute(${e.id})" class="edit-btn" style="margin-top: 8px;">View Route</button>`;
        }
        if (e.routeImage) {
          extra += `<img src="${e.routeImage}" class="route-map-image" alt="Route Map">`;
        }
      }
      div.innerHTML = `<strong>${e.name || 'Unnamed'}</strong><br>
                       ${e.score ? `Score: ${e.score}<br>` : ''}
                       ${extra}<br>Date: ${e.date}<br>
                       <button onclick="deleteEntry(${e.id})" class="delete-btn">üóëÔ∏è Delete</button>`;
      container.appendChild(div);
    });
    
    showDebugInfo(`üéâ Complete! ${container.children.length} shown`);
  };
}

function viewSavedRoute(entryId) {
  const tx = db.transaction("entries", "readonly");
  const store = tx.objectStore("entries");
  const req = store.get(entryId);
  
  req.onsuccess = () => {
    const entry = req.result;
    if (!entry || !entry.positions || entry.positions.length < 2) {
      alert("No route data available for this entry");
      return;
    }
    
    joggingPositions = entry.positions;
    showRouteView();
    
    // Update route stats
    const duration = entry.duration ? parseFloat(entry.duration.split(' ')[0]) : 0;
    const distance = entry.distance ? parseFloat(entry.distance.split(' ')[0]) : 0;
    const avgSpeed = entry.avgSpeed ? parseFloat(entry.avgSpeed.split(' ')[0]) : 0;
    
    document.getElementById('routeDistance').textContent = distance.toFixed(3);
    document.getElementById('routeDuration').textContent = Math.round(duration);
    document.getElementById('routeAvgSpeed').textContent = avgSpeed.toFixed(2);
  };
}

function loadMasteredEntries() {
  if (!db) {
    console.warn('Database not ready for loading mastered entries');
    return;
  }
  
  const tx = db.transaction("mastered", "readonly");
  const store = tx.objectStore("mastered");
  const req = store.getAll();

  req.onsuccess = () => {
    const container = document.getElementById("masteredContainer");
    
    if (!container) {
      console.warn('Mastered container not found, retrying in 100ms...');
      setTimeout(() => loadMasteredEntries(), 100);
      return;
    }
    
    container.innerHTML = "";
    const entries = req.result;

    entries.forEach(e => {
      const div = document.createElement("div");
      div.className = "archive-entry";
      let extra = "";
      if (e.type === 'reps') {
        extra = `Actual: ${e.actual}<br>Ideal: ${e.ideal}`;
      } else if (e.type === 'iso') {
        extra = `Actual: ${e.actual} sec<br>Ideal: ${e.ideal} sec`;
      } else if (e.type === 'semi') {
        extra = `Actual: ${e.actual}s, Reps: ${e.reps}<br>Ideal: ${e.idealTime}s, Reps: ${e.idealReps}`;
      } else if (e.type === 'jog') {
        extra = `Duration: ${e.duration}`;
        if (e.distance) extra += `<br>Distance: ${e.distance}`;
        if (e.avgSpeed) extra += `<br>Avg Speed: ${e.avgSpeed}`;
        if (e.routeImage) {
          extra += `<img src="${e.routeImage}" class="route-map-image" alt="Route Map">`;
        }
      }
      div.innerHTML = `<strong>${e.name || 'Unnamed'}</strong><br>
                       ${e.score ? `Score: ${e.score}<br>` : ''}
                       ${extra}<br>Date: ${e.date}<br>
                       <button onclick="deleteMastered(${e.id})" class="delete-btn">üóëÔ∏è Delete</button>`;
      container.appendChild(div);
    });
  };
}

function loadIdealEntries() {
  const container = document.getElementById("idealLogs");
  if (!container) return;
  
  if (!db) {
    console.warn('Database not ready for loading ideal entries');
    return;
  }
  
  container.innerHTML = "";

  const tx = db.transaction("ideals", "readonly");
  const store = tx.objectStore("ideals");
  const req = store.getAll();

  req.onsuccess = () => {
    const entries = req.result;
    const filtered = selectedCategory 
      ? entries.filter(e => e.category === selectedCategory)
      : entries;

    if (!filtered.length) {
      container.innerHTML = "<p style='text-align:center;color:#888'>No ideal entries logged yet.</p>";
      return;
    }

    filtered.forEach(e => {
      const div = document.createElement("div");
      div.className = "entry";
      let content = `<strong>${e.name}</strong><br>Type: ${e.type}<br>Category: ${e.category}<br>`;

      if (e.type === "reps") content += `Ideal Reps: ${e.idealReps}`;
      else if (e.type === "iso") content += `Ideal Time: ${e.idealTime} sec`;
      else if (e.type === "semi") content += `Ideal Time: ${e.idealTime} sec, Reps: ${e.idealReps}`;
      else if (e.type === "jog") content += `Ideal Distance: ${e.idealDistance} km, Ideal Speed: ${e.idealSpeed} km/h`;

      content += `<br>
        <div style="display: flex; gap: 10px; margin-top: 10px;">
          <button onclick="editIdealEntry(${e.id})" class="edit-btn" style="flex: 1; min-width: 0; padding: 10px; font-size: 0.9rem; height: 40px; border: none; border-radius: 8px;">‚úèÔ∏è Edit</button>
          <button onclick="deleteIdealEntry(${e.id})" class="delete-btn" style="flex: 1; min-width: 0; padding: 10px; font-size: 0.9rem; height: 40px; border: none; border-radius: 8px;">üóëÔ∏è Delete</button>
        </div>`;
      div.innerHTML = content;
      container.appendChild(div);
    });
  };
}

function loadArchiveEntries() {
  const container = document.getElementById("archiveContainer");
  container.innerHTML = "";
  const tx = db.transaction("entries", "readonly");
  const store = tx.objectStore("entries");
  const req = store.getAll();

  req.onsuccess = () => {
    const entries = req.result;
    const grouped = {};
    const categoryOrder = ["C.S.A", "C.P.E", "CA.P", "L.B.S"];
    entries.forEach(e => {
      if (!grouped[e.category]) grouped[e.category] = [];
      grouped[e.category].push(e);
    });
    
    categoryOrder.forEach(cat => {
      if (selectedCategory && cat !== selectedCategory) return;
      if (!grouped[cat]) return;
      const section = document.createElement("div");
      section.style.marginTop = "30px";
      section.innerHTML = `<h2>${cat}</h2>`;
      grouped[cat].forEach(e => {
        const div = document.createElement("div");
        div.className = "archive-entry";
        let details = "";
        if (e.type === 'reps') {
          details = `Actual: ${e.actual}<br>Ideal: ${e.ideal}`;
        } else if (e.type === 'iso') {
          details = `Actual: ${e.actual} sec<br>Ideal: ${e.ideal} sec`;
        } else if (e.type === 'semi') {
          details = `Actual: ${e.actual}s, Reps: ${e.reps}<br>Ideal: ${e.idealTime}s, Reps: ${e.idealReps}`;
        } else if (e.type === 'jog') {
          details = `Duration: ${e.duration}`;
          if (e.distance) details += `<br>Distance: ${e.distance}`;
          if (e.avgSpeed) details += `<br>Avg Speed: ${e.avgSpeed}`;
          if (e.positions && e.positions.length > 1) {
            details += `<br><button onclick="viewSavedRoute(${e.id})" class="edit-btn" style="margin-top: 8px;">View Route</button>`;
          }
          if (e.routeImage) {
            details += `<img src="${e.routeImage}" class="route-map-image" alt="Route Map">`;
          }
        }
        div.innerHTML = `<strong>${e.name || 'Unnamed'}</strong><br>
                         ${e.score ? `Score: ${e.score}<br>` : ''}
                         ${details}<br>Date: ${e.date}`;
        section.appendChild(div);
      });
      container.appendChild(section);
    });
  };
}

function editEntry(id) {
  const tx = db.transaction("entries", "readonly");
  const store = tx.objectStore("entries");
  const req = store.get(id);

  req.onsuccess = () => {
    const e = req.result;
    if (!e) return;
    editingId = id;

    document.getElementById("type").value = e.type;
    renderFields();
    document.getElementById("category").value = e.category;

    let attempts = 0;
    const maxAttempts = 30;

    function fillFieldsSafely() {
      attempts++;
        const name = document.getElementById("exerciseName");
  const actual = document.getElementById("actualValue");
  const ideal = document.getElementById("idealValue");
      const reps = document.getElementById("reps");
      const idealTime = document.getElementById("idealTime");
      const idealReps = document.getElementById("idealReps");
      const idealDistance = document.getElementById("idealDistance");
      const idealSpeed = document.getElementById("idealSpeed");

      if (e.type === "reps" || e.type === "iso") {
        if (name && actual && ideal) {
          name.value = e.name || "";
          actual.value = e.actual;
          ideal.value = e.ideal;
        } else return retry();
      } else if (e.type === "semi") {
        if (name && actual && reps && idealTime && idealReps) {
          name.value = e.name || "";
          actual.value = e.actual;
          reps.value = e.reps;
          idealTime.value = e.idealTime;
          idealReps.value = e.idealReps;
        } else return retry();
      } else if (e.type === "jog") {
        if (idealDistance && idealSpeed) {
          name.value = e.name || "";
          idealDistance.value = e.idealDistance || "";
          idealSpeed.value = e.idealSpeed || "";
        } else return retry();
      }

      document.getElementById("addEntry").textContent = "Update Entry";
      document.getElementById("cancelEdit").style.display = "inline-block";
    }

    function retry() {
      if (attempts < maxAttempts) {
        setTimeout(fillFieldsSafely, 50);
      }
    }

    setTimeout(fillFieldsSafely, 100);
  };
}
function editIdealEntry(id) {
  const tx = db.transaction("ideals", "readonly");
  const store = tx.objectStore("ideals");
  const req = store.get(id);

  req.onsuccess = () => {
    const e = req.result;
    if (!e) return;

    document.getElementById("idealType").value = e.type;
    renderIdealInputs();
    document.getElementById("idealCategory").value = e.category;
    document.getElementById("idealName").value = e.name;

    if (e.type === "reps") {
      document.getElementById("idealReps").value = e.idealReps;
    } else if (e.type === "iso") {
      document.getElementById("idealTime").value = e.idealTime;
    } else if (e.type === "semi") {
      document.getElementById("idealTime").value = e.idealTime;
      document.getElementById("idealReps").value = e.idealReps;
    } else if (e.type === "jog") {
      document.getElementById("idealDistance").value = e.idealDistance;
      document.getElementById("idealSpeed").value = e.idealSpeed;
    }

    deleteIdealEntry(id, false);
  };
}
function deleteEntry(id) {
  if (!confirm('Are you sure you want to delete this entry?')) return;
  const tx = db.transaction("entries", "readwrite");
  tx.objectStore("entries").delete(id);
  tx.oncomplete = () => {
    loadEntries();
    updateScorePanel();
    updateNameSuggestions();
  };
}
function deleteMastered(id) {
  if (!confirm("Are you sure you want to delete this mastered entry?")) return;
  const tx = db.transaction("mastered", "readwrite");
  tx.objectStore("mastered").delete(id);
  tx.oncomplete = () => loadMasteredEntries();
}

function deleteIdealEntry(id, reload = true) {
  if (reload && !confirm("Are you sure you want to delete this ideal entry?")) return;
  const tx = db.transaction("ideals", "readwrite");
  tx.objectStore("ideals").delete(id);
  if (reload) {
    tx.oncomplete = () => loadIdealEntries();
  }
}

function filterEntries(type) {
  currentFilter = type;
  loadEntries();
  updateScorePanel();
  updateNameSuggestions();
}

function setCategory(cat) {
  selectedCategory = cat;
  const isArchive = document.getElementById("archiveView").style.display === "block";
  const isIdeal = document.getElementById("idealScoreView").style.display === "block";
  const isMastered = document.getElementById("masteredView").style.display === "block";
  const isProgress = document.getElementById("progressView").style.display === "block";

  if (isArchive) {
    loadArchiveEntries();
  } else if (isIdeal) {
    loadIdealEntries();
  } else if (isMastered) {
    loadMasteredEntries();
  } else if (isProgress && currentChartType === 'exercise') {
    renderProgressChart('exercise');
  } else {
    loadEntries();
  }
  updateScorePanel();
}

// Score panel functions
function updateScorePanel() {
  const tx1 = db.transaction("entries", "readonly");
  const store1 = tx1.objectStore("entries");
  const req1 = store1.getAll();

  req1.onsuccess = () => {
    const entries = req1.result;
    const today = new Date().toLocaleDateString();

    const latestPerExercise = {};
    entries.forEach(e => {
      if (e.date === today) {
        const key = e.category + "_" + e.name;
        latestPerExercise[key] = e;
      }
    });

    let p1 = 0, p2 = 0, p3 = 0, p4 = 0;
    let c1 = 0, c2 = 0, c3 = 0, c4 = 0;

    for (const e of Object.values(latestPerExercise)) {
      if (!e.score) continue;
      const score = parseFloat(e.score);
      if (e.category === "C.S.A") { p1 += score; c1++; }
      else if (e.category === "C.P.E") { p2 += score; c2++; }
      else if (e.category === "CA.P") { p3 += score; c3++; }
      else if (e.category === "L.B.S") { p4 += score; c4++; }
    }

    const raw_p1 = p1, raw_p2 = p2, raw_p3 = p3, raw_p4 = p4;

    const avg_p1 = c1 ? p1 / c1 : 0;
    const avg_p2 = c2 ? p2 / c2 : 0;
    const avg_p3 = c3 ? p3 / c3 : 0;
    const avg_p4 = c4 ? p4 / c4 : 0;

    const tx2 = db.transaction("mastered", "readonly");
    const store2 = tx2.objectStore("mastered");
    const req2 = store2.getAll();

    req2.onsuccess = () => {
      const mastered = req2.result;
      let M = 0, a = 0;
      const todayKeys = new Set(Object.keys(latestPerExercise));

      mastered.forEach(e => {
        if (!e.score) return;
        const key = e.category + "_" + e.name;
        const score = parseFloat(e.score);
        M += score;
        if (e.date === today && todayKeys.has(key)) {
          a += score;
        }
      });

      const total = raw_p1 + raw_p2 + raw_p3 + raw_p4 + (M - a);

      let todayEQ = 0;
      if (selectedCategory === "C.S.A") todayEQ = avg_p1;
      else if (selectedCategory === "C.P.E") todayEQ = avg_p2;
      else if (selectedCategory === "CA.P") todayEQ = avg_p3;
      else if (selectedCategory === "L.B.S") todayEQ = avg_p4;

      document.getElementById("todayAvg").textContent = todayEQ.toFixed(2);
      document.getElementById("totalScore").textContent = total.toFixed(2);
    };
  };
}

// Autocomplete functions
function updateNameSuggestions() {
  const tx = db.transaction("entries", "readonly");
  const store = tx.objectStore("entries");
  const req = store.getAll();
  req.onsuccess = () => {
    const seen = new Set();
    nameHistory = req.result
      .filter(e => e.name)
      .map(e => e.name.trim())
      .filter(name => !seen.has(name) && seen.add(name));
  };
}

function showSuggestions(query) {
  const box = document.getElementById("customSuggestions");
  box.innerHTML = "";
  if (!query.trim()) return (box.style.display = "none");

  const matches = nameHistory.filter(name =>
    name.toLowerCase().includes(query.toLowerCase())
  ).slice(0, 5);

  if (!matches.length) return (box.style.display = "none");

  const input = document.getElementById("exerciseName");
  const rect = input.getBoundingClientRect();
  box.style.position = "absolute";
  box.style.top = window.scrollY + rect.bottom + "px";
  box.style.left = rect.left + "px";
  box.style.width = rect.width + "px";
  box.style.display = "block";

  matches.forEach(name => {
    const div = document.createElement("div");
    div.textContent = name;
    div.style.padding = "8px 12px";
    div.style.borderBottom = "1px solid #333";
    div.style.cursor = "pointer";
    div.onclick = () => {
      input.value = name;
      box.style.display = "none";
    };
    div.onmouseover = () => div.style.background = "#333";
    div.onmouseout = () => div.style.background = "transparent";
    box.appendChild(div);
  });
}

window.addEventListener("click", e => {
  const box = document.getElementById("customSuggestions");
  if (!box.contains(e.target) && e.target.id !== "name") {
    box.style.display = "none";
  }
});

// Ideal form handling
document.getElementById("idealForm").addEventListener("submit", function (e) {
  e.preventDefault();
  saveIdealEntry();
});

function saveIdealEntry() {
  if (!db) {
    alert("Database not ready. Please wait a moment and try again.");
    return;
  }
  
  const type = document.getElementById("idealType").value;
  const category = document.getElementById("idealCategory").value;
  const name = document.getElementById("idealName").value.trim();

  if (!type || !category || !name) return alert("Please fill all required fields.");

  const entry = { type, category, name };

  if (type === "reps") {
    const idealReps = +document.getElementById("idealReps").value;
    if (!idealReps || idealReps <= 0) return alert("Please enter a valid ideal reps value.");
    entry.idealReps = idealReps;
  } else if (type === "iso") {
    const idealTime = +document.getElementById("idealTime").value;
    if (!idealTime || idealTime <= 0) return alert("Please enter a valid ideal time value.");
    entry.idealTime = idealTime;
  } else if (type === "semi") {
    const idealTime = +document.getElementById("idealTime").value;
    const idealReps = +document.getElementById("idealReps").value;
    if (!idealTime || !idealReps || idealTime <= 0 || idealReps <= 0) {
      return alert("Please enter valid ideal time and reps values.");
    }
    entry.idealTime = idealTime;
    entry.idealReps = idealReps;
  } else if (type === "jog") {
    const idealDistance = +document.getElementById("idealDistance").value;
    const idealSpeed = +document.getElementById("idealSpeed").value;
    if (!idealDistance || !idealSpeed || idealDistance <= 0 || idealSpeed <= 0) {
      return alert("Please enter valid ideal distance and speed values.");
    }
    entry.idealDistance = idealDistance;
    entry.idealSpeed = idealSpeed;
  }

  console.log('Saving ideal entry:', entry);
  const tx = db.transaction("ideals", "readwrite");
  tx.objectStore("ideals").add(entry);
  tx.oncomplete = () => {
    console.log('Ideal entry saved successfully');
    loadIdealEntries();
    document.getElementById("idealForm").reset();
    document.getElementById("idealFields").innerHTML = "";
  };
  tx.onerror = (e) => {
    console.error('Error saving ideal entry:', e);
  };
}

// Debug function to check ideals in database
function debugIdeals() {
  if (!db) {
    console.log('Database not ready');
    return;
  }
  const tx = db.transaction("ideals", "readonly");
  const store = tx.objectStore("ideals");
  const req = store.getAll();
  
  req.onsuccess = () => {
    console.log('All ideals in database:', req.result);
  };
  req.onerror = () => {
    console.error('Error fetching ideals for debug');
  };
}

// Function to create test ideal data for testing autofill
function createTestIdealData() {
  if (!db) {
    console.log('Database not ready');
    return;
  }
  
  // Clear existing test data first
  const clearTx = db.transaction("ideals", "readwrite");
  const clearStore = clearTx.objectStore("ideals");
  const clearReq = clearStore.clear();
  
  clearReq.onsuccess = () => {
    console.log('Cleared existing ideal data');
    
    const testIdeals = [
      {
        name: 'Push-ups',
        type: 'reps',
        category: 'C.S.A',
        idealReps: 20
      },
      {
        name: 'Plank',
        type: 'iso',
        category: 'C.S.A', 
        idealTime: 60
      },
      {
        name: 'Burpees',
        type: 'semi',
        category: 'C.S.A',
        idealTime: 45,
        idealReps: 10
      },
      {
        name: 'Morning Run',
        type: 'jog',
        category: 'Cardio',
        idealDistance: 5,
        idealSpeed: 10
      }
    ];
    
    const tx = db.transaction("ideals", "readwrite");
    const store = tx.objectStore("ideals");
    
    testIdeals.forEach(ideal => {
      store.add(ideal);
    });
    
    tx.oncomplete = () => {
      console.log('Test ideal data created successfully!');
      console.log('You can now test autofill with: Push-ups, Plank, Burpees, or Morning Run');
      debugIdeals(); // Show what was created
    };
    
    tx.onerror = (e) => {
      console.error('Error adding test data:', e);
    };
  };
}

// Test function to manually trigger autofill
function testAutofill() {
  const exerciseName = prompt('Enter exercise name to test autofill:');
  if (exerciseName) {
    console.log('=== TESTING AUTOFILL FOR:', exerciseName, '===');
    console.log('Current activity type:', document.getElementById('type')?.value);
    console.log('Current category:', document.getElementById('category')?.value);
    console.log('Database ready:', !!db);
    
    // Test the autofill function
    triggerIdealAutofill(exerciseName);
    
    // Check result after a delay
    setTimeout(() => {
      console.log('=== AUTOFILL TEST RESULTS ===');
      const type = document.getElementById('type')?.value;
      const category = document.getElementById('category')?.value;
      const exerciseField = document.getElementById('exerciseName')?.value;
      
      console.log('Activity type after autofill:', type);
      console.log('Category after autofill:', category);
      console.log('Exercise name field value:', exerciseField);
      
      if (type === 'reps') {
        const idealValue = document.getElementById('idealValue')?.value;
        console.log('Ideal reps value:', idealValue);
        if (!idealValue) console.log('‚ùå No ideal value set for reps!');
      } else if (type === 'iso') {
        const idealValue = document.getElementById('idealValue')?.value;
        console.log('Ideal time value:', idealValue);
        if (!idealValue) console.log('‚ùå No ideal value set for iso!');
      } else if (type === 'semi') {
        const idealTime = document.getElementById('idealTime')?.value;
        const idealReps = document.getElementById('idealReps')?.value;
        console.log('Ideal time value:', idealTime);
        console.log('Ideal reps value:', idealReps);
        if (!idealTime || !idealReps) console.log('‚ùå Missing ideal values for semi!');
      } else if (type === 'jog') {
        const idealDistance = document.getElementById('idealDistance')?.value;
        const idealSpeed = document.getElementById('idealSpeed')?.value;
        console.log('Ideal distance value:', idealDistance);
        console.log('Ideal speed value:', idealSpeed);
        if (!idealDistance || !idealSpeed) console.log('‚ùå Missing ideal values for jog!');
      }
      console.log('=== END AUTOFILL TEST ===');
    }, 300);
  }
    }

// Quick test to check database and ideal data status
function checkDatabaseStatus() {
  console.log('üîç Database Status Check:');
  console.log('Database object exists:', !!db);
  
  if (!db) {
    console.log('‚ùå Database not initialized yet');
    return;
  }
  
  try {
    const tx = db.transaction("ideals", "readonly");
    const store = tx.objectStore("ideals");
    const req = store.getAll();
    
    req.onsuccess = () => {
      const ideals = req.result;
      console.log('‚úÖ Database working, found', ideals.length, 'ideal entries');
      if (ideals.length === 0) {
        console.log('üí° No ideal data found. Run createTestIdealData() first');
      } else {
        console.log('Ideal entries:', ideals.map(i => i.name).join(', '));
      }
    };
    
    req.onerror = () => {
      console.log('‚ùå Database query failed');
    };
  } catch (error) {
    console.log('‚ùå Database transaction error:', error);
  }
}
  
  // Comprehensive test for all activity types
function testAllAutofill() {
  if (!db) {
    console.log('Database not ready');
    return;
  }
  
  const tests = [
    { name: 'Push-ups', type: 'reps' },
    { name: 'Plank', type: 'iso' },
    { name: 'Burpees', type: 'semi' },
    { name: 'Morning Run', type: 'jog' }
  ];
  
  let currentTest = 0;
  
  const runNextTest = () => {
    if (currentTest >= tests.length) {
      console.log('üéâ All autofill tests completed!');
      return;
    }
    
    const test = tests[currentTest];
    console.log(`\n=== TEST ${currentTest + 1}: ${test.name} (${test.type}) ===`);
    
    // Set the activity type first
    document.getElementById('type').value = test.type;
    renderFields();
    
    setTimeout(() => {
      // Now test autofill
      triggerIdealAutofill(test.name);
      
      setTimeout(() => {
        const type = document.getElementById('type')?.value;
        console.log(`Type: ${type}`);
        
        let success = false;
        if (test.type === 'reps') {
          const value = document.getElementById('idealValue')?.value;
          console.log(`Ideal reps: ${value}`);
          success = !!value;
        } else if (test.type === 'iso') {
          const value = document.getElementById('idealValue')?.value;
          console.log(`Ideal time: ${value}`);
          success = !!value;
        } else if (test.type === 'semi') {
          const time = document.getElementById('idealTime')?.value;
          const reps = document.getElementById('idealReps')?.value;
          console.log(`Ideal time: ${time}, reps: ${reps}`);
          success = !!time && !!reps;
        } else if (test.type === 'jog') {
          const distance = document.getElementById('idealDistance')?.value;
          const speed = document.getElementById('idealSpeed')?.value;
          console.log(`Ideal distance: ${distance}, speed: ${speed}`);
          success = !!distance && !!speed;
        }
        
        console.log(`Result: ${success ? '‚úÖ SUCCESS' : '‚ùå FAILED'}`);
        
        currentTest++;
        setTimeout(runNextTest, 500);
      }, 200);
    }, 100);
  };
  
  runNextTest();
}
  
  // Test function for smart detection
function testSmartDetection() {
  const exerciseName = prompt('Enter exercise name to test smart detection:');
  if (exerciseName) {
    console.log('Testing smart detection for:', exerciseName);
    detectAndSetExerciseData(exerciseName, false);
  }
}

// Function to create a test ideal entry
function createTestIdeal() {
  if (!db) {
    alert('Database not ready');
    return;
  }
  
  const testEntry = {
    type: 'reps',
    category: 'C.S.A',
    name: 'Test Exercise',
    idealReps: 10
  };
  
  console.log('Creating test ideal entry:', testEntry);
  const tx = db.transaction("ideals", "readwrite");
  tx.objectStore("ideals").add(testEntry);
  tx.oncomplete = () => {
    console.log('Test ideal entry created successfully');
    alert('Test ideal entry created: Test Exercise (reps, C.S.A, 10 reps)');
  };
  tx.onerror = (e) => {
    console.error('Error creating test ideal entry:', e);
  };
}

// Function to create test entry data (for fallback detection)
function createTestEntry() {
  if (!db) {
    alert('Database not ready');
    return;
  }
  
  const testEntry = {
    type: 'iso',
    category: 'Cardio',
    name: 'Plank',
    actualValue: 60,
    idealValue: 120,
    date: new Date().toISOString(),
    score: 50
  };
  
  console.log('Creating test entry:', testEntry);
  const tx = db.transaction("entries", "readwrite");
  tx.objectStore("entries").add(testEntry);
  tx.oncomplete = () => {
    console.log('Test entry created successfully');
    alert('Test entry created: Plank (iso, Cardio)');
  };
  tx.onerror = (e) => {
    console.error('Error creating test entry:', e);
  };
}

// Function to create test complex task
function createTestComplexTask() {
  const testTask = {
    id: Date.now(),
    commands: ['test task', 'run test'],
    actions: 'show progress, toggle dark mode',
    feedback: 'Test task completed successfully'
  };
  
  complexTasks.push(testTask);
  localStorage.setItem('complexTasks', JSON.stringify(complexTasks));
  updateComplexTasksDisplay();
  
  alert('Test complex task created! Try saying "test task" or "run test"');
  console.log('Created test complex task:', testTask);
}

// Function to create test complex task for semi-isometric exercises
function createSemiIsometricTask() {
  const semiTask = {
    id: Date.now() + 1,
    commands: ['setup plank workout', 'prepare plank'],
    actions: 'set activity type to semi, set exercise name to plank, set ideal time to 60, set ideal reps to 3, set actual value to 45',
    feedback: 'Plank workout setup completed - ready to log!'
  };
  
  complexTasks.push(semiTask);
  localStorage.setItem('complexTasks', JSON.stringify(complexTasks));
  updateComplexTasksDisplay();
  
  alert('Semi-isometric test task created! Try saying "setup plank workout" - it will set both ideal time (60s) and ideal reps (3)');
  console.log('Created semi-isometric test task:', semiTask);
  }

// Instructions for testing autofill
function showAutofillTestInstructions() {
  console.log(`
üß™üì± MOBILE AUTOFILL TESTING INSTRUCTIONS:

üì± FOR MOBILE USERS:
1. Quick test everything:
   runCompleteAutofillTest()

2. Direct test (bypasses typing):
   testDirectAutofill()

3. Test specific exercises:
   testDirectAutofill('Plank', 'iso')
   testDirectAutofill('Burpees', 'semi')

üíª FOR DESKTOP USERS:
1. Step by step testing:
   a) createTestIdealData()
   b) testManualTyping()

2. Manual UI testing:
   - Select activity type (reps/iso/semi/jog)
   - Type exercise name: "Push-ups", "Plank", "Burpees", or "Morning Run"
   - Ideal values should auto-populate

üîß TROUBLESHOOTING:
- If typing doesn't work, try: testDirectAutofill()
- Check database: checkDatabaseStatus()
- View data: debugIdeals()

Expected behavior:
‚úÖ Mobile: Autofill on blur/change events
‚úÖ Desktop: Autofill during typing
‚úÖ All activity types supported
  `);
}
// Complete autofill test workflow
function runCompleteAutofillTest() {
  console.log('üöÄüì± Running complete autofill test workflow...');
  console.log('Mobile device:', isMobile());
  
  // Step 1: Check database
  checkDatabaseStatus();
  
  setTimeout(() => {
    // Step 2: Create test data
    console.log('\nüìù Creating test data...');
    createTestIdealData();
    
    setTimeout(() => {
      // Step 3: Test based on device type
      if (isMobile()) {
        console.log('\nüì± Testing mobile autofill...');
        testMobileAutofill();
      } else {
        console.log('\nüñäÔ∏è Testing manual typing...');
        testManualTyping();
      }
    }, 1000);
  }, 500);
}
// Simple immediate autofill function for testing
function testDirectAutofill(exerciseName = 'Push-ups', activityType = 'reps') {
  console.log(`üì±‚ö° Testing immediate autofill: ${exerciseName} (${activityType})`);
  
  // Set form state
  document.getElementById('type').value = activityType;
  renderFields();
  
  setTimeout(() => {
    // Set exercise name
    const nameField = document.getElementById('exerciseName');
    if (nameField) nameField.value = exerciseName;
    
    // Trigger autofill immediately without debounce
    const currentType = document.getElementById('type')?.value;
    const currentCategory = document.getElementById('category')?.value || 'C.S.A';
    
    console.log('Calling checkAndAutofillIdeal directly...');
    checkAndAutofillIdeal(exerciseName, currentType, currentCategory);
    
    // Check result
    setTimeout(() => {
      let success = false;
      if (activityType === 'reps') {
        const value = document.getElementById('idealValue')?.value;
        console.log('Result - ideal reps:', value);
        success = !!value;
      } else if (activityType === 'iso') {
        const value = document.getElementById('idealValue')?.value;
        console.log('Result - ideal time:', value);
        success = !!value;
      }
      
      console.log(success ? '‚úÖ Direct autofill SUCCESS!' : '‚ùå Direct autofill FAILED!');
    }, 100);
  }, 200);
}

// Simulate manual typing to test autofill
function testManualTyping() {
  console.log('üñäÔ∏èüì± Testing manual typing simulation...');
  console.log('Mobile device detected:', isMobile());
  
  // Set activity type to reps
  document.getElementById('type').value = 'reps';
  renderFields();
  
  setTimeout(() => {
    console.log('üìù Form rendered, now simulating typing "Push-ups"');
    const exerciseField = document.getElementById('exerciseName');
    if (exerciseField) {
      exerciseField.value = 'Push-ups';
      console.log('üíª Triggering multiple events for mobile compatibility...');
      
      // Trigger all possible events for mobile compatibility
      triggerIdealAutofill('Push-ups');
      
      // Also try triggering the events directly
      setTimeout(() => {
        triggerIdealAutofill('Push-ups');
      }, 50);
      
      setTimeout(() => {
        const idealField = document.getElementById('idealValue');
        console.log('üéØ Final result - ideal field value:', idealField?.value);
        if (idealField?.value) {
          console.log('‚úÖ Manual typing autofill SUCCESS!');
        } else {
          console.log('‚ùå Manual typing autofill FAILED!');
          console.log('Trying immediate autofill...');
          checkAndAutofillIdeal('Push-ups', 'reps', 'C.S.A');
        }
      }, isMobile() ? 200 : 1000);
    } else {
      console.log('‚ùå Exercise name field not found!');
    }
  }, 100);
}

// Mobile-specific immediate autofill test
function testMobileAutofill() {
  console.log('üì± Mobile autofill test starting...');
  
  // Ensure we have test data
  createTestIdealData();
  
  setTimeout(() => {
    // Set form to reps type
    document.getElementById('type').value = 'reps';
    renderFields();
    
    setTimeout(() => {
      // Directly test the autofill function
      console.log('Testing direct autofill...');
      checkAndAutofillIdeal('Push-ups', 'reps', 'C.S.A');
      
      setTimeout(() => {
        const idealField = document.getElementById('idealValue');
        console.log('Mobile test result:', idealField?.value);
      }, 100);
    }, 100);
  }, 500);
}
  
  // Function to debug complex tasks
function debugComplexTasks() {
  console.log('Current complex tasks:', complexTasks);
  console.log('Complex tasks in localStorage:', JSON.parse(localStorage.getItem('complexTasks') || '[]'));
  
  if (complexTasks.length === 0) {
    alert('No complex tasks found. Create one using the "Create Test Task" button or add one manually in settings.');
  } else {
    alert(`Found ${complexTasks.length} complex tasks. Check console for details.`);
  }
}

function showAutofillFeedback() {
  // Add a visual indicator that autofill has occurred
  console.log('Autofill completed - showing visual feedback');
  const nameField = document.getElementById('exerciseName');
  if (nameField) {
    const originalBorder = nameField.style.border;
    nameField.style.border = '2px solid #4CAF50';
    nameField.style.boxShadow = '0 0 5px rgba(76, 175, 80, 0.5)';
    
    setTimeout(() => {
      nameField.style.border = originalBorder;
      nameField.style.boxShadow = '';
    }, 1000);
  }
}
// Debounce timer for autofill to prevent excessive calls during typing
let autofillDebounceTimer = null;

// Mobile detection
function isMobile() {
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
         ('ontouchstart' in window) || 
         (navigator.maxTouchPoints > 0);
}

function triggerIdealAutofill(name) {
  console.log('üî•üì± triggerIdealAutofill called with name:', name, 'length:', name?.length, 'mobile:', isMobile());
  
  // Clear previous debounce timer
  if (autofillDebounceTimer) {
    clearTimeout(autofillDebounceTimer);
  }
  
  if (!db) {
    console.log('‚ùå Database not ready, skipping autofill');
    return; // Wait for database to be ready
  }
  
  // Additional check to ensure database is actually working
  try {
    const testTx = db.transaction("ideals", "readonly");
    if (!testTx) {
      console.log('‚ùå Database transaction failed, skipping autofill');
      return;
    }
  } catch (error) {
    console.log('‚ùå Database error, skipping autofill:', error);
    return;
  }
  if (!name.trim()) {
    console.log('Empty name, skipping autofill');
    return;
  }
  
  // Debounce the autofill to avoid excessive calls during typing
  autofillDebounceTimer = setTimeout(() => {
    console.log('‚è∞ Debounce triggered - Starting ideal autofill for:', name.trim());
    
    // For manual typing, only autofill ideal values for current activity type
    // Don't change the activity type to avoid disrupting user input
    const currentType = document.getElementById('type')?.value;
    const currentCategory = document.getElementById('category')?.value;
    
    console.log('üìã Current form state - Type:', currentType, 'Category:', currentCategory);
    console.log('üóÑÔ∏è Database ready:', !!db);
    
    if (currentType) {
      console.log('‚úÖ Manual autofill for current type:', currentType);
      checkAndAutofillIdeal(name.trim(), currentType, currentCategory);
    } else {
      console.log('‚ùå No current type selected, skipping autofill');
    }
  }, isMobile() ? 100 : 300); // Shorter delay for mobile devices
}

// Function for voice commands that can change activity type and autofill
function detectAndSetExerciseDataForVoice(exerciseName) {
  console.log('detectAndSetExerciseDataForVoice called with:', exerciseName);
  
  // This function is used by voice commands and can change activity type
  detectAndSetExerciseData(exerciseName, true);
}
  
  function detectAndSetExerciseData(exerciseName, isVoiceCommand = false) {
  console.log('detectAndSetExerciseData called with:', exerciseName, 'isVoiceCommand:', isVoiceCommand);
  
  // Validation function for ideal match data
  const validateIdealMatch = (match) => {
    if (!match || !match.name || !match.type) return false;
    
    // Check if the match has the required ideal values for its type
    switch (match.type) {
      case 'reps':
        return match.idealReps !== undefined && match.idealReps !== null;
      case 'iso':
        return match.idealTime !== undefined && match.idealTime !== null;
      case 'semi':
        return (match.idealTime !== undefined && match.idealTime !== null) &&
               (match.idealReps !== undefined && match.idealReps !== null);
      case 'jog':
        return (match.idealDistance !== undefined && match.idealDistance !== null) &&
               (match.idealSpeed !== undefined && match.idealSpeed !== null);
      default:
        return false;
    }
  };
  
  // First check for ideal data, then fall back to previous entries
  const idealsReq = db.transaction("ideals", "readonly").objectStore("ideals").getAll();
  
  idealsReq.onsuccess = () => {
    const ideals = idealsReq.result;
    console.log('Fetched ideals from database:', ideals);
    const idealMatch = ideals.find(e => e.name?.toLowerCase() === exerciseName.toLowerCase());
    console.log('Found ideal match:', idealMatch);

    if (idealMatch && validateIdealMatch(idealMatch)) {
      // Use ideal data for type and category
      console.log('Using ideal data - Type:', idealMatch.type, 'Category:', idealMatch.category);
      const typeField = document.getElementById('type');
      const categoryField = document.getElementById('category');
      
      if (typeField && typeField.value !== idealMatch.type) {
        typeField.value = idealMatch.type;
        renderFields(); // Re-render fields for the new type
        
        // Wait for fields to render before filling values
        setTimeout(() => {
          if (categoryField) categoryField.value = idealMatch.category;
          
          // Set exercise name if not already set (mainly for voice commands)
          const nameField = document.getElementById('exerciseName');
          if (nameField && nameField.value !== exerciseName) {
            nameField.value = exerciseName;
          }
          
          checkAndAutofillIdeal(exerciseName, idealMatch.type, idealMatch.category);
          showAutofillFeedback();
          
          if (isVoiceCommand) {
            speakFeedback(`${getVoiceCommands().logExerciseFeedback}: ${exerciseName} as ${idealMatch.type} for ${idealMatch.category}`);
          }
        }, 100);
      } else {
        if (categoryField) categoryField.value = idealMatch.category;
        
        // Set exercise name if not already set (mainly for voice commands)
        const nameField = document.getElementById('exerciseName');
        if (nameField && nameField.value !== exerciseName) {
          nameField.value = exerciseName;
        }
        
        checkAndAutofillIdeal(exerciseName, idealMatch.type, idealMatch.category);
        showAutofillFeedback();
        
        if (isVoiceCommand) {
          speakFeedback(`${getVoiceCommands().logExerciseFeedback}: ${exerciseName} as ${idealMatch.type} for ${idealMatch.category}`);
        }
      }
    } else {
      // Fall back to previous entries detection
      if (idealMatch) {
        console.log('Found ideal match but it has invalid data structure:', idealMatch);
      }
      console.log('No valid ideal found, checking previous entries...');
      const tx = db.transaction("entries", "readonly");
      const store = tx.objectStore("entries");
      const req = store.getAll();
      
      req.onsuccess = () => {
        const entries = req.result;
        const matchingEntries = entries.filter(e => 
          e.name && e.name.toLowerCase().includes(exerciseName.toLowerCase())
        );
        console.log('Found matching entries:', matchingEntries);
        
        let detectedType = 'reps'; // default
        let detectedCategory = 'C.S.A'; // default
        
        if (matchingEntries.length > 0) {
          // Use the most recent matching entry's type and category
          const recent = matchingEntries[matchingEntries.length - 1];
          detectedType = recent.type || 'reps';
          detectedCategory = recent.category || 'C.S.A';
          console.log('Using data from recent entry - Type:', detectedType, 'Category:', detectedCategory);
        }
        
        // Set the form values
        const typeField = document.getElementById('type');
        const categoryField = document.getElementById('category');
        
        if (typeField && typeField.value !== detectedType) {
          typeField.value = detectedType;
          renderFields();
          
          setTimeout(() => {
            if (categoryField) categoryField.value = detectedCategory;
            
            // Set exercise name if not already set (mainly for voice commands)
            const nameField = document.getElementById('exerciseName');
            if (nameField && nameField.value !== exerciseName) {
              nameField.value = exerciseName;
            }
            
            checkAndAutofillIdeal(exerciseName, detectedType, detectedCategory);
            
            if (isVoiceCommand) {
              speakFeedback(`${getVoiceCommands().logExerciseFeedback}: ${exerciseName} as ${detectedType} for ${detectedCategory}`);
            }
          }, 100);
        } else {
          if (categoryField) categoryField.value = detectedCategory;
          
          // Set exercise name if not already set (mainly for voice commands)
          const nameField = document.getElementById('exerciseName');
          if (nameField && nameField.value !== exerciseName) {
            nameField.value = exerciseName;
          }
          
          checkAndAutofillIdeal(exerciseName, detectedType, detectedCategory);
          
          if (isVoiceCommand) {
            speakFeedback(`${getVoiceCommands().logExerciseFeedback}: ${exerciseName} as ${detectedType} for ${detectedCategory}`);
          }
        }
      };
      
      req.onerror = () => {
        console.error('Error fetching entries for type detection');
      };
    }
  };

  idealsReq.onerror = () => {
    console.error('Error fetching ideals for detection');
  };
}

function checkAndAutofillIdeal(name, type, category) {
  console.log('üéØ checkAndAutofillIdeal called with:', name, type, category);
  if (!db) return;
  
  try {
    const tx = db.transaction("ideals", "readonly");
    const store = tx.objectStore("ideals");
    const req = store.getAll();

    req.onsuccess = () => {
      const ideals = req.result;
      console.log('checkAndAutofillIdeal: searching in ideals:', ideals);
      
      // First try to find exact match with type and category
      let match = ideals.find(e =>
        e.name?.toLowerCase() === name.toLowerCase() &&
        e.type === type &&
        e.category === category
      );
      
      // If no exact match, try to find by name and type only
      if (!match) {
        match = ideals.find(e =>
          e.name?.toLowerCase() === name.toLowerCase() &&
          e.type === type
        );
      }
      
      // If still no match, try to find any ideal with the same name
      if (!match) {
        match = ideals.find(e =>
          e.name?.toLowerCase() === name.toLowerCase()
        );
        
        // If found, but it's for a different activity type, don't autofill
        // (this avoids confusion)
        if (match && match.type !== type) {
          console.log('Found ideal for different activity type:', match.type, 'vs', type);
          return;
        }
      }
      
      console.log('checkAndAutofillIdeal: found match:', match);

      if (!match) {
        console.log('No match found in checkAndAutofillIdeal');
        return;
      }

              try {
        console.log('Autofilling values for type:', type, 'with data:', match);
        
        // Add a small delay to ensure DOM elements are fully rendered
        const fillIdealValues = () => {
          console.log('üí´ fillIdealValues called for type:', type, 'with match:', match);
          if (type === "reps") {
            const field = document.getElementById("idealValue");
            console.log('üéØ Found idealValue field:', !!field, 'setting to:', match.idealReps);
            if (field && match.idealReps !== undefined) {
              field.value = match.idealReps;
              console.log('‚úÖ Successfully set idealValue to:', match.idealReps);
            } else {
              console.log('‚ùå Could not set reps value - field exists:', !!field, 'value defined:', match.idealReps !== undefined);
            }
          } else if (type === "iso") {
            const field = document.getElementById("idealValue");
            console.log('Found idealValue field:', field, 'setting to:', match.idealTime);
            if (field && match.idealTime !== undefined) {
              field.value = match.idealTime;
              console.log('Successfully set idealValue to:', match.idealTime);
            }
          } else if (type === "semi") {
            const timeField = document.getElementById("idealTime");
            const repsField = document.getElementById("idealReps");
            console.log('Found time field:', timeField, 'reps field:', repsField);
            if (timeField && match.idealTime !== undefined) {
              timeField.value = match.idealTime;
              console.log('Successfully set idealTime to:', match.idealTime);
            }
            if (repsField && match.idealReps !== undefined) {
              repsField.value = match.idealReps;
              console.log('Successfully set idealReps to:', match.idealReps);
            }
          } else if (type === "jog") {
            const distanceField = document.getElementById("idealDistance");
            const speedField = document.getElementById("idealSpeed");
            console.log('Found distance field:', distanceField, 'speed field:', speedField);
            if (distanceField && match.idealDistance !== undefined) {
              distanceField.value = match.idealDistance;
              console.log('Successfully set idealDistance to:', match.idealDistance);
            }
            if (speedField && match.idealSpeed !== undefined) {
              speedField.value = match.idealSpeed;
              console.log('Successfully set idealSpeed to:', match.idealSpeed);
            }
          }
        };

        // Try to fill immediately, but if fields don't exist, retry after a short delay
        fillIdealValues();
        
        // Backup attempt in case fields weren't ready
        setTimeout(() => {
          fillIdealValues();
        }, 50);
        
      } catch (error) {
        console.error('Error autofilling ideal values:', error);
      }
    };
    
    req.onerror = () => {
      console.error('Error fetching ideals for autofill');
    };
  } catch (error) {
    console.error('Error in checkAndAutofillIdeal:', error);
  }
}

// Progress chart functions
function switchChartType(type) {
  currentChartType = type;
  const dropdown = document.getElementById("exerciseDropdown");
  dropdown.style.display = type === 'exercise' ? 'block' : 'none';
  renderProgressChart(type);
}

function renderProgressChart(type = "total", from = null, to = null, exerciseName = null) {
  const tx = db.transaction("entries", "readonly");
  const store = tx.objectStore("entries");
  const req = store.getAll();
  
  req.onsuccess = () => {
    const data = req.result;
    const scoreMap = {};
    const filtered = data.filter(e => {
      const d = new Date(e.date);
      if (from && d < new Date(from)) return false;
      if (to && d > new Date(to)) return false;
      if (type === "exercise" && exerciseName && e.name !== exerciseName) return false;
      if (type === "exercise" && selectedCategory && e.category !== selectedCategory) return false;
      return !!e.score;
    });

    // Update exercise dropdown
    const exercises = [...new Set(data
      .filter(e => !selectedCategory || e.category === selectedCategory)
      .map(e => e.name)
    )].filter(Boolean).sort();
    
    const dropdown = document.getElementById("exerciseDropdown");
    dropdown.innerHTML = '<option value="">Select an exercise</option>' + 
      exercises.map(name => `<option value="${name}" ${name === exerciseName ? 'selected' : ''}>${name}</option>`).join('');
    
    dropdown.onchange = () => {
      renderProgressChart('exercise', null, null, dropdown.value);
    };

    filtered.forEach(e => {
      const dateKey = new Date(e.date).toLocaleDateString();
      if (!scoreMap[dateKey]) scoreMap[dateKey] = [];
      scoreMap[dateKey].push(parseFloat(e.score));
    });

    const sortedDays = Object.keys(scoreMap).sort((a, b) => new Date(a) - new Date(b));
    const labels = sortedDays;
    const scores = sortedDays.map(day => {
      const list = scoreMap[day];
      const avg = list.reduce((a, b) => a + b, 0) / list.length;
      return avg.toFixed(2);
    });

      const ctx = document.getElementById("progressChart").getContext("2d");
  if (window.progressChartInstance) window.progressChartInstance.destroy();
  
  // Check if Chart.js is available
  if (typeof Chart === 'undefined') {
    document.getElementById("progressChart").innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">üìä Charts require internet connection<br>Your data is still being tracked!</div>';
    return;
  }
  
  window.progressChartInstance = new Chart(ctx, {
      type: 'line',
      data: {
        labels,
        datasets: [{
          label: type === "exercise" ? `${exerciseName || 'Exercise'} Score` : "Total Score",
          data: scores,
          fill: false,
          borderColor: '#00e5ff',
          backgroundColor: '#00e5ff',
          tension: 0.3
        }]
      },
      options: {
        responsive: true,
        plugins: {
          legend: {
            labels: { color: "#fff" }
          }
        },
        scales: {
          x: { ticks: { color: "#fff" } },
          y: { ticks: { color: "#fff" }, beginAtZero: true }
        }
      }
    });
  };
}
// Voice recognition with proper cleanup
function startVoiceRecognition() {
  if (!('webkitSpeechRecognition' in window || 'SpeechRecognition' in window)) {
    alert("Your browser does not support speech recognition");
    return;
  }

  if (listening) {
    stopVoiceRecognition();
    return;
  }

  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  recognizer = new SpeechRecognition();
  
  // Register for cleanup
  if (window.memoryManager) {
    window.memoryManager.registerVoiceRecognizer(recognizer);
  }
  recognizer.continuous = true;
  recognizer.interimResults = false;
  recognizer.lang = "en-US";

  recognizer.onstart = function () {
    listening = true;
    updateVoiceStatus("Listening...", "listening");
    
    // Play a subtle, short beep that won't interfere with voice feedback
    try {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      
      // Register audio context for cleanup
      if (window.memoryManager) {
        window.memoryManager.registerAudioContext(audioContext);
      }
      
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
      gainNode.gain.setValueAtTime(0.1, audioContext.currentTime); // Very low volume
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1); // Quick fade
      
      oscillator.start();
      oscillator.stop(audioContext.currentTime + 0.1); // Very short duration
      
      // Clean up audio context after use
      setTimeout(() => {
        try {
          audioContext.close();
          if (window.memoryManager) {
            window.memoryManager.audioContexts.delete(audioContext);
          }
        } catch (e) {
          console.warn('Error closing audio context:', e);
        }
      }, 200);
    } catch (error) {
      console.log('Audio context not available for beep');
    }
  };

  recognizer.onresult = function (event) {
    const transcript = event.results[event.results.length - 1][0].transcript.trim().toLowerCase();
    const commands = getVoiceCommands();
    
    addVoiceMessage('user', transcript);
    
    // Small delay before processing command to ensure voice message is shown
    setTimeout(() => {
      if (transcript.includes(commands.startTimer)) {
        startTimer();
        speakFeedback(commands.startTimerFeedback, 'startTimer');
      } else if (transcript.includes(commands.stopTimer)) {
        stopTimer();
        speakFeedback(commands.stopTimerFeedback, 'stopTimer');
      } else if (transcript.includes(commands.resetTimer)) {
        resetTimer();
        speakFeedback(commands.resetTimerFeedback);
      } else if (transcript.includes(commands.startJog)) {
        startJogging();
        speakFeedback(commands.startJogFeedback);
      } else if (transcript.includes(commands.stopJog)) {
        stopJogging();
        speakFeedback(commands.stopJogFeedback);
      } else if (transcript.includes(commands.logExercise)) {
        const exerciseName = transcript.split(commands.logExercise)[1].trim();
        handleSmartExerciseLogging(exerciseName);
      } else if (transcript.includes(commands.startTimerFor)) {
        const timeText = transcript.split(commands.startTimerFor)[1].trim();
        handleTimerForDuration(timeText);
      } else if (transcript.includes(commands.addEntry)) {
        const addBtn = document.getElementById('addEntry');
        if (addBtn) {
          addBtn.click();
          speakFeedback(commands.addEntryFeedback, 'addEntry');
        }
      } else if (transcript.includes(commands.setActualReps)) {
        const repsValue = transcript.split(commands.setActualReps)[1].trim();
          const actualField = window.getElement('actualValue');
  if (actualField) {
    actualField.value = repsValue;
    speakFeedback(`${commands.setActualRepsFeedback} ${repsValue}`);
  }
      } else if (transcript.includes(commands.showProgress)) {
        showProgressView();
        speakFeedback(`${commands.navigationFeedback} progress view`);
      } else if (transcript.includes(commands.showArchive)) {
        showArchiveView();
        speakFeedback(`${commands.navigationFeedback} archive view`);
      } else if (transcript.includes(commands.openSettings)) {
        showSettingsView();
        speakFeedback(`${commands.navigationFeedback} settings`);
      } else if (transcript.includes(commands.goHome)) {
        // Go back to main view
        hideProgressView();
        hideMasteredView();
        hideIdealScoreView();
        hideArchiveView();
        hideSettingsView();
        speakFeedback(`${commands.navigationFeedback} home`);
      } else {
        // Check complex tasks
        let commandFound = false;
        console.log('Checking complex tasks. Available tasks:', complexTasks.length);
        for (const task of complexTasks) {
          console.log('Checking task:', task.commands, 'against transcript:', transcript);
          // Check if transcript matches any of the task's commands
          const matchingCommand = task.commands ? 
            task.commands.find(cmd => transcript.includes(cmd.toLowerCase())) :
            (transcript.includes(task.command ? task.command.toLowerCase() : task.primaryCommand));
            
          if (matchingCommand) {
            console.log('Found matching command:', matchingCommand, 'executing task:', task);
            executeComplexTask(task);
            commandFound = true;
            break;
          }
        }
        
        // Check automation sequences
        if (!commandFound) {
          for (const automation of automationSequences) {
            // Check if transcript matches any of the automation's commands
            const matchingCommand = automation.commands ? 
              automation.commands.find(cmd => transcript.includes(cmd.toLowerCase())) :
              (transcript.includes(automation.command ? automation.command.toLowerCase() : automation.name.toLowerCase()));
              
            if (matchingCommand) {
              executeAutomationSequence(automation);
              commandFound = true;
              break;
            }
          }
        }
        
        if (!commandFound) {
          // No command recognized
          speakFeedback("Command not recognized. Please try again or check your voice settings.");
        }
      }
    }, 50); // Small delay for voice message display
  };

  recognizer.onerror = function (event) {
    console.error('Speech recognition error', event.error);
    updateVoiceStatus("Voice Error", "error");
    setTimeout(() => {
      updateVoiceStatus("Voice: Ready", "ready");
    }, 2000);
  };

  recognizer.onend = function () {
    if (listening) {
      // Don't auto-restart to prevent command loops
      setTimeout(() => {
        if (listening) recognizer.start();
      }, 1000);
    } else {
      stopVoiceRecognition();
    }
  };
  
  recognizer.start();
}

function stopVoiceRecognition() {
  if (recognizer) {
    try {
      recognizer.stop();
      recognizer.abort(); // Ensure complete cleanup
      
      // Unregister from memory manager
      if (window.memoryManager) {
        window.memoryManager.voiceRecognizers.delete(recognizer);
      }
      
      recognizer = null; // Clear reference
    } catch (err) {
      console.error('Error stopping speech recognition:', err);
    }
  }
  listening = false;
  updateVoiceStatus("Voice: Ready", "ready");
}

function updateVoiceStatus(text, state) {
  const indicator = window.getElement("voiceIndicator");
  const statusText = window.getElement("voiceStatusText");
  
  if (!indicator || !statusText) return;
  
  // Remove all classes
  indicator.className = "indicator";
  
  // Add appropriate class based on state
  if (state === "ready") indicator.classList.add("ready");
  else if (state === "listening") indicator.classList.add("listening");
  else if (state === "feedback") indicator.classList.add("feedback");
  else if (state === "error") indicator.classList.add("error");
  
  statusText.textContent = text;
}

function addVoiceMessage(role, text) {
  const container = document.getElementById("voiceFeedbackContainer");
  if (!container) return;
  
  // Clean the text
  text = text.replace(/\{.*?\}/g, '').trim();
  if (!text) return;
  
  // Check for duplicates
  const existingMessages = container.querySelectorAll('.voice-message');
  const isDuplicate = Array.from(existingMessages).some(msg => 
    msg.textContent.trim() === text && msg.classList.contains(role)
  );
  
  if (isDuplicate) return;
  
  const message = document.createElement("div");
  message.className = `voice-message ${role}`;
  message.textContent = text;
  
  container.appendChild(message);
  container.scrollTop = container.scrollHeight;
  container.style.display = "block";
  
  // Reset the hide timer whenever new message is added
  resetPopupTimer(container);
}

// Import/Export functions
function exportEntriesAsJSON() {
  const data = {};
  const tx = db.transaction(["entries", "mastered", "ideals"], "readonly");

  tx.objectStore("entries").getAll().onsuccess = e => {
    data.entries = e.target.result;

    tx.objectStore("mastered").getAll().onsuccess = e2 => {
      data.mastered = e2.target.result;

      tx.objectStore("ideals").getAll().onsuccess = e3 => {
        data.ideals = e3.target.result;
        
        // Include voice feedback settings and custom recordings
        data.feedbackSettings = feedbackSettings;
        data.customRecordings = customRecordings;
        
        // Include other localStorage settings
        data.voiceFeedbackInterval = voiceFeedbackInterval;
        data.voiceFeedbackEnabled = voiceFeedbackEnabled;

        const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "performa_backup.json";
        a.click();
      };
    };
  };
}

function exportEntriesAsCSV() {
  const tx1 = db.transaction("entries", "readonly").objectStore("entries").getAll();
  const tx2 = db.transaction("mastered", "readonly").objectStore("mastered").getAll();

  tx1.onsuccess = () => {
    tx2.onsuccess = () => {
      const entries = tx1.result.map(e => ({ ...e, source: "entries" }));
      const mastered = tx2.result.map(e => ({ ...e, source: "mastered" }));
      const combined = [...entries, ...mastered];
      if (!combined.length) return alert("No entries to export.");

      const keys = Array.from(new Set(combined.flatMap(obj => Object.keys(obj))));
      const csv = [keys.join(",")].concat(
        combined.map(row => keys.map(k => JSON.stringify(row[k] || "")).join(","))
      ).join("\n");

      const blob = new Blob([csv], { type: "text/csv" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "performa_entries_backup.csv";
      a.click();
      URL.revokeObjectURL(url);
    };
  };
}

function importFromJSON() {
  const fileInput = document.getElementById("importFile");
  if (!fileInput.files.length) return alert("Please select a file first.");

  const reader = new FileReader();
  reader.onload = function (e) {
    try {
      const data = JSON.parse(e.target.result);
      const tx = db.transaction(["entries", "mastered", "ideals"], "readwrite");

      if (Array.isArray(data.entries)) {
        const store = tx.objectStore("entries");
        data.entries.forEach(entry => store.add(entry));
      }
      if (Array.isArray(data.mastered)) {
        const store = tx.objectStore("mastered");
        data.mastered.forEach(entry => store.add(entry));
      }
      if (Array.isArray(data.ideals)) {
        const store = tx.objectStore("ideals");
        data.ideals.forEach(entry => store.add(entry));
      }

      // Restore voice feedback settings and custom recordings
      if (data.feedbackSettings) {
        feedbackSettings = data.feedbackSettings;
        localStorage.setItem('feedbackSettings', JSON.stringify(feedbackSettings));
      }
      if (data.customRecordings) {
        customRecordings = data.customRecordings;
        localStorage.setItem('customRecordings', JSON.stringify(customRecordings));
      }
      if (data.voiceFeedbackInterval) {
        voiceFeedbackInterval = data.voiceFeedbackInterval;
        localStorage.setItem('voiceFeedbackInterval', voiceFeedbackInterval);
      }
      if (typeof data.voiceFeedbackEnabled === 'boolean') {
        voiceFeedbackEnabled = data.voiceFeedbackEnabled;
        localStorage.setItem('voiceFeedbackEnabled', voiceFeedbackEnabled);
      }

      tx.oncomplete = () => {
        alert("Import successful! Voice recordings and settings have been restored.");
        loadEntries();
        loadIdealEntries();
        loadMasteredEntries();
        // Refresh the voice feedback UI
        initializeFeedbackSystem();
        updateCustomRecordingsList();
      };

      tx.onerror = () => {
        alert("Error importing data. Please check the file format.");
      };
    } catch (err) {
      alert("Invalid JSON file.");
      console.error('Import error:', err);
    }
  };
  reader.onerror = () => {
    alert("Error reading file. Please try again.");
  };
  reader.readAsText(fileInput.files[0]);
}

// Streak Tracking Functions
function updateStreak() {
  const today = new Date().toISOString().split('T')[0];
  const lastLogDate = localStorage.getItem('lastLogDate') || null;
  let currentStreak = parseInt(localStorage.getItem('currentStreak')) || 0;
  let bestStreak = parseInt(localStorage.getItem('bestStreak')) || 0;
  
  if (!lastLogDate) {
    // First time logging
    currentStreak = 1;
  } else {
    const lastDate = new Date(lastLogDate);
    const todayDate = new Date(today);
    const diffTime = todayDate - lastDate;
    const diffDays = diffTime / (1000 * 60 * 60 * 24);
    
    if (diffDays === 0) {
      // Same day, don't change streak
      return;
    } else if (diffDays === 1) {
      // Consecutive day, increase streak
      currentStreak++;
    } else {
      // Gap in days, reset streak
      currentStreak = 1;
    }
  }
  
  // Update best streak if needed
  if (currentStreak > bestStreak) {
    bestStreak = currentStreak;
    localStorage.setItem('bestStreak', bestStreak);
  }
  
  // Save streak data
  localStorage.setItem('currentStreak', currentStreak);
  localStorage.setItem('lastLogDate', today);
  
  // Update streak summary
  updateStreakSummary();
}

function updateStreakSummary() {
  const currentStreak = parseInt(localStorage.getItem('currentStreak')) || 0;
  const bestStreak = parseInt(localStorage.getItem('bestStreak')) || 0;
  const lastLogDate = localStorage.getItem('lastLogDate');
  
  if (!lastLogDate) return;
  
  const lastDate = new Date(lastLogDate);
  const startDate = new Date(lastDate);
  startDate.setDate(startDate.getDate() - (currentStreak - 1));
  
  let summaryText = '';
  if (currentStreak > 1) {
    summaryText = `Logged every day from ${startDate.toLocaleDateString()} to ${lastDate.toLocaleDateString()} (${currentStreak} days)`;
  } else {
    summaryText = `Logged on ${lastDate.toLocaleDateString()}`;
  }
  
  localStorage.setItem('streakSummary', summaryText);
}

function renderStreakCalendar() {
  const calendarEl = document.getElementById('streakCalendar');
  if (!calendarEl) return;
  
  calendarEl.innerHTML = '';
  
  const today = new Date();
  const daysInMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0).getDate();
  const firstDay = new Date(today.getFullYear(), today.getMonth(), 1).getDay();
  
  // Add empty cells for days before the first of the month
  for (let i = 0; i < firstDay; i++) {
    const emptyCell = document.createElement('div');
    emptyCell.style.height = '20px';
    calendarEl.appendChild(emptyCell);
  }
  
  // Add cells for each day of the month
  for (let day = 1; day <= daysInMonth; day++) {
    const dateStr = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
    const hasActivity = localStorage.getItem(`log_${dateStr}`) === 'true';
    
    const dayCell = document.createElement('div');
    dayCell.style.textAlign = 'center';
    dayCell.style.padding = '5px';
    dayCell.style.borderRadius = '50%';
    dayCell.style.width = '20px';
    dayCell.style.height = '20px';
    dayCell.style.fontSize = '0.8rem';
    dayCell.style.display = 'flex';
    dayCell.style.alignItems = 'center';
    dayCell.style.justifyContent = 'center';
    
    if (hasActivity) {
      dayCell.innerHTML = 'üî•';
      dayCell.style.color = '#ff5722';
    } else {
      dayCell.textContent = day;
      dayCell.style.color = '#888';
    }
    
    if (day === today.getDate()) {
      dayCell.style.border = '1px solid #00e5ff';
    }
    
    calendarEl.appendChild(dayCell);
  }
}
function showStreakTracker() {
  document.getElementById("mainContent").style.display = "none";
  document.getElementById("streakView").style.display = "block";
  
  // Update streak display
  const currentStreak = parseInt(localStorage.getItem('currentStreak')) || 0;
  const bestStreak = parseInt(localStorage.getItem('bestStreak')) || 0;
  const lastLogDate = localStorage.getItem('lastLogDate');
  const streakSummary = localStorage.getItem('streakSummary') || 'No streak data yet';
  
  document.getElementById('currentStreak').textContent = currentStreak;
  document.getElementById('bestStreak').textContent = bestStreak;
  document.getElementById('lastLogDate').textContent = lastLogDate ? new Date(lastLogDate).toLocaleDateString() : 'Never';
  document.getElementById('streakSummary').textContent = streakSummary;
  
  renderStreakCalendar();
}

function hideStreakView() {
  document.getElementById("streakView").style.display = "none";
  document.getElementById("mainContent").style.display = "block";
}















// Offline detection
function updateOnlineStatus() {
  const offlineNotification = document.getElementById('offlineNotification');
  if (!navigator.onLine) {
    offlineNotification.style.display = 'block';
  } else {
    offlineNotification.style.display = 'none';
  }
}

// Popup behavior functions
let popupHideTimer = null;

function resetPopupTimer(container) {
  if (popupHideTimer) clearTimeout(popupHideTimer);
  popupHideTimer = setTimeout(() => {
    if (container && container.style.display === "block") {
      container.style.display = "none";
    }
  }, 8000); // Reduced from 15 seconds to 8 seconds
}

function setupPopupBehavior() {
  const container = document.getElementById("voiceFeedbackContainer");
  if (!container) return;
  
  document.addEventListener('click', (e) => {
    if (!container.contains(e.target) && 
        e.target.id !== 'aiVoiceBtn' && 
        !e.target.closest('.voice-status') &&
        !e.target.closest('#timer') &&
        !e.target.classList.contains('timer') &&
        container.style.display === "block") {
      container.style.display = "none";
    }
  });
  
  container.addEventListener('scroll', () => resetPopupTimer(container));
  container.addEventListener('mouseenter', () => clearTimeout(popupHideTimer));
  container.addEventListener('mouseleave', () => resetPopupTimer(container));
}



// handleAddEntryClick function removed - using direct event listener instead

// Fallback database initialization
function initializeDatabase() {
  if (!window.indexedDB) {
    alert('Your browser does not support database storage. Please use a modern browser.');
    return;
  }
  
  const request = indexedDB.open("PerformaDB", 3);
  
  request.onupgradeneeded = function(e) {
    const database = e.target.result;
    if (!database.objectStoreNames.contains("entries")) {
      database.createObjectStore("entries", { keyPath: "id", autoIncrement: true });
    }
    if (!database.objectStoreNames.contains("mastered")) {
      database.createObjectStore("mastered", { keyPath: "id", autoIncrement: true });
    }
    if (!database.objectStoreNames.contains("ideals")) {
      database.createObjectStore("ideals", { keyPath: "id", autoIncrement: true });
    }
  };
  
  request.onsuccess = function(e) {
    db = e.target.result;
    console.log('Fallback database initialization successful');
    // Now try the addEntry function
    addEntry();
  };
  
  request.onerror = function(e) {
    console.error('Fallback database initialization failed:', e.target.error);
    alert('Database initialization failed. Please refresh the page and try again.');
  };
}

  // Check external library availability
  function checkExternalLibraries() {
    const status = {
      chartjs: typeof Chart !== 'undefined',
      leaflet: typeof L !== 'undefined', 
      html2canvas: typeof html2canvas !== 'undefined'
    };
    return status;
  }

// Initialize the app
let appInitialized = false;
function initializeApp() {
  if (appInitialized) {
    return;
  }
  appInitialized = true;
  showDebugInfo('üöÄ InitializeApp started');
  
  try {
    // Check external libraries (after a small delay to let them load)
    setTimeout(checkExternalLibraries, 500);
    showDebugInfo('üìö External libs check scheduled');
    
    // Check if dark mode is enabled
    if (localStorage.getItem("darkMode") === "on") {
      document.body.classList.add("dark-mode");
      const darkToggle = document.getElementById("darkModeToggle");
      if (darkToggle) darkToggle.checked = true;
    }
    showDebugInfo('üåô Dark mode settings loaded');
    
    // Initialize voice settings
    voiceFeedbackEnabled = localStorage.getItem("voiceFeedbackEnabled") !== "off";
    const voiceToggle = document.getElementById("voiceFeedbackToggle");
    if (voiceToggle) voiceToggle.checked = voiceFeedbackEnabled;
    showDebugInfo('üé§ Voice settings loaded');
  } catch (error) {
    showDebugInfo('‚ùå Settings error: ' + error.message);
  }
  
  try {
    // Initialize voice feedback interval
voiceFeedbackInterval = parseInt(localStorage.getItem("voiceFeedbackInterval")) || 30;
// üöÄ PWA Service Worker Registration
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js')
      .then((registration) => {
        console.log('‚úÖ PWA Service Worker registered:', registration.scope);
        
        // Enhanced persistent storage for PWA
        if ('storage' in navigator && 'persist' in navigator.storage) {
          navigator.storage.persist().then((persistent) => {
            if (persistent) {
              console.log('‚úÖ PWA persistent storage granted - data will be preserved');
            } else {
              console.log('‚ö†Ô∏è PWA persistent storage denied - data may be evicted');
            }
          });
        }
        
        // Background sync registration
        if ('serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype) {
          // Register for background sync
          registration.sync.register('backup-data').then(() => {
            console.log('üì¶ Background sync registered for data backup');
          }).catch((error) => {
            console.log('Background sync registration failed:', error);
          });
        }
        
        // Listen for service worker messages
        navigator.serviceWorker.addEventListener('message', (event) => {
          if (event.data.type === 'BACKUP_COMPLETED') {
            console.log('‚úÖ Background backup completed:', event.data.timestamp);
          }
          if (event.data.type === 'RECORDINGS_SYNCED') {
            console.log('üéôÔ∏è Voice recordings synced:', event.data.timestamp);
          }
        });
        
      })
      .catch((error) => {
        console.error('‚ùå Service Worker registration failed:', error);
      });
  });
}
    const intervalInput = document.getElementById("voiceFeedbackInterval");
    if (intervalInput) intervalInput.value = voiceFeedbackInterval;
    
    // Initialize GPS tracking
    gpsTrackingEnabled = localStorage.getItem("gpsTrackingEnabled") !== "off";
    const gpsToggle = document.getElementById("gpsTrackingToggle");
    if (gpsToggle) gpsToggle.checked = gpsTrackingEnabled;
    
    // Initialize route preview
    routePreviewEnabled = localStorage.getItem("routePreviewEnabled") !== "off";
    const routeToggle = document.getElementById("routePreviewToggle");
    if (routeToggle) routeToggle.checked = routePreviewEnabled;
    
    showDebugInfo('‚öôÔ∏è More settings loaded');
    
    // Load voice settings
    loadVoiceSettings();
    showDebugInfo('üîä Voice system loaded');
    
    // Update complex tasks display
    updateComplexTasksDisplay();
    showDebugInfo('üìã Complex tasks updated');
  } catch (error) {
    showDebugInfo('‚ùå Config error: ' + error.message);
  }
  
  // Initialize IndexedDB
  showDebugInfo('üóÑÔ∏è Checking IndexedDB support...');
  if (!window.indexedDB) {
    showDebugInfo('‚ùå IndexedDB not supported!');
    alert('Your browser does not support IndexedDB. Please use a modern browser.');
    return;
  }
  
  showDebugInfo('üóÉÔ∏è Opening database...');
  const request = indexedDB.open("PerformaDB", 3);
  
  request.onupgradeneeded = function(e) {
    showDebugInfo('‚¨ÜÔ∏è Upgrading database...');
    const database = e.target.result;
    
    if (!database.objectStoreNames.contains("entries")) {
      database.createObjectStore("entries", { keyPath: "id", autoIncrement: true });
      showDebugInfo('üìù Created entries store');
    }
    
    if (!database.objectStoreNames.contains("mastered")) {
      database.createObjectStore("mastered", { keyPath: "id", autoIncrement: true });
      showDebugInfo('üèÜ Created mastered store');
    }
    
    if (!database.objectStoreNames.contains("ideals")) {
      database.createObjectStore("ideals", { keyPath: "id", autoIncrement: true });
      showDebugInfo('üí° Created ideals store');
    }
    showDebugInfo('‚úÖ Database upgrade complete');
  };
  
  request.onsuccess = function(e) {
    db = e.target.result;
    showDebugInfo('üíæ Database initialized!');
    
    // Wait a moment to ensure database is fully ready
    setTimeout(() => {
      // Ensure DOM is ready before loading data
      const loadData = () => {
        showDebugInfo('üîÑ Starting data load...');
        showDebugInfo('DOM: ' + document.readyState);
        showDebugInfo('Container: ' + !!document.getElementById('entries'));
        showDebugInfo('DB ready: ' + !!db);
        
        try {
          showDebugInfo('üìö Loading entries...');
          loadEntries();
          showDebugInfo('üèÜ Loading mastered...');
          loadMasteredEntries();
          showDebugInfo('üí° Loading ideals...');
          loadIdealEntries();
          updateNameSuggestions();
          updateScorePanel();
          updateStreak();
          showDebugInfo('‚úÖ Init complete!');
        } catch (error) {
          showDebugInfo('‚ùå Error: ' + error.message);
        }
      };
      
      // If DOM is already loaded, load immediately, otherwise wait
      if (document.readyState === 'complete' || document.readyState === 'interactive') {
        loadData();
      } else {
        document.addEventListener('DOMContentLoaded', loadData);
        // Fallback timeout
        setTimeout(loadData, 300);
      }
    }, 100); // Give database 100ms to be fully ready
  };
  
  request.onerror = function(e) {
    showDebugInfo('‚ùå DB Error: ' + e.target.error);
    console.error("Database error:", e.target.error);
  };
  
  request.onblocked = function(e) {
    showDebugInfo('üö´ DB Blocked - close other tabs');
  };
  
  // Set up event listeners
  const addEntryBtn = document.getElementById('addEntry');
  if (addEntryBtn && !addEntryBtn.hasAttribute('data-listener-added')) {
    addEntryBtn.addEventListener('click', function(e) {
      e.preventDefault();
      e.stopPropagation();
      addEntry();
    });
    addEntryBtn.setAttribute('data-listener-added', 'true');
  }
  document.getElementById('voiceFeedbackInterval').addEventListener('change', function() {
    voiceFeedbackInterval = parseInt(this.value) || 30;
    localStorage.setItem("voiceFeedbackInterval", voiceFeedbackInterval);
  });
  
      // Initialize individual feedback system
    initializeFeedbackSystem();
    
    // Set up automation tracking for all elements
    setupMainFormTracking();
    
    // Set up offline detection
    window.addEventListener('online', updateOnlineStatus);
    window.addEventListener('offline', updateOnlineStatus);
    updateOnlineStatus();
    
    // Set up popup behavior
    setupPopupBehavior();
    
    // Initialize timer display
    updateTimerDisplay();
}

// Try multiple initialization methods
window.addEventListener('load', () => {
  // Create debug info early if it doesn't exist
  if (!document.getElementById('debugInfo')) {
    const debugDiv = document.createElement('div');
    debugDiv.id = 'debugInfo';
    debugDiv.style.cssText = 'position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.8); color: white; padding: 10px; border-radius: 5px; font-size: 12px; max-width: 200px; z-index: 9999;';
    debugDiv.innerHTML = '<div style="font-weight: bold;">Debug Info:</div><div id="debugText">üìÑ Page loaded - starting init</div>';
    document.body.appendChild(debugDiv);
  } else {
    showDebugInfo('üìÑ Page loaded - starting init');
  }
  initializeApp();
});
window.addEventListener('DOMContentLoaded', () => {
  if (typeof showDebugInfo === 'function') {
    showDebugInfo('üìã DOM loaded - starting init');
  }
  initializeApp();
});

// Fallback initialization after 2 seconds
setTimeout(function() {
  if (!db) {
    showDebugInfo('‚è∞ Fallback init triggered');
    initializeApp();
  } else {
    showDebugInfo('‚úÖ DB already exists, no fallback needed');
  }
}, 2000);

// Clean up on page unload
window.addEventListener('beforeunload', () => {
  if (recognizer) {
    recognizer.stop();
    recognizer = null;
  }
});

// Service Worker Registration
if ('serviceWorker' in navigator) {
  window.addEventListener('load', async () => {
    try {
      const registration = await navigator.serviceWorker.register('./sw.js');
      console.log('üöÄ Performa PWA: Service Worker registered successfully:', registration.scope);
      
      // Handle service worker updates
      registration.addEventListener('updatefound', () => {
        const newWorker = registration.installing;
        newWorker.addEventListener('statechange', () => {
          if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
            // Show update notification
            if (confirm('üîÑ New version available! Restart to update Performa Tracker?')) {
              newWorker.postMessage({ type: 'SKIP_WAITING' });
              window.location.reload();
            }
          }
        });
      });
      
      // Listen for service worker messages with enhanced offline handling
      navigator.serviceWorker.addEventListener('message', event => {
        console.log('üí¨ Message from Service Worker:', event.data);
        const { type, message, version } = event.data;
        
        switch (type) {
          case 'SYNC_COMPLETE':
            console.log('‚úÖ Data sync completed');
            showNotification('‚úÖ Data synchronized successfully', 'success');
            break;
            
          case 'SYNC_FAILED':
            console.log('‚ùå Data sync failed');
            showNotification('‚ö†Ô∏è Sync failed - will retry when online', 'warning');
            break;
            
          case 'OFFLINE_MODE':
            console.log('üì± App running in offline mode');
            showOfflineIndicator(message);
            break;
            
          case 'SW_ACTIVATED':
            console.log(`üöÄ Service Worker v${version} activated`);
            break;
            
          case 'SW_ERROR':
            console.warn('‚ö†Ô∏è Service Worker error:', message);
            break;
            
          default:
            console.log('Unknown message from Service Worker:', event.data);
        }
      });
      
    } catch (error) {
      console.error('‚ùå Performa PWA: Service Worker registration failed:', error);
    }
  });
  
  // Handle service worker controlled
  navigator.serviceWorker.addEventListener('controllerchange', () => {
    console.log('üîÑ Performa PWA: Service Worker controller changed');
    window.location.reload();
  });
}

// Enhanced Offline Notification System
function showOfflineIndicator(message = 'Some features might not work offline') {
  // Remove any existing offline indicator
  const existingIndicator = document.querySelector('.offline-indicator');
  if (existingIndicator) {
    existingIndicator.remove();
  }
  
  // Create offline indicator
  const indicator = document.createElement('div');
  indicator.className = 'offline-indicator';
  indicator.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    background: linear-gradient(135deg, #ff9800, #f57c00);
    color: white;
    padding: 12px 20px;
    text-align: center;
    z-index: 10001;
    font-size: 14px;
    font-weight: 500;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    transform: translateY(-100%);
    transition: transform 0.3s ease-in-out;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px;
  `;
  
  indicator.innerHTML = `
    <span style="display: flex; align-items: center; gap: 8px;">
      <span style="font-size: 18px;">üì±</span>
      <span>${message}</span>
    </span>
    <button id="hideOfflineBtn" style="
      background: rgba(255,255,255,0.2);
      color: white;
      border: 1px solid rgba(255,255,255,0.3);
      padding: 6px 12px;
      border-radius: 16px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 500;
      transition: background 0.2s;
    ">Hide</button>
  `;
  
  document.body.appendChild(indicator);
  
  // Animate in
  setTimeout(() => {
    indicator.style.transform = 'translateY(0)';
  }, 100);
  
  // Hide button functionality
  const hideBtn = document.getElementById('hideOfflineBtn');
  hideBtn.onmouseover = () => hideBtn.style.background = 'rgba(255,255,255,0.3)';
  hideBtn.onmouseout = () => hideBtn.style.background = 'rgba(255,255,255,0.2)';
  hideBtn.onclick = () => hideOfflineIndicator();
  
  // Auto-hide after 10 seconds
  const autoHideTimer = setTimeout(() => {
    hideOfflineIndicator();
  }, 10000);
  
  // Store timer reference for potential cancellation
  indicator.dataset.autoHideTimer = autoHideTimer;
  
  // Adjust body padding to compensate for fixed indicator
  document.body.style.paddingTop = indicator.offsetHeight + 'px';
}

function hideOfflineIndicator() {
  const indicator = document.querySelector('.offline-indicator');
  if (indicator) {
    // Clear auto-hide timer
    if (indicator.dataset.autoHideTimer) {
      clearTimeout(parseInt(indicator.dataset.autoHideTimer));
    }
    
    // Animate out
    indicator.style.transform = 'translateY(-100%)';
    
    setTimeout(() => {
      indicator.remove();
      // Reset body padding
      document.body.style.paddingTop = '';
    }, 300);
  }
}

// General notification system for other app messages
function showNotification(message, type = 'info', duration = 5000) {
  const notification = document.createElement('div');
  notification.className = `app-notification notification-${type}`;
  
  const colors = {
    success: { bg: '#4caf50', border: '#45a049' },
    warning: { bg: '#ff9800', border: '#f57c00' },
    error: { bg: '#f44336', border: '#d32f2f' },
    info: { bg: '#2196f3', border: '#1976d2' }
  };
  
  const color = colors[type] || colors.info;
  
  notification.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background: ${color.bg};
    color: white;
    padding: 12px 16px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 10000;
    max-width: 300px;
    font-size: 14px;
    font-weight: 500;
    opacity: 0;
    transform: translateX(100%);
    transition: all 0.3s ease;
    cursor: pointer;
    border-left: 4px solid ${color.border};
  `;
  
  notification.textContent = message;
  notification.onclick = () => {
    notification.style.opacity = '0';
    notification.style.transform = 'translateX(100%)';
    setTimeout(() => notification.remove(), 300);
  };
  
  document.body.appendChild(notification);
  
  // Animate in
  setTimeout(() => {
    notification.style.opacity = '1';
    notification.style.transform = 'translateX(0)';
  }, 100);
  
  // Auto-remove
  setTimeout(() => {
    if (notification.parentNode) {
      notification.style.opacity = '0';
      notification.style.transform = 'translateX(100%)';
      setTimeout(() => notification.remove(), 300);
    }
  }, duration);
}

// Online/Offline Detection
window.addEventListener('online', () => {
  console.log('üåê Connection restored');
  hideOfflineIndicator();
  showNotification('üåê Connection restored', 'success');
  
  // Request background sync when back online
  if ('serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype) {
    navigator.serviceWorker.ready.then(registration => {
      return registration.sync.register('sync-exercise-data');
    }).catch(err => console.log('Background sync registration failed:', err));
  }
});

window.addEventListener('offline', () => {
  console.log('üì± Connection lost - switching to offline mode');
  showOfflineIndicator('You\'re offline. Some features may be limited.');
});

// Check if app was launched in offline mode (from URL parameter)
if (window.location.search.includes('offline=true')) {
  document.addEventListener('DOMContentLoaded', () => {
    showOfflineIndicator('Running in offline mode');
  });
}

// PWA Install prompt
let deferredPrompt;
window.addEventListener('beforeinstallprompt', (e) => {
  console.log('üì± Performa PWA: Install prompt triggered');
  e.preventDefault();
  deferredPrompt = e;
  
  // Show custom install button
  const installBtn = document.createElement('button');
  installBtn.style.cssText = `
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: #00796b;
    color: white;
    border: none;
    padding: 12px 16px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    z-index: 1000;
    transition: all 0.3s ease;
  `;
  installBtn.innerHTML = 'üì± Install App';
  installBtn.onmouseover = () => installBtn.style.background = '#004d40';
  installBtn.onmouseout = () => installBtn.style.background = '#00796b';
  installBtn.onclick = async () => {
    if (deferredPrompt) {
      deferredPrompt.prompt();
      const { outcome } = await deferredPrompt.userChoice;
      console.log(`üì± Install outcome: ${outcome}`);
      deferredPrompt = null;
      installBtn.remove();
    }
  };
  document.body.appendChild(installBtn);
  
  // Auto-hide after 15 seconds
  setTimeout(() => {
    if (installBtn.parentNode) {
      installBtn.style.opacity = '0';
      setTimeout(() => installBtn.remove(), 300);
    }
  }, 15000);
});

// Track app install
window.addEventListener('appinstalled', () => {
  console.log('üéâ Performa PWA: App installed successfully');
  deferredPrompt = null;
});

// Splash Screen Management
function hideSplashScreen() {
  const splashScreen = document.getElementById('splashScreen');
  if (splashScreen) {
    console.log('üé® Hiding splash screen');
    splashScreen.style.opacity = '0';
    setTimeout(() => {
      splashScreen.style.display = 'none';
      // Remove from DOM to free memory
      splashScreen.remove();
    }, 500);
  }
}

// Hide splash screen when app is ready
function initializeSplashScreen() {
  console.log('üé® Initializing splash screen');
  
  // Minimum display time for splash screen (2 seconds)
  const minDisplayTime = 2000;
  const startTime = Date.now();
  
  // Wait for critical resources to load
  const checkAppReady = () => {
    const isDbReady = !!window.db;
    const isDOMReady = document.readyState === 'complete';
    const isTimerReady = !!document.getElementById('timer');
    const isFormReady = !!document.getElementById('form');
    
    const appReady = isDbReady && isDOMReady && isTimerReady && isFormReady;
    const timeElapsed = Date.now() - startTime;
    
    console.log('üîç App readiness check:', {
      dbReady: isDbReady,
      domReady: isDOMReady,
      timerReady: isTimerReady,
      formReady: isFormReady,
      timeElapsed: timeElapsed
    });
    
    if (appReady && timeElapsed >= minDisplayTime) {
      console.log('‚úÖ App fully ready - hiding splash screen');
      hideSplashScreen();
    } else {
      // Check again in 100ms
      setTimeout(checkAppReady, 100);
    }
  };
  
  // Start checking after a short delay
  setTimeout(checkAppReady, 500);
  
  // Failsafe: hide splash screen after maximum 8 seconds
  setTimeout(() => {
    console.log('‚è∞ Splash screen timeout - force hiding');
    hideSplashScreen();
  }, 8000);
}

// Initialize splash screen management when DOM is loaded
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initializeSplashScreen);
} else {
  initializeSplashScreen();
}

// Hide offline notification
function hideOfflineNotification() {
  const notification = document.getElementById('offlineNotification');
  if (notification) {
    notification.style.opacity = '0';
    setTimeout(() => {
      notification.style.display = 'none';
    }, 300);
  }
}

// Handle URL parameters for shortcuts
window.addEventListener('load', () => {
  const urlParams = new URLSearchParams(window.location.search);
  const action = urlParams.get('action');
  
  if (action) {
    console.log('üîó Performa PWA: Handling shortcut action:', action);
    setTimeout(() => {
      switch (action) {
        case 'log':
          // Focus on exercise logging
          document.getElementById('exerciseName')?.focus();
          break;
        case 'timer':
          // Start timer
          startTimer();
          break;
        case 'progress':
          // Open progress view
          showProgressView();
          break;
        case 'jog':
          // Start jogging
          startJogging();
          break;
        default:
          console.log('Unknown action:', action);
      }
    }, 1000);
  }
});
// Service Worker Registration for PWA
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js')
      .then((registration) => {
        console.log('‚úÖ Service Worker registered successfully:', registration.scope);
        
        // Check for updates
        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing;
          if (newWorker) {
            newWorker.addEventListener('statechange', () => {
              if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                // New update available
                if (confirm('üì± New app update available! Install now?')) {
                  newWorker.postMessage({ type: 'SKIP_WAITING' });
                  window.location.reload();
                }
              }
            });
          }
        });
        
        // Listen for messages from service worker
        navigator.serviceWorker.addEventListener('message', (event) => {
          console.log('üì® Message from Service Worker:', event.data);
          
          if (event.data.type === 'BACKUP_COMPLETED') {
            console.log('‚úÖ Background backup completed at:', event.data.timestamp);
          }
          
          if (event.data.type === 'RECORDINGS_SYNCED') {
            console.log('üéôÔ∏è Voice recordings synced at:', event.data.timestamp);
          }
        });
        
        // Request persistent storage for PWA
        if ('storage' in navigator && 'persist' in navigator.storage) {
          navigator.storage.persist().then((persistent) => {
            if (persistent) {
              console.log('‚úÖ PWA persistent storage granted');
            } else {
              console.log('‚ö†Ô∏è PWA persistent storage denied');
            }
          });
        }
        
      })
      .catch((error) => {
        console.error('‚ùå Service Worker registration failed:', error);
      });
  });
}

// Enhanced Data Persistence System for Mobile App-like Storage
class PerformaDataManager {
  constructor() {
    this.dbName = 'PerformaTrackerDB';
    this.dbVersion = 3;
    this.db = null;
    this.isOffline = !navigator.onLine;
    this.pendingSyncs = [];
    this.init();
  }
  
  async init() {
    try {
      await this.openDB();
      await this.requestPersistentStorage();
      console.log('üíæ Performa Data Manager initialized successfully');
    } catch (error) {
      console.error('‚ùå Failed to initialize data manager:', error);
    }
  }
  
  async openDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.dbVersion);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve(this.db);
      };
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        
        // Create object stores for different data types
        
        // Workout sessions store
        if (!db.objectStoreNames.contains('workouts')) {
          const workoutStore = db.createObjectStore('workouts', { 
            keyPath: 'id', 
            autoIncrement: true 
          });
          workoutStore.createIndex('date', 'date', { unique: false });
          workoutStore.createIndex('type', 'type', { unique: false });
          workoutStore.createIndex('syncStatus', 'syncStatus', { unique: false });
        }
        
        // Exercise data store
        if (!db.objectStoreNames.contains('exercises')) {
          const exerciseStore = db.createObjectStore('exercises', { 
            keyPath: 'id', 
            autoIncrement: true 
          });
          exerciseStore.createIndex('workoutId', 'workoutId', { unique: false });
          exerciseStore.createIndex('exerciseType', 'exerciseType', { unique: false });
        }
        
        // GPS tracking data store
        if (!db.objectStoreNames.contains('gpsData')) {
          const gpsStore = db.createObjectStore('gpsData', { 
            keyPath: 'id', 
            autoIncrement: true 
          });
          gpsStore.createIndex('sessionId', 'sessionId', { unique: false });
          gpsStore.createIndex('timestamp', 'timestamp', { unique: false });
        }
        
        // User preferences and settings store
        if (!db.objectStoreNames.contains('settings')) {
          const settingsStore = db.createObjectStore('settings', { 
            keyPath: 'key' 
          });
        }
        
        // Voice recordings store
        if (!db.objectStoreNames.contains('voiceData')) {
          const voiceStore = db.createObjectStore('voiceData', { 
            keyPath: 'id', 
            autoIncrement: true 
          });
          voiceStore.createIndex('type', 'type', { unique: false });
          voiceStore.createIndex('date', 'date', { unique: false });
        }
        
        // Offline actions queue store
        if (!db.objectStoreNames.contains('offlineQueue')) {
          const queueStore = db.createObjectStore('offlineQueue', { 
            keyPath: 'id', 
            autoIncrement: true 
          });
          queueStore.createIndex('timestamp', 'timestamp', { unique: false });
          queueStore.createIndex('action', 'action', { unique: false });
        }
        
        console.log('üíæ Database upgraded to version', this.dbVersion);
      };
    });
  }
  
  async requestPersistentStorage() {
    if ('storage' in navigator && 'persist' in navigator.storage) {
      try {
        const isPersistent = await navigator.storage.persist();
        if (isPersistent) {
          console.log('üíæ Persistent storage granted');
        } else {
          console.log('‚ö†Ô∏è Persistent storage denied');
        }
        
        // Check storage quota
        if ('estimate' in navigator.storage) {
          const estimate = await navigator.storage.estimate();
          const usedMB = (estimate.usage / (1024 * 1024)).toFixed(2);
          const quotaMB = (estimate.quota / (1024 * 1024)).toFixed(2);
          console.log(`üíæ Storage: ${usedMB}MB used of ${quotaMB}MB available`);
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Persistent storage request failed:', error);
      }
    }
  }
  
  // Save workout data with offline support
  async saveWorkout(workoutData) {
    try {
      const workout = {
        ...workoutData,
        id: workoutData.id || Date.now(),
        date: workoutData.date || new Date().toISOString(),
        syncStatus: this.isOffline ? 'pending' : 'synced',
        lastModified: new Date().toISOString()
      };
      
      const transaction = this.db.transaction(['workouts'], 'readwrite');
      const store = transaction.objectStore('workouts');
      await this.promisifyRequest(store.put(workout));
      
      console.log('üíæ Workout saved to local storage:', workout.id);
      
      if (this.isOffline) {
        await this.queueOfflineAction('saveWorkout', workout);
      }
      
      return workout;
    } catch (error) {
      console.error('‚ùå Failed to save workout:', error);
      throw error;
    }
  }
  
  // Save exercise data
  async saveExercise(exerciseData) {
    try {
      const exercise = {
        ...exerciseData,
        id: exerciseData.id || Date.now() + Math.random(),
        timestamp: exerciseData.timestamp || new Date().toISOString(),
        syncStatus: this.isOffline ? 'pending' : 'synced'
      };
      
      const transaction = this.db.transaction(['exercises'], 'readwrite');
      const store = transaction.objectStore('exercises');
      await this.promisifyRequest(store.put(exercise));
      
      console.log('üíæ Exercise saved:', exercise.id);
      return exercise;
    } catch (error) {
      console.error('‚ùå Failed to save exercise:', error);
      throw error;
    }
  }
  
  // Save GPS tracking data
  async saveGPSData(gpsData) {
    try {
      const transaction = this.db.transaction(['gpsData'], 'readwrite');
      const store = transaction.objectStore('gpsData');
      await this.promisifyRequest(store.put(gpsData));
      
      console.log('üìç GPS data saved');
      return gpsData;
    } catch (error) {
      console.error('‚ùå Failed to save GPS data:', error);
      throw error;
    }
  }
  
  // Save user settings
  async saveSetting(key, value) {
    try {
      const setting = { key, value, lastModified: new Date().toISOString() };
      const transaction = this.db.transaction(['settings'], 'readwrite');
      const store = transaction.objectStore('settings');
      await this.promisifyRequest(store.put(setting));
      
      console.log('‚öôÔ∏è Setting saved:', key);
      return setting;
    } catch (error) {
      console.error('‚ùå Failed to save setting:', error);
      throw error;
    }
  }
  
  // Get all workouts
  async getWorkouts(limit = 50) {
    try {
      const transaction = this.db.transaction(['workouts'], 'readonly');
      const store = transaction.objectStore('workouts');
      const index = store.index('date');
      const request = index.openCursor(null, 'prev');
      
      const workouts = [];
      return new Promise((resolve, reject) => {
        request.onsuccess = (event) => {
          const cursor = event.target.result;
          if (cursor && workouts.length < limit) {
            workouts.push(cursor.value);
            cursor.continue();
          } else {
            resolve(workouts);
          }
        };
        request.onerror = () => reject(request.error);
      });
    } catch (error) {
      console.error('‚ùå Failed to get workouts:', error);
      return [];
    }
  }
  
  // Get user setting
  async getSetting(key, defaultValue = null) {
    try {
      const transaction = this.db.transaction(['settings'], 'readonly');
      const store = transaction.objectStore('settings');
      const result = await this.promisifyRequest(store.get(key));
      
      return result ? result.value : defaultValue;
    } catch (error) {
      console.error('‚ùå Failed to get setting:', error);
      return defaultValue;
    }
  }
  
  // Queue offline actions for later sync
  async queueOfflineAction(action, data) {
    try {
      const queueItem = {
        action,
        data,
        timestamp: new Date().toISOString(),
        attempts: 0
      };
      
      const transaction = this.db.transaction(['offlineQueue'], 'readwrite');
      const store = transaction.objectStore('offlineQueue');
      await this.promisifyRequest(store.add(queueItem));
      
      console.log('üì§ Action queued for sync:', action);
    } catch (error) {
      console.error('‚ùå Failed to queue offline action:', error);
    }
  }
  
  // Process offline queue when back online
  async processOfflineQueue() {
    try {
      const transaction = this.db.transaction(['offlineQueue'], 'readwrite');
      const store = transaction.objectStore('offlineQueue');
      const request = store.getAll();
      
      const queueItems = await this.promisifyRequest(request);
      
      for (const item of queueItems) {
        try {
          // Process each queued action
          console.log('üîÑ Processing offline action:', item.action);
          
          // Update sync status of related data
          if (item.action === 'saveWorkout') {
            await this.updateWorkoutSyncStatus(item.data.id, 'synced');
          }
          
          // Remove processed item from queue
          await this.promisifyRequest(store.delete(item.id));
          
        } catch (error) {
          console.error('‚ùå Failed to process offline action:', error);
          
          // Update attempt count
          item.attempts++;
          if (item.attempts < 3) {
            await this.promisifyRequest(store.put(item));
          } else {
            // Remove after 3 failed attempts
            await this.promisifyRequest(store.delete(item.id));
          }
        }
      }
      
      console.log('‚úÖ Offline queue processed');
    } catch (error) {
      console.error('‚ùå Failed to process offline queue:', error);
    }
  }
  
  // Update workout sync status
  async updateWorkoutSyncStatus(workoutId, status) {
    try {
      const transaction = this.db.transaction(['workouts'], 'readwrite');
      const store = transaction.objectStore('workouts');
      const workout = await this.promisifyRequest(store.get(workoutId));
      
      if (workout) {
        workout.syncStatus = status;
        workout.lastModified = new Date().toISOString();
        await this.promisifyRequest(store.put(workout));
      }
    } catch (error) {
      console.error('‚ùå Failed to update sync status:', error);
    }
  }
  
  // Clear all data (for reset functionality)
  async clearAllData() {
    try {
      const storeNames = ['workouts', 'exercises', 'gpsData', 'voiceData', 'offlineQueue'];
      const transaction = this.db.transaction(storeNames, 'readwrite');
      
      for (const storeName of storeNames) {
        const store = transaction.objectStore(storeName);
        await this.promisifyRequest(store.clear());
      }
      
      console.log('üóëÔ∏è All data cleared');
    } catch (error) {
      console.error('‚ùå Failed to clear data:', error);
    }
  }
  
  // Export data for backup
  async exportData() {
    try {
      const data = {
        workouts: await this.getWorkouts(1000),
        settings: await this.getAllSettings(),
        exportDate: new Date().toISOString(),
        version: this.dbVersion
      };
      
      const blob = new Blob([JSON.stringify(data, null, 2)], {
        type: 'application/json'
      });
      
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `performa-backup-${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      console.log('üì§ Data exported successfully');
    } catch (error) {
      console.error('‚ùå Failed to export data:', error);
    }
  }
  
  async getAllSettings() {
    try {
      const transaction = this.db.transaction(['settings'], 'readonly');
      const store = transaction.objectStore('settings');
      const result = await this.promisifyRequest(store.getAll());
      
      const settings = {};
      result.forEach(item => {
        settings[item.key] = item.value;
      });
      
      return settings;
    } catch (error) {
      console.error('‚ùå Failed to get all settings:', error);
      return {};
    }
  }
  
  // Helper to promisify IndexedDB requests
  promisifyRequest(request) {
    return new Promise((resolve, reject) => {
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
  
  // Update offline status
  setOfflineStatus(isOffline) {
    this.isOffline = isOffline;
    if (!isOffline) {
      // Process any queued offline actions
      this.processOfflineQueue();
    }
  }
}

// Initialize the data manager
window.performaDataManager = new PerformaDataManager();

// Listen for online/offline events to update data manager
window.addEventListener('online', () => {
  window.performaDataManager.setOfflineStatus(false);
});

window.addEventListener('offline', () => {
  window.performaDataManager.setOfflineStatus(true);
});

// Enhanced localStorage fallback for critical settings
class PerformaStorageManager {
  static setItem(key, value) {
    try {
      // Try IndexedDB first
      if (window.performaDataManager && window.performaDataManager.db) {
        window.performaDataManager.saveSetting(key, value);
      }
      
      // Fallback to localStorage
      localStorage.setItem(`performa_${key}`, JSON.stringify({
        value,
        timestamp: Date.now()
      }));
    } catch (error) {
      console.warn('‚ö†Ô∏è Storage failed:', error);
    }
  }
  
  static async getItem(key, defaultValue = null) {
    try {
      // Try IndexedDB first
      if (window.performaDataManager && window.performaDataManager.db) {
        const value = await window.performaDataManager.getSetting(key);
        if (value !== null) return value;
      }
      
      // Fallback to localStorage
      const item = localStorage.getItem(`performa_${key}`);
      if (item) {
        const parsed = JSON.parse(item);
        return parsed.value;
      }
      
      return defaultValue;
    } catch (error) {
      console.warn('‚ö†Ô∏è Failed to get item from storage:', error);
      return defaultValue;
    }
  }
  
  static removeItem(key) {
    try {
      localStorage.removeItem(`performa_${key}`);
      
      if (window.performaDataManager && window.performaDataManager.db) {
        const transaction = window.performaDataManager.db.transaction(['settings'], 'readwrite');
        const store = transaction.objectStore('settings');
        store.delete(key);
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Failed to remove item from storage:', error);
    }
  }
}

// Make storage manager globally available
window.PerformaStorage = PerformaStorageManager;

// Initialize memory manager for leak prevention
window.memoryManager = new MemoryManager();

// Utility function to get cached DOM elements
window.getElement = (id) => {
  return window.memoryManager ? window.memoryManager.getCachedElement(id) : document.getElementById(id);
};

console.log('üíæ Enhanced data persistence system initialized');
console.log('üßπ Memory management system initialized - leak prevention active');

</script>
</body>
</html>